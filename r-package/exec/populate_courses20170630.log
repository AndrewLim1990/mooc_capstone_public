Biobank1x_1T2017 demographic_multiple_choice already exists. Ignoring.
Biobank1x_1T2017 open_assessment already exists. Ignoring.
Biobank1x_1T2017 generalized_video_heat already exists. Ignoring.
Biobank1x_1T2017 generalized_video_axis already exists. Ignoring.
Biobank1x_1T2017 generalized_demographics already exists. Ignoring.
Biobank1x_1T2017 forum_posts already exists. Ignoring.
Biobank1x_1T2017 forum_searches already exists. Ignoring.
Biobank1x_1T2017 forum_views already exists. Ignoring.
Biobank1x_1T2017 tower_item already exists. Ignoring.
Biobank1x_1T2017 tower_engage_dirt already exists. Ignoring.
Biobank1x_1T2017 course_axis already exists. Ignoring.
Biobank1x_1T2017 external_link_dirt already exists. Ignoring.
Biobank1x_1T2017 page_dirt already exists. Ignoring.
Could not parse Checkbox Group


Before biospecimens are released from a biobank, the following documents will have been submitted by a researcher and reviewed as part of the application process: 

Biobank application form
A standard operating procedure for the collection of the biospecimen
Document showing ethics approval of the research study
Completed material transfer agreement



Could not parse Checkbox Group


Upon receipt of biospecimens, the following will be documented.

Date and time the shipment was received 
Confirmation that specimens received match those listed on the manifest 
The number and types of labels affixed to the packaging
Result of inspection of package and container for visible signs of damage 



Could not parse problem


Dr. Aldrin’s data generates interest from a pulmonary pathologist at St. Cloud Hospital in Minnesota, Dr. Marsha Eriksen, who obtains approval to obtain frozen sputum supernatants from the TB patients in Dr. Scherbatsky’s clinic. Dr. Aldrin asks Barnabus to arrange the shipment of these specimens to Dr. Eriksen. How will Barnabus verify that enough supernatant remains to send to Dr. Eriksen? 
Choose an option from the dropdown menu

Ask Dr. Aldrin how much of the supernatants she used in her ELISA experiments
Check the computer inventory system



Could not parse Checkbox Group


What class of biospecimen will Barnabus be shipping to Minnesota? 

UN2814
UN3373
UN2873



Could not parse Checkbox Group


Does the shipment Barnabus is preparing to send to Minnesota contain dangerous goods?  

Yes
No



Could not parse Checkbox Group


Read the following statements and select the items that apply. Biospecimen annotation:

A.	Is the process by which a biospecimen is associated with participant and biospecimen related data such as patient demographics, diagnosis, collection, biospecimen type, storage conditions. 
B.	Is the detailed location where biospecimen data is stored in a data management system. 
C.	Allows for a better understanding of the banked biospecimen, making it more valuable for answering a researcher's complex questions 
D.	Should be verified for accuracy. 



Could not parse Checkbox Group


Determining the level of annotation needed will depend on:  

A.	The type of research the biospecimens will be used for.
B.	The feasibility of annotation based on the timeframe, costs, and effort required for collection of required data.
C.	An assessment of the MTA form provided to researchers. 
D.	The ability to create a duplicate copy of all data from an existing database and store it in your own database.



Could not parse Checkbox Group


Select the three data sets that may be collected at the outset by a small biobank creating a prospective collection.

Diagnosis
Consent
Biospecimen collection
Patient outcomes



Could not parse Checkbox Group


Some data management systems may have interoperability and integration capabilities. The benefits of using an interoperable system are:

A.	Reduced re-entry of data and lower risk of error. 
B.	Addressing custodianship and privacy issues around transfer and data sharing. 
C.	Identification and correction of data errors are replicated in all systems.
D.	The ability to integrate and store scanned documents.



Could not parse problem


Data element definitions should be regularly reviewed and updated to ensure that interpretations of each data field correspond to current best practices.  

True
False



Could not parse problem


Information irrevocably stripped of direct identifiers where re-linkage is not possible is defined as: 



Directly identifying information
Anonymized information
Coded information



Could not parse Checkbox Group


During your interview with the World Health Organization you were asked to define what a biobank is. Which of the following statements best describe the activity known as biobanking? 

Any biological material taken from a person for medical or research purposes.
A range of linked processes focused on participant enrollment, collection, processing, annotation, storage, release and distribution of biospecimens and data. 
The structure or framework that defines how a biobank will operate, who is responsible for the biobank’s operations and how decisions involving the biobank’s activities are made.
The activity of planning and starting a biobank.



Could not parse problem


The consensus from the participant organizations was that biobanking efforts emerging from the consultation process be multi-use, on a national or sub-regional level, and provide storage and oversight of samples from a wider array of diseases, and not focus exclusively on Ebola.

True
False



Could not parse problem


The draft proposal for the Ebola biobank has been given to you. The proposal has a complex organizational structure, spanning different countries, with multiple research priorities, and different cultural sensitivities. Defining a governance structure can help define how the biobank operates, and who has responsibility for operations and decisions. 

True
False



Could not parse problem


Biobank governance is the framework that serves to ensure that the biobank operates within the applicable laws and regulations, as well as within the cultural and ethical standards of the society in which it is located. Mechanisms can be categorized as internal or external. Internal mechanisms of governance are those that a biobank has no influence over but must fulfill or address. 

True
False



Could not parse Checkbox Group


In what cases may an ethics review board require additional information with your application?

Use of biospecimens for genetic research
Derivation of stem cell lines 
Plans to aliquot biospecimens for storage and distribution at different times 
Involvement of special populations 



Could not parse problem


Ebola virus is a contagious and highly dangerous virus. Storage of samples from the Ebola virus outbreak containing live virus requires a high-containment laboratory and special safety precautions. Each country will have its own specific safety requirements 

True
False



Could not parse Checkbox Group


Dry ice is commonly used to maintain frozen temperatures (at or below -70°C) during shipment of frozen biospecimens. When transferring frozen Ebola specimens between biobank sites, what are the requirements for shipping by air with dry ice? 

The UN 1845 Class 9 miscellaneous "dry ice" label affixed on the outer packaging.
The Category B, UN3373 biospecimens label affixed to the outer packaging.
The amount of dry ice used in the shipment (in kilograms) is written on the dry ice label. 
The IATA Checklist documentation for dry ice. 



Could not parse Checkbox Group


Biospecimens shipped on dry ice must be packaged in a specific manner to meet regulations. Which of the following are required when preparing a package for shipment? 

Primary container 
Secondary container 
Tertiary container
Absorbent material 
Waterproof wrapping
Outer container 



Could not parse problem


International partners from Medecins sans Frontiers, Italy, European Mobile Laboratories, South Africa, Public Health England, China, the US Centers for Disease Control, US National Institutes of Health have transferred approximately 16,000 samples out of Western Africa. A MTA may be required when transferring biospecimens to an outside centre. MTA is the abbreviation for material transport arrangement.

True
False



Could not parse Checkbox Group


What are some challenges the unified Ebola biobank has identified when managing transfers of biospecimens between sites? 

Lack of centralized processes and single chain of command 
Lack of availability of copies of MTAs used for prior transfers of samples 
Differing national processes 
Laboratories in different countries operate on different time zones and coordinating shipments is challenging
High cost of shipping frozen biospecimens internationally will be prohibitive 



Could not parse Checkbox Group


Biospecimen labelling is an important component of tracking biospecimens throughout their pathway from point of collection and origin, storage and shipping, and distribution. Which of the following are best practices for creating a biospecimen label? 

Remain tightly adhered to the container under all projected storage conditions
Always use 2D barcodes because they are superior to 1D barcodes
Placed in a location on the container that allows for label legibility
Resistant to all common laboratory solvents (e.g. ethanol) 



Could not parse problem


What could be the impact of the issues highlighted by the H3 biobank on future research using these Ebola Virus specimens?
Differences in the way biospecimens are collected and stored are examples of preanalytical variables and these can impact research results 

True
False



Could not parse Checkbox Group


Some of the biospecimens collected during the Ebola outbreak were likely preserved by formalin-fixation and embedding in paraffin. This method of preservation allows tissues to be prepared into FFPE tissue blocks, suitable for thin sectioning by microtome for morphological and molecular analysis. What are advantages of this format?

Universal application in clinical pathology
Considered best format for preserving proteins, RNA, DNA
Provides optimal morphological preservation 
It is the optimal fixation technique for fatty tissues and thick pieces of tissue



Could not parse Checkbox Group


Cryopreservation is a process used for slowing the activity of cellular pathways in biological tissues and preventing nucleic acid and protein degradation. Many of the biospecimens collected in the Ebola outbreak would have been cryopreserved to help maintain their utility long-term. Which of the following are examples of cryopreservation by ultra-rapid freezing? 

Placing the tissue in 10:1 parts formalin to tissue sample volume for 12-24 hours
Embedding the tissue in paraffin and placing it in the -80ºC freezer
Embedding tissue in a cryomold with a cryoembedding compound and then freezing on with cooled isopetane  
Placing the tissue into a liquid nitrogen charged dry shipper/vapour dewar 



Could not parse Checkbox Group


Sample type and associated data can impact a sample’s value for clinical and research applications. How are participants in the Ebola biobank considering increasing the value of collected samples?  

Isolating viruses 
Annotating biospecimens
Extracting genetic information 
Creating tissue arrays of infected tissue biospecimens
Linking clinical and research databases 



Could not parse Checkbox Group


What should be considered when processing a biospecimen for storage in a biobank for future research?  

Downstream research application and what is the most appropriate preservation method 
Documenting the collection time so this factor can be considered in future analyses 
Collecting biospecimens only in standard clinical formats, such as FFPE
Collecting only a cryopreserved aliquot of each biospecimen to allow for high quality RNA extraction
Setting achievable minimum and maximum collection time benchmarks 



Could not parse Checkbox Group


What factors affecting sample value were noted by the workshop participants? 

Sample quality, storage time and conditions 
Volume of sample and associated metadata
Mutations in the isolated virus 
Location of infected individual in the outbreak
Relative timing in the course of the outbreak 



Could not parse Checkbox Group


It will be important for partners in the Ebola biobank to develop a quality management system that includes policies for quality control of biospecimens. Which of the following are examples of quality control approaches the Ebola biobank might adopt? 

Microscopic examination by a pathologist of an aliquot representative of a tissue biospecimen to establish cellular composition 
Assessing the quality of nucleic acids
Create an empirical scoring system based on the collection time of the biospecimen
Creating a tissue microarray from biospecimens



Could not parse Checkbox Group


Which samples in the existing Ebola virus collections were considered particularly valuable? 

Positive samples, in a series, with associated clinical or epidemiological data 
Positive samples, collected at random time-points from patients who survived infection with Ebola virus, with associated clinical or epidemiological data
Negative samples from patients who were exposed to the disease but demonstrated resistance, with associated clinical and genetic data



Could not parse Checkbox Group


Your friend requires control samples of human plasma for her study to compare to those from Ebola virus survivors. What should she consider when deciding whether to collect biospecimens herself or use a biobank’s service?

Her level of biobanking experience, time available to devote to biobanking, and whether she has sufficient funding to establish and maintain a biobank  
Whether her research study is retrospective or prospective in design, and if she plans a series of studies based on the same biospecimens 
Whether an application to the biobank to access biospecimens and data is required, and how much time it would take to complete
Whether the biospecimens required need to be fresh or preserved, and associated with the patient outcome data 



Could not parse Checkbox Group


Which of the following are typical steps in the process of applying to a biobank for access to biospecimens and data? 

Application Assessment 
Submission of Application Form 
Provision of documentation of biosafety training certificate
Initial Inquiry 
Completion of MTA



Could not parse problem


Your friend is interested in obtaining 500 Ebola positive blood samples with patient outcomes data. Is this available in the PHE-MOHS Ebola Biobank? 

Yes
No



Multiple Choice JSON Ready
Assessment JSON Ready
Biobank1x_1T2017 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Biobank1x_1T2017 wrangle_video already exists. Ignoring.
Biobank1x_1T2017 wrangle_link_page already exists. Ignoring.
Biobank1x_1T2017 wrangle_general already exists. Ignoring.
CW1_1x_1T2016 demographic_multiple_choice already exists. Ignoring.
CW1_1x_1T2016 open_assessment already exists. Ignoring.
CW1_1x_1T2016 generalized_video_heat already exists. Ignoring.
CW1_1x_1T2016 generalized_video_axis already exists. Ignoring.
CW1_1x_1T2016 generalized_demographics already exists. Ignoring.
CW1_1x_1T2016 forum_posts already exists. Ignoring.
CW1_1x_1T2016 forum_searches already exists. Ignoring.
CW1_1x_1T2016 forum_views already exists. Ignoring.
CW1_1x_1T2016 tower_item already exists. Ignoring.
CW1_1x_1T2016 tower_engage_dirt already exists. Ignoring.
CW1_1x_1T2016 course_axis already exists. Ignoring.
CW1_1x_1T2016 external_link_dirt already exists. Ignoring.
CW1_1x_1T2016 page_dirt already exists. Ignoring.
Could not parse problem

Use this list to determine which of your openings checks the most boxes; this should let you know which is the most effective opening for your novel and why. This exercise is being graded for completion, so remember to click 'CHECK' after typing your answers.
Who are the main characters?



Where is this set?



When is this set?



Have I packed my reader a carry-on (provided the basic who/what/where in the opening paragraphs / page that they’ll need to carry with them throughout the story)?



Which POV have I chosen? What effect is this having on the piece as a whole?



Am I writing in present tense or past tense? Why? What effect is this having on my story?



What is my story about? Summarize as you would a news story.



What is the catalyst for the telling of the story?



What will be my theme? Have I gestured towards this in any way with my opening?



Which of my three openings features the elements that are most important to me?



Which of my three openings surprised me the most? Why?




Multiple Choice JSON Ready
Assessment JSON Ready
CW1_1x_1T2016 wrangle_overview_engagement already exists. Ignoring.
CW1_1x_1T2016 wrangle_forum already exists. Ignoring.
CW1_1x_1T2016 wrangle_video already exists. Ignoring.
CW1_1x_1T2016 wrangle_link_page already exists. Ignoring.
CW1_1x_1T2016 wrangle_general already exists. Ignoring.
CW1_1x_1T2017 demographic_multiple_choice already exists. Ignoring.
CW1_1x_1T2017 open_assessment already exists. Ignoring.
CW1_1x_1T2017 generalized_video_heat already exists. Ignoring.
CW1_1x_1T2017 generalized_video_axis already exists. Ignoring.
CW1_1x_1T2017 generalized_demographics already exists. Ignoring.
CW1_1x_1T2017 forum_posts already exists. Ignoring.
CW1_1x_1T2017 forum_searches already exists. Ignoring.
CW1_1x_1T2017 forum_views already exists. Ignoring.
CW1_1x_1T2017 tower_item already exists. Ignoring.
CW1_1x_1T2017 tower_engage_dirt already exists. Ignoring.
CW1_1x_1T2017 course_axis already exists. Ignoring.
CW1_1x_1T2017 external_link_dirt already exists. Ignoring.
CW1_1x_1T2017 page_dirt already exists. Ignoring.
Could not parse problem

Use this list to determine which of your openings checks the most boxes; this should let you know which is the most effective opening for your novel and why. This exercise is being graded for completion, so remember to click 'CHECK' after typing your answers.
Who are the main characters?



Where is this set?



When is this set?



Have I packed my reader a carry-on (provided the basic who/what/where in the opening paragraphs / page that they’ll need to carry with them throughout the story)?



Which POV have I chosen? What effect is this having on the piece as a whole?



Am I writing in present tense or past tense? Why? What effect is this having on my story?



What is my story about? Summarize as you would a news story.



What is the catalyst for the telling of the story?



What will be my theme? Have I gestured towards this in any way with my opening?



Which of my three openings features the elements that are most important to me?



Which of my three openings surprised me the most? Why?




Multiple Choice JSON Ready
Assessment JSON Ready
CW1_1x_1T2017 wrangle_overview_engagement already exists. Ignoring.
CW1_1x_1T2017 wrangle_forum already exists. Ignoring.
CW1_1x_1T2017 wrangle_video already exists. Ignoring.
CW1_1x_1T2017 wrangle_link_page already exists. Ignoring.
CW1_1x_1T2017 wrangle_general already exists. Ignoring.
CW1_1x_3T2016 demographic_multiple_choice already exists. Ignoring.
CW1_1x_3T2016 open_assessment already exists. Ignoring.
CW1_1x_3T2016 generalized_video_heat already exists. Ignoring.
CW1_1x_3T2016 generalized_video_axis already exists. Ignoring.
CW1_1x_3T2016 generalized_demographics already exists. Ignoring.
CW1_1x_3T2016 forum_posts already exists. Ignoring.
CW1_1x_3T2016 forum_searches already exists. Ignoring.
CW1_1x_3T2016 forum_views already exists. Ignoring.
CW1_1x_3T2016 tower_item already exists. Ignoring.
CW1_1x_3T2016 tower_engage_dirt already exists. Ignoring.
CW1_1x_3T2016 course_axis already exists. Ignoring.
CW1_1x_3T2016 external_link_dirt already exists. Ignoring.
CW1_1x_3T2016 page_dirt already exists. Ignoring.
Could not parse problem

Use this list to determine which of your openings checks the most boxes; this should let you know which is the most effective opening for your novel and why. This exercise is being graded for completion, so remember to click 'CHECK' after typing your answers.
Who are the main characters?



Where is this set?



When is this set?



Have I packed my reader a carry-on (provided the basic who/what/where in the opening paragraphs / page that they’ll need to carry with them throughout the story)?



Which POV have I chosen? What effect is this having on the piece as a whole?



Am I writing in present tense or past tense? Why? What effect is this having on my story?



What is my story about? Summarize as you would a news story.



What is the catalyst for the telling of the story?



What will be my theme? Have I gestured towards this in any way with my opening?



Which of my three openings features the elements that are most important to me?



Which of my three openings surprised me the most? Why?




Multiple Choice JSON Ready
Assessment JSON Ready
CW1_1x_3T2016 wrangle_overview_engagement already exists. Ignoring.
CW1_1x_3T2016 wrangle_forum already exists. Ignoring.
CW1_1x_3T2016 wrangle_video already exists. Ignoring.
CW1_1x_3T2016 wrangle_link_page already exists. Ignoring.
CW1_1x_3T2016 wrangle_general already exists. Ignoring.
CW1_2x_1T2016 demographic_multiple_choice already exists. Ignoring.
CW1_2x_1T2016 open_assessment already exists. Ignoring.
CW1_2x_1T2016 generalized_video_heat already exists. Ignoring.
CW1_2x_1T2016 generalized_video_axis already exists. Ignoring.
CW1_2x_1T2016 generalized_demographics already exists. Ignoring.
CW1_2x_1T2016 forum_posts already exists. Ignoring.
CW1_2x_1T2016 forum_searches already exists. Ignoring.
CW1_2x_1T2016 forum_views already exists. Ignoring.
CW1_2x_1T2016 tower_item already exists. Ignoring.
CW1_2x_1T2016 tower_engage_dirt already exists. Ignoring.
CW1_2x_1T2016 course_axis already exists. Ignoring.
CW1_2x_1T2016 external_link_dirt already exists. Ignoring.
CW1_2x_1T2016 page_dirt already exists. Ignoring.
Could not parse problem


Use this list to determine which of your openings checks the most boxes; this should let you know which is the most effective opening for your novel and why. This exercise is being graded for completion, so remember to click 'CHECK' after typing your answers. If you navigate away from the page before clicking 'CHECK' your answers will disappear.
Who are the main characters?



Where is this set?



When is this set?



Have I packed my reader a carry-on (provided the basic who/what/where in the opening paragraphs / page that they’ll need to carry with them throughout the story)?



Which POV have I chosen? What effect is this having on the piece as a whole?



Am I writing in present tense or past tense? Why? What effect is this having on my story?



What is my story about? Summarize as you would a news story.



What is the catalyst for the telling of the story?



What will be my theme? Have I gestured towards this in any way with my opening?



Which of my three openings features the elements that are most important to me?



Which of my three openings surprised me the most? Why?





Multiple Choice JSON Ready
Assessment JSON Ready
CW1_2x_1T2016 wrangle_overview_engagement already exists. Ignoring.
CW1_2x_1T2016 wrangle_forum already exists. Ignoring.
CW1_2x_1T2016 wrangle_video already exists. Ignoring.
CW1_2x_1T2016 wrangle_link_page already exists. Ignoring.
CW1_2x_1T2016 wrangle_general already exists. Ignoring.
CW1_2x_1T2017 demographic_multiple_choice already exists. Ignoring.
CW1_2x_1T2017 open_assessment already exists. Ignoring.
CW1_2x_1T2017 generalized_video_heat already exists. Ignoring.
CW1_2x_1T2017 generalized_video_axis already exists. Ignoring.
CW1_2x_1T2017 generalized_demographics already exists. Ignoring.
CW1_2x_1T2017 forum_posts already exists. Ignoring.
CW1_2x_1T2017 forum_searches already exists. Ignoring.
CW1_2x_1T2017 forum_views already exists. Ignoring.
CW1_2x_1T2017 tower_item already exists. Ignoring.
CW1_2x_1T2017 tower_engage_dirt already exists. Ignoring.
CW1_2x_1T2017 course_axis already exists. Ignoring.
CW1_2x_1T2017 external_link_dirt already exists. Ignoring.
CW1_2x_1T2017 page_dirt already exists. Ignoring.
Could not parse problem


Use this list to determine which of your openings checks the most boxes; this should let you know which is the most effective opening for your novel and why. This exercise is being graded for completion, so remember to click 'SUBMIT' after typing your answers. If you navigate away from the page before clicking 'SUBMIT' your answers will disappear.
Who are the main characters?



Where is this set?



When is this set?
    



Have I packed my reader a carry-on (provided the basic who/what/where in the opening paragraphs / page that they’ll need to carry with them throughout the story)?



Which POV have I chosen? What effect is this having on the piece as a whole?



Am I writing in present tense or past tense? Why? What effect is this having on my story?



What is my story about? Summarize as you would a news story.



What is the catalyst for the telling of the story?



What will be my theme? Have I gestured towards this in any way with my opening?



Which of my three openings features the elements that are most important to me?



Which of my three openings surprised me the most? Why?





Multiple Choice JSON Ready
Assessment JSON Ready
CW1_2x_1T2017 wrangle_overview_engagement already exists. Ignoring.
CW1_2x_1T2017 wrangle_forum already exists. Ignoring.
CW1_2x_1T2017 wrangle_video already exists. Ignoring.
CW1_2x_1T2017 wrangle_link_page already exists. Ignoring.
CW1_2x_1T2017 wrangle_general already exists. Ignoring.
CW1_2x_3T2016 demographic_multiple_choice already exists. Ignoring.
CW1_2x_3T2016 open_assessment already exists. Ignoring.
CW1_2x_3T2016 generalized_video_heat already exists. Ignoring.
CW1_2x_3T2016 generalized_video_axis already exists. Ignoring.
CW1_2x_3T2016 generalized_demographics already exists. Ignoring.
CW1_2x_3T2016 forum_posts already exists. Ignoring.
CW1_2x_3T2016 forum_searches already exists. Ignoring.
CW1_2x_3T2016 forum_views already exists. Ignoring.
CW1_2x_3T2016 tower_item already exists. Ignoring.
CW1_2x_3T2016 tower_engage_dirt already exists. Ignoring.
CW1_2x_3T2016 course_axis already exists. Ignoring.
CW1_2x_3T2016 external_link_dirt already exists. Ignoring.
CW1_2x_3T2016 page_dirt already exists. Ignoring.
Could not parse problem


Use this list to determine which of your openings checks the most boxes; this should let you know which is the most effective opening for your novel and why. This exercise is being graded for completion, so remember to click 'SUBMIT' after typing your answers. If you navigate away from the page before clicking 'SUBMIT' your answers will disappear.
Who are the main characters?



Where is this set?



When is this set?
    



Have I packed my reader a carry-on (provided the basic who/what/where in the opening paragraphs / page that they’ll need to carry with them throughout the story)?



Which POV have I chosen? What effect is this having on the piece as a whole?



Am I writing in present tense or past tense? Why? What effect is this having on my story?



What is my story about? Summarize as you would a news story.



What is the catalyst for the telling of the story?



What will be my theme? Have I gestured towards this in any way with my opening?



Which of my three openings features the elements that are most important to me?



Which of my three openings surprised me the most? Why?





Multiple Choice JSON Ready
Assessment JSON Ready
CW1_2x_3T2016 wrangle_overview_engagement already exists. Ignoring.
CW1_2x_3T2016 wrangle_forum already exists. Ignoring.
CW1_2x_3T2016 wrangle_video already exists. Ignoring.
CW1_2x_3T2016 wrangle_link_page already exists. Ignoring.
CW1_2x_3T2016 wrangle_general already exists. Ignoring.
China300_1x_1T2016 demographic_multiple_choice already exists. Ignoring.
China300_1x_1T2016 open_assessment already exists. Ignoring.
China300_1x_1T2016 generalized_video_heat already exists. Ignoring.
China300_1x_1T2016 generalized_video_axis already exists. Ignoring.
China300_1x_1T2016 generalized_demographics already exists. Ignoring.
China300_1x_1T2016 forum_posts already exists. Ignoring.
China300_1x_1T2016 forum_searches already exists. Ignoring.
China300_1x_1T2016 forum_views already exists. Ignoring.
China300_1x_1T2016 tower_item already exists. Ignoring.
China300_1x_1T2016 tower_engage_dirt already exists. Ignoring.
China300_1x_1T2016 course_axis already exists. Ignoring.
China300_1x_1T2016 external_link_dirt already exists. Ignoring.
China300_1x_1T2016 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
China300_1x_1T2016 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
China300_1x_1T2016 wrangle_video already exists. Ignoring.
China300_1x_1T2016 wrangle_link_page already exists. Ignoring.
China300_1x_1T2016 wrangle_general already exists. Ignoring.
China300_1x_3T2015 demographic_multiple_choice already exists. Ignoring.
China300_1x_3T2015 open_assessment already exists. Ignoring.
China300_1x_3T2015 generalized_video_heat already exists. Ignoring.
China300_1x_3T2015 generalized_video_axis already exists. Ignoring.
China300_1x_3T2015 generalized_demographics already exists. Ignoring.
China300_1x_3T2015 forum_posts already exists. Ignoring.
China300_1x_3T2015 forum_searches already exists. Ignoring.
China300_1x_3T2015 forum_views already exists. Ignoring.
China300_1x_3T2015 tower_item already exists. Ignoring.
China300_1x_3T2015 tower_engage_dirt already exists. Ignoring.
China300_1x_3T2015 course_axis already exists. Ignoring.
China300_1x_3T2015 external_link_dirt already exists. Ignoring.
China300_1x_3T2015 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
China300_1x_3T2015 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
China300_1x_3T2015 wrangle_video already exists. Ignoring.
China300_1x_3T2015 wrangle_link_page already exists. Ignoring.
China300_1x_3T2015 wrangle_general already exists. Ignoring.
China300_1x_3T2016 demographic_multiple_choice already exists. Ignoring.
China300_1x_3T2016 open_assessment already exists. Ignoring.
China300_1x_3T2016 generalized_video_heat already exists. Ignoring.
China300_1x_3T2016 generalized_video_axis already exists. Ignoring.
China300_1x_3T2016 generalized_demographics already exists. Ignoring.
China300_1x_3T2016 forum_posts already exists. Ignoring.
China300_1x_3T2016 forum_searches already exists. Ignoring.
China300_1x_3T2016 forum_views already exists. Ignoring.
China300_1x_3T2016 tower_item already exists. Ignoring.
China300_1x_3T2016 tower_engage_dirt already exists. Ignoring.
China300_1x_3T2016 course_axis already exists. Ignoring.
China300_1x_3T2016 external_link_dirt already exists. Ignoring.
China300_1x_3T2016 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
China300_1x_3T2016 wrangle_overview_engagement already exists. Ignoring.
China300_1x_3T2016 wrangle_forum already exists. Ignoring.
China300_1x_3T2016 wrangle_video already exists. Ignoring.
China300_1x_3T2016 wrangle_link_page already exists. Ignoring.
China300_1x_3T2016 wrangle_general already exists. Ignoring.
China300_2x_1T2016 demographic_multiple_choice already exists. Ignoring.
China300_2x_1T2016 open_assessment already exists. Ignoring.
China300_2x_1T2016 generalized_video_heat already exists. Ignoring.
China300_2x_1T2016 generalized_video_axis already exists. Ignoring.
China300_2x_1T2016 generalized_demographics already exists. Ignoring.
China300_2x_1T2016 forum_posts already exists. Ignoring.
China300_2x_1T2016 forum_searches already exists. Ignoring.
China300_2x_1T2016 forum_views already exists. Ignoring.
China300_2x_1T2016 tower_item already exists. Ignoring.
China300_2x_1T2016 tower_engage_dirt already exists. Ignoring.
China300_2x_1T2016 course_axis already exists. Ignoring.
China300_2x_1T2016 external_link_dirt already exists. Ignoring.
China300_2x_1T2016 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
China300_2x_1T2016 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
China300_2x_1T2016 wrangle_video already exists. Ignoring.
China300_2x_1T2016 wrangle_link_page already exists. Ignoring.
China300_2x_1T2016 wrangle_general already exists. Ignoring.
China300_2x_3T2015 demographic_multiple_choice already exists. Ignoring.
China300_2x_3T2015 open_assessment already exists. Ignoring.
China300_2x_3T2015 generalized_video_heat already exists. Ignoring.
China300_2x_3T2015 generalized_video_axis already exists. Ignoring.
China300_2x_3T2015 generalized_demographics already exists. Ignoring.
China300_2x_3T2015 forum_posts already exists. Ignoring.
China300_2x_3T2015 forum_searches already exists. Ignoring.
China300_2x_3T2015 forum_views already exists. Ignoring.
China300_2x_3T2015 tower_item already exists. Ignoring.
China300_2x_3T2015 tower_engage_dirt already exists. Ignoring.
China300_2x_3T2015 course_axis already exists. Ignoring.
China300_2x_3T2015 external_link_dirt already exists. Ignoring.
China300_2x_3T2015 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
China300_2x_3T2015 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
China300_2x_3T2015 wrangle_video already exists. Ignoring.
China300_2x_3T2015 wrangle_link_page already exists. Ignoring.
China300_2x_3T2015 wrangle_general already exists. Ignoring.
China300_2x_3T2016 demographic_multiple_choice already exists. Ignoring.
China300_2x_3T2016 open_assessment already exists. Ignoring.
China300_2x_3T2016 generalized_video_heat already exists. Ignoring.
China300_2x_3T2016 generalized_video_axis already exists. Ignoring.
China300_2x_3T2016 generalized_demographics already exists. Ignoring.
China300_2x_3T2016 forum_posts already exists. Ignoring.
China300_2x_3T2016 forum_searches already exists. Ignoring.
China300_2x_3T2016 forum_views already exists. Ignoring.
China300_2x_3T2016 tower_item already exists. Ignoring.
China300_2x_3T2016 tower_engage_dirt already exists. Ignoring.
China300_2x_3T2016 course_axis already exists. Ignoring.
China300_2x_3T2016 external_link_dirt already exists. Ignoring.
China300_2x_3T2016 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
China300_2x_3T2016 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
China300_2x_3T2016 wrangle_video already exists. Ignoring.
China300_2x_3T2016 wrangle_link_page already exists. Ignoring.
China300_2x_3T2016 wrangle_general already exists. Ignoring.
China300x_3T2014 demographic_multiple_choice already exists. Ignoring.
China300x_3T2014 open_assessment already exists. Ignoring.
China300x_3T2014 generalized_video_heat already exists. Ignoring.
China300x_3T2014 generalized_video_axis already exists. Ignoring.
China300x_3T2014 generalized_demographics already exists. Ignoring.
China300x_3T2014 forum_posts already exists. Ignoring.
China300x_3T2014 forum_searches already exists. Ignoring.
China300x_3T2014 forum_views already exists. Ignoring.
China300x_3T2014 tower_item already exists. Ignoring.
China300x_3T2014 tower_engage_dirt already exists. Ignoring.
China300x_3T2014 course_axis already exists. Ignoring.
China300x_3T2014 external_link_dirt already exists. Ignoring.
China300x_3T2014 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
China300x_3T2014 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
China300x_3T2014 wrangle_video already exists. Ignoring.
China300x_3T2014 wrangle_link_page already exists. Ignoring.
China300x_3T2014 wrangle_general already exists. Ignoring.
Climate101x_3T2015 demographic_multiple_choice already exists. Ignoring.
Climate101x_3T2015 open_assessment already exists. Ignoring.
Climate101x_3T2015 generalized_video_heat already exists. Ignoring.
Climate101x_3T2015 generalized_video_axis already exists. Ignoring.
Climate101x_3T2015 generalized_demographics already exists. Ignoring.
Climate101x_3T2015 forum_posts already exists. Ignoring.
Climate101x_3T2015 forum_searches already exists. Ignoring.
Climate101x_3T2015 forum_views already exists. Ignoring.
Climate101x_3T2015 tower_item already exists. Ignoring.
Climate101x_3T2015 tower_engage_dirt already exists. Ignoring.
Climate101x_3T2015 course_axis already exists. Ignoring.
Climate101x_3T2015 external_link_dirt already exists. Ignoring.
Climate101x_3T2015 page_dirt already exists. Ignoring.
Could not parse problem

Water boils at 212°F. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert from Fahrenheit to Celsius, first subtract 32, then multiply by 5, then divide by 9
°C = (°F-32)*5/9.



Could not parse problem

Earth’s global average temperature is about 15°C today. What is that temperature in kelvin (K)? (Enter a number)





Explanation 
To convert from °C to kelvin (K), add 273 (or, to be more precise, add 273.15). 
K = °C + 273.15 
The answer you see above, [288,288.15],  means that the system will accept answers between 288 and 288.15, since it depends whether you used 273 or 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.
These two scales, Celsius and kelvin, are simply offset from one another.  Each one degree change in Celsius represents the same change in temperature as a one degree change in kelvin.  It's just that on the Celsius scale, 0 is defined as the freezing point of water, and on the kelvin scale, 0 is defined as absolute zero.



Could not parse problem

Wintertime air temperature at the South Pole is about -58°C. What is that temperature in Fahrenheit (°F)? (Enter a number)





Explanation
To convert from °C to °F, multiply by 9, divide by 5, then add 32
°F = (°C*9/5) + 32

Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.




Could not parse problem

Warm tropical surface ocean temperatures are around 300 K. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert kelvin to °C, subtract 273 (or, to be more precise, subtract 273.15). 
°C = K - 273.15  
Again, the answer you see above, [26.85,27] just means that the system accepts answers between 26.85 and 27, since you might have used 273, or you might have used 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

The Sun’s surface is about 6000 K. What is that temperature in Fahrenheit (°F)? (Enter a number.)





Explanation
To convert from kelvin (K) to Fahrenheit (°F), subtract 273.15, then multiply by 9, then divide by 5, then add 32
°F = (K-273.15)*9/5 + 32.  
With this equation, you should get 10340.33. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation. The system will accept answers from 10000 to 10341, in case you ballpark estimated this one. 



Could not parse problem

The air temperature in my city in May averages about 56°F. What is that temperature in kelvin (K)? (Enter a number)





Explanation
To convert from Fahrenheit (°F) to kelvin (K), subtract 32, then multiply by 5, divide by 9, and last, add 273.15.  
K = ((°F-32)*5/9) + 273.15. 
If you use this equation, you'll get 286.483. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

For what location did you figure out last month's temperature anomaly?




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Could not parse problem

Here you can enter the magnitude of your temperature anomaly more specifically. What is the magnitude of the temperature anomaly you figured out? If, for example, your temperature average for last month was 0.5 degrees Celsius colder than the 1980s was, enter -0.5 in the box below. If your temperature average for last month was 0.5 degrees Celsius warmer than the 1980s was, enter 0.5 in the box below. Please enter your answer in Celsius!




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Multiple Choice JSON Ready
Assessment JSON Ready
Climate101x_3T2015 wrangle_overview_engagement already exists. Ignoring.
Climate101x_3T2015 wrangle_forum already exists. Ignoring.
Climate101x_3T2015 wrangle_video already exists. Ignoring.
Climate101x_3T2015 wrangle_link_page already exists. Ignoring.
Climate101x_3T2015 wrangle_general already exists. Ignoring.
Climate101x_3T2015 wrangle_assessments already exists. Ignoring.
Climate1x_1T2016 demographic_multiple_choice already exists. Ignoring.
Climate1x_1T2016 open_assessment already exists. Ignoring.
Climate1x_1T2016 generalized_video_heat already exists. Ignoring.
Climate1x_1T2016 generalized_video_axis already exists. Ignoring.
Climate1x_1T2016 generalized_demographics already exists. Ignoring.
Climate1x_1T2016 forum_posts already exists. Ignoring.
Climate1x_1T2016 forum_searches already exists. Ignoring.
Climate1x_1T2016 forum_views already exists. Ignoring.
Climate1x_1T2016 tower_item already exists. Ignoring.
Climate1x_1T2016 tower_engage_dirt already exists. Ignoring.
Climate1x_1T2016 course_axis already exists. Ignoring.
Climate1x_1T2016 external_link_dirt already exists. Ignoring.
Climate1x_1T2016 page_dirt already exists. Ignoring.
Could not parse problem

Water boils at 212°F. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert from Fahrenheit to Celsius, first subtract 32, then multiply by 5, then divide by 9
°C = (°F-32)*5/9.



Could not parse problem

Earth’s global average temperature is about 15°C today. What is that temperature in kelvin (K)? (Enter a number)





Explanation 
To convert from °C to kelvin (K), add 273 (or, to be more precise, add 273.15). 
K = °C + 273.15 
The answer you see above, [288,288.15],  means that the system will accept answers between 288 and 288.15, since it depends whether you used 273 or 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.
These two scales, Celsius and kelvin, are simply offset from one another.  Each one degree change in Celsius represents the same change in temperature as a one degree change in kelvin.  It's just that on the Celsius scale, 0 is defined as the freezing point of water, and on the kelvin scale, 0 is defined as absolute zero.



Could not parse problem

Wintertime air temperature at the South Pole is about -58°C. What is that temperature in Fahrenheit (°F)? (Enter a number)





Explanation
To convert from °C to °F, multiply by 9, divide by 5, then add 32
°F = (°C*9/5) + 32

Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.




Could not parse problem

Warm tropical surface ocean temperatures are around 300 K. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert kelvin to °C, subtract 273 (or, to be more precise, subtract 273.15). 
°C = K - 273.15  
Again, the answer you see above, [26.85,27] just means that the system accepts answers between 26.85 and 27, since you might have used 273, or you might have used 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

The Sun’s surface is about 6000 K. What is that temperature in Fahrenheit (°F)? (Enter a number.)





Explanation
To convert from kelvin (K) to Fahrenheit (°F), subtract 273.15, then multiply by 9, then divide by 5, then add 32
°F = (K-273.15)*9/5 + 32.  
With this equation, you should get 10340.33. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation. The system will accept answers from 10000 to 10341, in case you ballpark estimated this one. 



Could not parse problem

The air temperature in my city in May averages about 56°F. What is that temperature in kelvin (K)? (Enter a number)





Explanation
To convert from Fahrenheit (°F) to kelvin (K), subtract 32, then multiply by 5, divide by 9, and last, add 273.15.  
K = ((°F-32)*5/9) + 273.15. 
If you use this equation, you'll get 286.483. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

For what location did you figure out last month's temperature anomaly?




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Could not parse problem

Here you can enter the magnitude of your temperature anomaly more specifically. What is the magnitude of the temperature anomaly you figured out? If, for example, your temperature average for last month was 0.5 degrees Celsius colder than the 1980s was, enter -0.5 in the box below. If your temperature average for last month was 0.5 degrees Celsius warmer than the 1980s was, enter 0.5 in the box below. Please enter your answer in Celsius!




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Multiple Choice JSON Ready
Assessment JSON Ready
Climate1x_1T2016 wrangle_overview_engagement already exists. Ignoring.
Climate1x_1T2016 wrangle_forum already exists. Ignoring.
Climate1x_1T2016 wrangle_video already exists. Ignoring.
Climate1x_1T2016 wrangle_link_page already exists. Ignoring.
Climate1x_1T2016 wrangle_general already exists. Ignoring.
Climate1x_1T2016 wrangle_assessments already exists. Ignoring.
Climate1x_2T2016 demographic_multiple_choice already exists. Ignoring.
Climate1x_2T2016 open_assessment already exists. Ignoring.
Climate1x_2T2016 generalized_video_heat already exists. Ignoring.
Climate1x_2T2016 generalized_video_axis already exists. Ignoring.
Climate1x_2T2016 generalized_demographics already exists. Ignoring.
Climate1x_2T2016 forum_posts already exists. Ignoring.
Climate1x_2T2016 forum_searches already exists. Ignoring.
Climate1x_2T2016 forum_views already exists. Ignoring.
Climate1x_2T2016 tower_item already exists. Ignoring.
Climate1x_2T2016 tower_engage_dirt already exists. Ignoring.
Climate1x_2T2016 course_axis already exists. Ignoring.
Climate1x_2T2016 external_link_dirt already exists. Ignoring.
Climate1x_2T2016 page_dirt already exists. Ignoring.
Could not parse problem

Water boils at 212°F. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert from Fahrenheit to Celsius, first subtract 32, then multiply by 5, then divide by 9
°C = (°F-32)*5/9.



Could not parse problem

Earth’s global average temperature is about 15°C today. What is that temperature in kelvin (K)? (Enter a number)





Explanation 
To convert from °C to kelvin (K), add 273 (or, to be more precise, add 273.15). 
K = °C + 273.15 
The answer you see above, [288,288.15],  means that the system will accept answers between 288 and 288.15, since it depends whether you used 273 or 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.
These two scales, Celsius and kelvin, are simply offset from one another.  Each one degree change in Celsius represents the same change in temperature as a one degree change in kelvin.  It's just that on the Celsius scale, 0 is defined as the freezing point of water, and on the kelvin scale, 0 is defined as absolute zero.



Could not parse problem

Wintertime air temperature at the South Pole is about -58°C. What is that temperature in Fahrenheit (°F)? (Enter a number)





Explanation
To convert from °C to °F, multiply by 9, divide by 5, then add 32
°F = (°C*9/5) + 32

Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.




Could not parse problem

Warm tropical surface ocean temperatures are around 300 K. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert kelvin to °C, subtract 273 (or, to be more precise, subtract 273.15). 
°C = K - 273.15  
Again, the answer you see above, [26.85,27] just means that the system accepts answers between 26.85 and 27, since you might have used 273, or you might have used 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

The Sun’s surface is about 6000 K. What is that temperature in Fahrenheit (°F)? (Enter a number.)





Explanation
To convert from kelvin (K) to Fahrenheit (°F), subtract 273.15, then multiply by 9, then divide by 5, then add 32
°F = (K-273.15)*9/5 + 32.  
With this equation, you should get 10340.33. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation. The system will accept answers from 10000 to 10341, in case you ballpark estimated this one. 



Could not parse problem

The air temperature in my city in May averages about 56°F. What is that temperature in kelvin (K)? (Enter a number)





Explanation
To convert from Fahrenheit (°F) to kelvin (K), subtract 32, then multiply by 5, divide by 9, and last, add 273.15.  
K = ((°F-32)*5/9) + 273.15. 
If you use this equation, you'll get 286.483. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

For what location did you figure out last month's temperature anomaly?




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Could not parse problem

Here you can enter the magnitude of your temperature anomaly more specifically. What is the magnitude of the temperature anomaly you figured out? If, for example, your temperature average for last month was 0.5 degrees Celsius colder than the 1980s was, enter -0.5 in the box below. If your temperature average for last month was 0.5 degrees Celsius warmer than the 1980s was, enter 0.5 in the box below. Please enter your answer in Celsius!




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Multiple Choice JSON Ready
Assessment JSON Ready
Climate1x_2T2016 wrangle_overview_engagement already exists. Ignoring.
Climate1x_2T2016 wrangle_forum already exists. Ignoring.
Climate1x_2T2016 wrangle_video already exists. Ignoring.
Climate1x_2T2016 wrangle_link_page already exists. Ignoring.
Climate1x_2T2016 wrangle_general already exists. Ignoring.
Climate1x_2T2016 wrangle_assessments already exists. Ignoring.
Climate1x_2T2017 demographic_multiple_choice already exists. Ignoring.
Climate1x_2T2017 open_assessment already exists. Ignoring.
Climate1x_2T2017 generalized_video_heat already exists. Ignoring.
Climate1x_2T2017 generalized_video_axis already exists. Ignoring.
Climate1x_2T2017 generalized_demographics already exists. Ignoring.
Climate1x_2T2017 forum_posts already exists. Ignoring.
Climate1x_2T2017 forum_searches already exists. Ignoring.
Climate1x_2T2017 forum_views already exists. Ignoring.
Climate1x_2T2017 tower_item already exists. Ignoring.
Climate1x_2T2017 tower_engage_dirt already exists. Ignoring.
Climate1x_2T2017 course_axis already exists. Ignoring.
Climate1x_2T2017 external_link_dirt already exists. Ignoring.
Climate1x_2T2017 page_dirt already exists. Ignoring.
Could not parse problem

Water boils at 212°F. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert from Fahrenheit to Celsius, first subtract 32, then multiply by 5, then divide by 9
°C = (°F-32)*5/9.



Could not parse problem

Earth’s global average temperature is about 15°C today. What is that temperature in kelvin (K)? (Enter a number)





Explanation 
To convert from °C to kelvin (K), add 273 (or, to be more precise, add 273.15). 
K = °C + 273.15 
The answer you see above, [288,288.15],  means that the system will accept answers between 288 and 288.15, since it depends whether you used 273 or 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.
These two scales, Celsius and kelvin, are simply offset from one another.  Each one degree change in Celsius represents the same change in temperature as a one degree change in kelvin.  It's just that on the Celsius scale, 0 is defined as the freezing point of water, and on the kelvin scale, 0 is defined as absolute zero.



Could not parse problem

Wintertime air temperature at the South Pole is about -58°C. What is that temperature in Fahrenheit (°F)? (Enter a number)





Explanation
To convert from °C to °F, multiply by 9, divide by 5, then add 32
°F = (°C*9/5) + 32

Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.




Could not parse problem

Warm tropical surface ocean temperatures are around 300 K. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert kelvin to °C, subtract 273 (or, to be more precise, subtract 273.15). 
°C = K - 273.15  
Again, the answer you see above, [26.85,27] just means that the system accepts answers between 26.85 and 27, since you might have used 273, or you might have used 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

The Sun’s surface is about 6000 K. What is that temperature in Fahrenheit (°F)? (Enter a number.)





Explanation
To convert from kelvin (K) to Fahrenheit (°F), subtract 273.15, then multiply by 9, then divide by 5, then add 32
°F = (K-273.15)*9/5 + 32.  
With this equation, you should get 10340.33. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation. The system will accept answers from 10000 to 10341, in case you ballpark estimated this one. 



Could not parse problem

The air temperature in my city in May averages about 56°F. What is that temperature in kelvin (K)? (Enter a number)





Explanation
To convert from Fahrenheit (°F) to kelvin (K), subtract 32, then multiply by 5, divide by 9, and last, add 273.15.  
K = ((°F-32)*5/9) + 273.15. 
If you use this equation, you'll get 286.483. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

For what location did you figure out last month's temperature anomaly?




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Could not parse problem

Here you can enter the magnitude of your temperature anomaly more specifically. What is the magnitude of the temperature anomaly you figured out? If, for example, your temperature average for last month was 0.5 degrees Celsius colder than the 1980s was, enter -0.5 in the box below. If your temperature average for last month was 0.5 degrees Celsius warmer than the 1980s was, enter 0.5 in the box below. Please enter your answer in Celsius!




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Multiple Choice JSON Ready
Assessment JSON Ready
Climate1x_2T2017 wrangle_overview_engagement already exists. Ignoring.
Climate1x_2T2017 wrangle_forum already exists. Ignoring.
Climate1x_2T2017 wrangle_link_page already exists. Ignoring.
Climate1x_2T2017 wrangle_general already exists. Ignoring.
Climate1x_2T2017 wrangle_assessments already exists. Ignoring.
Climate1x_3T2016 demographic_multiple_choice already exists. Ignoring.
Climate1x_3T2016 open_assessment already exists. Ignoring.
Climate1x_3T2016 generalized_video_heat already exists. Ignoring.
Climate1x_3T2016 generalized_video_axis already exists. Ignoring.
Climate1x_3T2016 generalized_demographics already exists. Ignoring.
Climate1x_3T2016 forum_posts already exists. Ignoring.
Climate1x_3T2016 forum_searches already exists. Ignoring.
Climate1x_3T2016 forum_views already exists. Ignoring.
Climate1x_3T2016 tower_item already exists. Ignoring.
Climate1x_3T2016 tower_engage_dirt already exists. Ignoring.
Climate1x_3T2016 course_axis already exists. Ignoring.
Climate1x_3T2016 external_link_dirt already exists. Ignoring.
Climate1x_3T2016 page_dirt already exists. Ignoring.
Could not parse problem

Water boils at 212°F. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert from Fahrenheit to Celsius, first subtract 32, then multiply by 5, then divide by 9
°C = (°F-32)*5/9.



Could not parse problem

Earth’s global average temperature is about 15°C today. What is that temperature in kelvin (K)? (Enter a number)





Explanation 
To convert from °C to kelvin (K), add 273 (or, to be more precise, add 273.15). 
K = °C + 273.15 
The answer you see above, [288,288.15],  means that the system will accept answers between 288 and 288.15, since it depends whether you used 273 or 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.
These two scales, Celsius and kelvin, are simply offset from one another.  Each one degree change in Celsius represents the same change in temperature as a one degree change in kelvin.  It's just that on the Celsius scale, 0 is defined as the freezing point of water, and on the kelvin scale, 0 is defined as absolute zero.



Could not parse problem

Wintertime air temperature at the South Pole is about -58°C. What is that temperature in Fahrenheit (°F)? (Enter a number)





Explanation
To convert from °C to °F, multiply by 9, divide by 5, then add 32
°F = (°C*9/5) + 32

Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.




Could not parse problem

Warm tropical surface ocean temperatures are around 300 K. What is that temperature in Celsius (°C)? (Enter a number)





Explanation
To convert kelvin to °C, subtract 273 (or, to be more precise, subtract 273.15). 
°C = K - 273.15  
Again, the answer you see above, [26.85,27] just means that the system accepts answers between 26.85 and 27, since you might have used 273, or you might have used 273.15 in your calculation. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

The Sun’s surface is about 6000 K. What is that temperature in Fahrenheit (°F)? (Enter a number.)





Explanation
To convert from kelvin (K) to Fahrenheit (°F), subtract 273.15, then multiply by 9, then divide by 5, then add 32
°F = (K-273.15)*9/5 + 32.  
With this equation, you should get 10340.33. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation. The system will accept answers from 10000 to 10341, in case you ballpark estimated this one. 



Could not parse problem

The air temperature in my city in May averages about 56°F. What is that temperature in kelvin (K)? (Enter a number)





Explanation
To convert from Fahrenheit (°F) to kelvin (K), subtract 32, then multiply by 5, divide by 9, and last, add 273.15.  
K = ((°F-32)*5/9) + 273.15. 
If you use this equation, you'll get 286.483. Be sure not to use commas in your answer, or the system will give you an error. Use a period (.) for the decimal designation.



Could not parse problem

For what location did you figure out last month's temperature anomaly?




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Could not parse problem

Here you can enter the magnitude of your temperature anomaly more specifically. What is the magnitude of the temperature anomaly you figured out? If, for example, your temperature average for last month was 0.5 degrees Celsius colder than the 1980s was, enter -0.5 in the box below. If your temperature average for last month was 0.5 degrees Celsius warmer than the 1980s was, enter 0.5 in the box below. Please enter your answer in Celsius!




 
 
def alwaysright(x,y): 
 return True 







Explanation
Thank you!




Multiple Choice JSON Ready
Assessment JSON Ready
Climate1x_3T2016 wrangle_overview_engagement already exists. Ignoring.
Climate1x_3T2016 wrangle_forum already exists. Ignoring.
Climate1x_3T2016 wrangle_video already exists. Ignoring.
Climate1x_3T2016 wrangle_link_page already exists. Ignoring.
Climate1x_3T2016 wrangle_general already exists. Ignoring.
Climate1x_3T2016 wrangle_assessments already exists. Ignoring.
EcodesignX_1T2017 demographic_multiple_choice already exists. Ignoring.
EcodesignX_1T2017 open_assessment already exists. Ignoring.
EcodesignX_1T2017 generalized_video_heat already exists. Ignoring.
EcodesignX_1T2017 generalized_video_axis already exists. Ignoring.
EcodesignX_1T2017 generalized_demographics already exists. Ignoring.
EcodesignX_1T2017 forum_posts already exists. Ignoring.
EcodesignX_1T2017 forum_searches already exists. Ignoring.
EcodesignX_1T2017 forum_views already exists. Ignoring.
EcodesignX_1T2017 tower_item already exists. Ignoring.
EcodesignX_1T2017 tower_engage_dirt already exists. Ignoring.
EcodesignX_1T2017 course_axis already exists. Ignoring.
EcodesignX_1T2017 external_link_dirt already exists. Ignoring.
EcodesignX_1T2017 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
EcodesignX_1T2017 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
EcodesignX_1T2017 wrangle_video already exists. Ignoring.
EcodesignX_1T2017 wrangle_link_page already exists. Ignoring.
EcodesignX_1T2017 wrangle_general already exists. Ignoring.
EcodesignX_1T2017 wrangle_assessments already exists. Ignoring.
EcodesignX_2T2017 demographic_multiple_choice already exists. Ignoring.
EcodesignX_2T2017 open_assessment already exists. Ignoring.
Requesting query... ok.
Query running...
Query done.
Processed: 79.0 MB

Retrieving results...
  Got page: 1; 28% done. Elapsed 9.78 s.
  Got page: 2; 55% done. Elapsed 14.09 s.
  Got page: 3; 83% done. Elapsed 18.31 s.
  Got page: 4; 100% done. Elapsed 21.73 s.
Got 84330 rows.

Total time taken 25.39 s.
Finished at 2017-06-30 19:39:01.
Saved to ./../data/EcodesignX_2T2017/generalized_video_heat.csv
EcodesignX_2T2017 generalized_video_axis already exists. Ignoring.
EcodesignX_2T2017 generalized_demographics already exists. Ignoring.
EcodesignX_2T2017 forum_posts already exists. Ignoring.
EcodesignX_2T2017 forum_searches already exists. Ignoring.
EcodesignX_2T2017 forum_views already exists. Ignoring.
EcodesignX_2T2017 tower_item already exists. Ignoring.
EcodesignX_2T2017 tower_engage_dirt already exists. Ignoring.
EcodesignX_2T2017 course_axis already exists. Ignoring.
Requesting query... ok.
Query running...
Requesting query... ok.
Query running...
Multiple Choice JSON Ready
Assessment JSON Ready
EcodesignX_2T2017 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
EcodesignX_2T2017 wrangle_general already exists. Ignoring.
EcodesignX_2T2017 wrangle_assessments already exists. Ignoring.
FBSEx_2T2017 demographic_multiple_choice already exists. Ignoring.
FBSEx_2T2017 open_assessment already exists. Ignoring.
Requesting query... ok.
Query running...
Query done.
Processed: 76.1 MB

Retrieving results...
  Got page: 1; 41% done. Elapsed 9.63 s.
  Got page: 2; 83% done. Elapsed 14.51 s.
  Got page: 3; 100% done. Elapsed 16.52 s.
Got 56476 rows.

Total time taken 19.21 s.
Finished at 2017-06-30 19:39:51.
Saved to ./../data/FBSEx_2T2017/generalized_video_heat.csv
FBSEx_2T2017 generalized_video_axis already exists. Ignoring.
FBSEx_2T2017 generalized_demographics already exists. Ignoring.
FBSEx_2T2017 forum_posts already exists. Ignoring.
FBSEx_2T2017 forum_searches already exists. Ignoring.
FBSEx_2T2017 forum_views already exists. Ignoring.
FBSEx_2T2017 tower_item already exists. Ignoring.
FBSEx_2T2017 tower_engage_dirt already exists. Ignoring.
FBSEx_2T2017 course_axis already exists. Ignoring.
Requesting query... ok.
Query running...
Requesting query... ok.
Query running...
Could not parse Checkbox Group



Identify all characteristics that make family enterprises unique, as compared to non-family owned businesses (check all that apply):

Family members wear multiple hats 
Need to manage different shareholder goals/objectives
Deal with the pressures of transition and continuity 
Personal identity and reputation tied to the business 
Concerned about growth and expansion of the enterprise



Could not parse problem


(Type in the correct answers)
Danny Miller and Isabelle le Breton-Miller researched the outstanding performance of numerous family firms. They concluded that family firms are different from non family firms in four ways. These “differentiators” often provided them with a competitive advantage. What are these four factors which set family businesses apart? (Hint: they all start with the letter C!)






























Explanation
What do each of these mean?
COMMAND: “take decisive action in the marketplace” 
CONTINUITY: “invest for the long run” ( rather then for quarterly earnings reports)
COMMUNITY: “unite the tribe” ( create a cohesive community of employees)
CONNECTION: “build close relationships with customers and suppliers” 



Could not parse Checkbox Group



Wendy discusses four principles of family systems theory and applies them to family business and the three circles within a family enterprise.  Select the four statements below that capture the essence of the four principles she discussed. 

Families and family systems tend to resist change to preserve the current state
Disruption in the business system doesn't directly impact the ownership system
Patterns, whether advantageous or harmful, repeat themselves generation after generation
Activity in any of the three circles can reverberate and impact any or all of the circles
Independence among generations is a common pattern
The whole is greater than the sum of the parts thus families and assets are stronger together



Could not parse Checkbox Group



Wendy highlights the difference between changes and transitions and states that every transition offers three opportunities; they are:  

to address a pressing challenge that the family enterprise is facing
to bring in external consultants to manage the change and guide the family firm
to increase engagement within the family and non-family
to identify new values and vision to match the changes that are occurring
to have a special family meeting because families are more impacted than firms from change
to build trust, new capabilities, and capacities



Could not parse problem


Fill in the blanks below.
What are the three best ways of preparing to join a family firm?


 
Obtaining a suitable _________





 
Gaining ______ to the business





 
Getting relevant ______ work experience




Could not parse Checkbox Group



David explained that it is important to have those who “marry into” a family at least be informed about what is going on in the business. Check all the reasons that apply:

Being married entitles them to know about the business
Like it or not, they will have an influence on decisions
They will be the parents of the next generation
It is better to have an informed influence rather than uninformed influence
If they don’t, they may go into competition with the family



Could not parse Checkbox Group



David’s father, H. Clark Bentall, served on several Boards of Directors later in his career. This was important for him in passing the baton to his younger brother because: (check all that apply)

He earned good money as a member of these boards
He was able to invest his time and energy productively
He was fulfilled with meaningful roles that did not interfere with his brothers’ leadership of the firm
Boards are pretigious 
He widened his network and subsequently brought more business to the family firm
He passed on learnings from other organizations to his brother 



Could not parse Checkbox Group



Among the common transition patterns identified in the last video, choose the two that are described to be the most effective:   

Cold Turkey
Delay, Delay, Delay
Waterfall 
Gradual/ Progressive
In Out, In Out
Interim CEO (non-family)



Could not parse problem


Fill in the blanks below.
What are the three keys to succession planning (according to the research David shared with us in this lecture)?


 
Formalized ______ planning process





 
A board of ______ with outside independent members





 
Regular ______ meetings




Could not parse Checkbox Group



David shared 5 attributes which he believes are required to be a great successor. Select them from the list below.
There are 5 correct answers.

willingness to work hard
good connections
patience
age and experience
humility
respect
specific industry expertise and knowledge
courage to stand up to the elder generation
lots of good ideas for improving the company
courage to work outside the family enterprise



Could not parse problem


Match each of the following definitions to their correct word.

Often associated with principles within a religious context


Values
Ethics
Morals


Typically associated with rules of a community or group (e.g., professional body)


Values
Ethics
Morals


Typically rule/guide for an individual, group or business


Values
Ethics
Morals




Explanation
You can have professional ethics, but you seldom hear about professional morals. Ethics tend to be codified into a formal system or set of rules which are explicitly adopted by a group of people. Thus you have medical ethics. Ethics are thus internally defined and adopted, whilst morals tend to be externally imposed on other people. Morals have a greater social element to values and tend to have a very broad acceptance. Morals are far more about good and bad than other values. We thus judge others more strongly on morals than values. A person can be described as immoral, yet there is no word for them not following values.



Could not parse Checkbox Group



Identify the reasons why family values are important (check all that apply).

They help families to grow the business.
Family values reflect a family’s history and shared traditions.
Values communicate to customers that they are important.
Family values contribute to family unity.
Values provide a guideline for how to behave – including how to treat customers or clients.
Values are an expression of culture.



Could not parse Checkbox Group



In the previous video, David explained that there are two essential elements to governance, these are:

Organization
Communication
Discipline
Decision making
Structure
Delegation



Could not parse Checkbox Group



Which of the following were mentioned as some of the key duties of a board of directors?

Ensuring the company has a clear strategic direction
Raising capital for new innovations of the family enterprise
Coordinating with family governance (or Family Council)
Overseeing family involvement in the family enterprise
Making important decisions on behalf of the CEO when they are absent
Selecting and appraising the CEO



Could not parse Checkbox Group



Which topics are important topics for an ownership meeting? Check all that apply.

corporate structure
strategic business planning and growth strategies
shareholders agreements
establish Board of Directors
family retreat planning
divendend policy
management selection
annual general meeting planning



Could not parse problem


Identify the 3 keys for an effective decision making process:
1.	Everyone understands and has clarity about the _______ being made




2.	Everyone has the same _______ information and details about the decision




3.	Everyone has a _______ in the decision and gets to participate





Could not parse problem



Wendy states: “Our brains seek out familiar patterns to confirm what we already know to be true”.    This is commonly referred to as ______________ bias.



Could not parse problem


  Wendy introduces us to the Insights Discovery framework as a way of discussing communication styles and preferences. Each of the four colours on the wheel's quadrants are associated with certain adjectives that describe that personality type. For this review question, type in the colour associated with the following characteristics: 


cautious







demanding







sociable







caring






Could not parse problem


Think about the five different styles of managing conflict. Which of the following statements are true and which are false?


Each of the five styles can be appropriate, in different circumstances.




true
false




Using your preferred style to handle conflict is ideal since you are accustomed to it.




true
false




The best way of handling conflict is to collaborate.




true
false




To collaborate typically takes more time and energy.




true
false




Avoiding conflict is always bad.




true
false



Could not parse problem


Type in your answers.
In a Family Enterprise, David recommends two styles as being the most important for families to cultivate. They are: 
 





AND
 






Could not parse Checkbox Group



Identify which of the following questions are powerful, curious questions: 

Do you think this decision is a mistake?
What would help us move forward from your perspective?
Do you want to stop working in the business?
What is the core challenge we are facing?
What does success look like for you?
Are you feeling badly about how things are going?



Could not parse problem


Among the examples that David shares to illustrate the power of consensus, he shares a passage from Nelson Mandela's book Long Walk to Freedom. Mandela’s ideas of leadership were influenced by his experiences in South Africa, watching the Regent in his court. He learned, that even in a tribal village decisions could be made by consensus, and he said that   “the (a) __________ was not to be crushed by the (b) _____________ "
blank a:



blank b:




Could not parse problem


  Type in the missing words below.
When most people think about entrepreneurship, they tend to associate it with risk taking, which in many ways is appropriate. However, entrepreneurship is much more than just taking risks (driving fast, on a windy road, on a dark, rainy night is definitely taking a risk, but it's not entrepreneurial!). In sharing a thoughtful definition of entrepreneurship, David wanted to emphasize the importance of what all successful entrepreneurs have in common, namely, the P_________ of O_____________. Because unless an entrepreneur has something worth going after, they are just a “risk taker” not an entrepreneur.
P_________ 



O_________ 




Could not parse Checkbox Group



A well structured Family Bank does the following (choose all that apply):

Has a committee  of family members who give out money to next generation members for their new companies
Funds education for members of the next generation
Requires members of the next generation to write a business plan to explain their business ideas and proposed strategies for their new businesses
Gives money to family members to help them start any company
Provides loans to family members on favourable terms, if their ideas are deemed worthy of investment
Supports all new ideas and dreams of family members who want to start new ventures
Has a committee of experienced professionals who must review and approve new business ventures before they will receive any funding



Could not parse Checkbox Group



According the Raphael Amit, Professor of Entrepreneurship at Wharton, it is important to keep entrepreneurship alive in family businesses because it (choose all that apply):

Can diffuse tension between siblings and cousins.
Can help elder generation to be proud of their offspring.
Enables individual family members to pursue their own dreams.
Enables family members to follow in their parents footsteps.
Shifts focus to “what I can do”, rather than “what can I get”.
Links personal greed to value creation and new products.
Can lead to greater fulfillment and happiness for family members.
Rising generations can see themselves as wealth creators.



Could not parse problem


  According to Dr Raphael Amit, it is essential to stimulate the rising generation to 
"Think about 1) ____________ and learn about 2) _________________"
1)




2)





Could not parse problem
Antoine Mayoud contrasts Entrepreneurship and Intrapreneurship. 
   Fill in the blanks:Intrapreneurs work i______________ the company and add new products and solutions 


Entrepreneurs  work o______________ creating new ventures and adding to what the company already has


Could not parse problem


  Antoine Mayoud begs family enterprise successors to not choose the easy road. Instead, he recommends choosing the more difficult road, of an entrepreneur because :
 
1)   It is more _________




2)   It is the most _________ road




3)   The road is not _________





Multiple Choice JSON Ready
Assessment JSON Ready
FBSEx_2T2017 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
FBSEx_2T2017 wrangle_general already exists. Ignoring.
FamBiz1x_1T2017 demographic_multiple_choice already exists. Ignoring.
FamBiz1x_1T2017 open_assessment already exists. Ignoring.
FamBiz1x_1T2017 generalized_video_heat already exists. Ignoring.
FamBiz1x_1T2017 generalized_video_axis already exists. Ignoring.
FamBiz1x_1T2017 generalized_demographics already exists. Ignoring.
FamBiz1x_1T2017 forum_posts already exists. Ignoring.
FamBiz1x_1T2017 forum_searches already exists. Ignoring.
FamBiz1x_1T2017 forum_views already exists. Ignoring.
FamBiz1x_1T2017 tower_item already exists. Ignoring.
FamBiz1x_1T2017 tower_engage_dirt already exists. Ignoring.
FamBiz1x_1T2017 course_axis already exists. Ignoring.
FamBiz1x_1T2017 external_link_dirt already exists. Ignoring.
FamBiz1x_1T2017 page_dirt already exists. Ignoring.
Could not parse Checkbox Group



Identify all characteristics that make family enterprises unique, as compared to non-family owned businesses (check all that apply):

Family members wear multiple hats 
Need to manage different shareholder goals/objectives
Deal with the pressures of transition and continuity 
Personal identity and reputation tied to the business 
Concerned about growth and expansion of the enterprise



Could not parse problem


(Type in the correct answers)
Danny Miller and Isabelle le Breton-Miller researched the outstanding performance of numerous family firms. They concluded that family firms are different from non family firms in four ways. These “differentiators” often provided them with a competitive advantage. What are these four factors which set family businesses apart? (Hint: they all start with the letter C!)






























Explanation
What do each of these mean?
COMMAND: “take decisive action in the marketplace” 
CONTINUITY: “invest for the long run” ( rather then for quarterly earnings reports)
COMMUNITY: “unite the tribe” ( create a cohesive community of employees)
CONNECTION: “build close relationships with customers and suppliers” 



Could not parse Checkbox Group



Wendy discusses four principles of family systems theory and applies them to family business and the three circles within a family enterprise.  Select the four statements below that capture the essence of the four principles she discussed. 

Families and family systems tend to resist change to preserve the current state
Disruption in the business system doesn't directly impact the ownership system
Patterns, whether advantageous or harmful, repeat themselves generation after generation
Activity in any of the three circles can reverberate and impact any or all of the circles
Independence among generations is a common pattern
The whole is greater than the sum of the parts thus families and assets are stronger together



Could not parse Checkbox Group



Wendy highlights the difference between changes and transitions and states that every transition offers three opportunities; they are:  

to address a pressing challenge that the family enterprise is facing
to bring in external consultants to manage the change and guide the family firm
to increase engagement within the family and non-family
to identify new values and vision to match the changes that are occurring
to have a special family meeting because families are more impacted than firms from change
to build trust, new capabilities, and capacities



Could not parse problem


Fill in the blanks below.
What are the three best ways of preparing to join a family firm?


 
Obtaining a suitable _________





 
Gaining ______ to the business





 
Getting relevant ______ work experience




Could not parse Checkbox Group



David explained that it is important to have those who “marry into” a family at least be informed about what is going on in the business. Check all the reasons that apply:

Being married entitles them to know about the business
Like it or not, they will have an influence on decisions
They will be the parents of the next generation
It is better to have an informed influence rather than uninformed influence
If they don’t, they may go into competition with the family



Could not parse Checkbox Group



David’s father, H. Clark Bentall, served on several Boards of Directors later in his career. This was important for him in passing the baton to his younger brother because: (check all that apply)

He earned good money as a member of these boards
He was able to invest his time and energy productively
He was fulfilled with meaningful roles that did not interfere with his brothers’ leadership of the firm
Boards are pretigious 
He widened his network and subsequently brought more business to the family firm
He passed on learnings from other organizations to his brother 



Could not parse Checkbox Group



Among the common transition patterns identified in the last video, choose the two that are described to be the most effective:   

Cold Turkey
Delay, Delay, Delay
Waterfall 
Gradual/ Progressive
In Out, In Out
Interim CEO (non-family)



Could not parse problem


Fill in the blanks below.
What are the three keys to succession planning (according to the research David shared with us in this lecture)?


 
Formalized ______ planning process





 
A board of ______ with outside independent members





 
Regular ______ meetings




Could not parse Checkbox Group



David shared 5 attributes which he believes are required to be a great successor. Select them from the list below.
There are 5 correct answers.

willingness to work hard
good connections
patience
age and experience
humility
respect
specific industry expertise and knowledge
courage to stand up to the elder generation
lots of good ideas for improving the company
courage to work outside the family enterprise



Could not parse problem


Match each of the following definitions to their correct word.

Often associated with principles within a religious context


Values
Ethics
Morals


Typically associated with rules of a community or group (e.g., professional body)


Values
Ethics
Morals


Typically rule/guide for an individual, group or business


Values
Ethics
Morals




Explanation
You can have professional ethics, but you seldom hear about professional morals. Ethics tend to be codified into a formal system or set of rules which are explicitly adopted by a group of people. Thus you have medical ethics. Ethics are thus internally defined and adopted, whilst morals tend to be externally imposed on other people. Morals have a greater social element to values and tend to have a very broad acceptance. Morals are far more about good and bad than other values. We thus judge others more strongly on morals than values. A person can be described as immoral, yet there is no word for them not following values.



Could not parse Checkbox Group



Identify the reasons why family values are important (check all that apply).

They help families to grow the business.
Family values reflect a family’s history and shared traditions.
Values communicate to customers that they are important.
Family values contribute to family unity.
Values provide a guideline for how to behave – including how to treat customers or clients.
Values are an expression of culture.



Could not parse Checkbox Group



In the previous video, David explained that there are two essential elements to governance, these are:

Organization
Communication
Discipline
Decision making
Structure
Delegation



Could not parse Checkbox Group



Which of the following were mentioned as some of the key duties of a board of directors?

Ensuring the company has a clear strategic direction
Raising capital for new innovations of the family enterprise
Coordinating with family governance (or Family Council)
Overseeing family involvement in the family enterprise
Making important decisions on behalf of the CEO when they are absent
Selecting and appraising the CEO



Could not parse Checkbox Group



Which topics are important topics for an ownership meeting? Check all that apply.

corporate structure
strategic business planning and growth strategies
shareholders agreements
establish Board of Directors
family retreat planning
divendend policy
management selection
annual general meeting planning



Could not parse problem


Identify the 3 keys for an effective decision making process:
1.	Everyone understands and has clarity about the _______ being made




2.	Everyone has the same _______ information and details about the decision




3.	Everyone has a _______ in the decision and gets to participate





Could not parse problem



Wendy states: “Our brains seek out familiar patterns to confirm what we already know to be true”.    This is commonly referred to as ______________ bias.



Could not parse problem


  Wendy introduces us to the Insights Discovery framework as a way of discussing communication styles and preferences. Each of the four colours on the wheel's quadrants are associated with certain adjectives that describe that personality type. For this review question, type in the colour associated with the following characteristics: 


cautious







demanding







sociable







caring






Could not parse problem


Think about the five different styles of managing conflict. Which of the following statements are true and which are false?


Each of the five styles can be appropriate, in different circumstances.




true
false




Using your preferred style to handle conflict is ideal since you are accustomed to it.




true
false




The best way of handling conflict is to collaborate.




true
false




To collaborate typically takes more time and energy.




true
false




Avoiding conflict is always bad.




true
false



Could not parse problem


Type in your answers.
In a Family Enterprise, David recommends two styles as being the most important for families to cultivate. They are: 
 





AND
 






Could not parse Checkbox Group



Identify which of the following questions are powerful, curious questions: 

Do you think this decision is a mistake?
What would help us move forward from your perspective?
Do you want to stop working in the business?
What is the core challenge we are facing?
What does success look like for you?
Are you feeling badly about how things are going?



Could not parse problem


Among the examples that David shares to illustrate the power of consensus, he shares a passage from Nelson Mandela's book Long Walk to Freedom. Mandela’s ideas of leadership were influenced by his experiences in South Africa, watching the Regent in his court. He learned, that even in a tribal village decisions could be made by consensus, and he said that   “the (a) __________ was not to be crushed by the (b) _____________ "
blank a:



blank b:




Could not parse problem


  Type in the missing words below.
When most people think about entrepreneurship, they tend to associate it with risk taking, which in many ways is appropriate. However, entrepreneurship is much more than just taking risks (driving fast, on a windy road, on a dark, rainy night is definitely taking a risk, but it's not entrepreneurial!). In sharing a thoughtful definition of entrepreneurship, David wanted to emphasize the importance of what all successful entrepreneurs have in common, namely, the P_________ of O_____________. Because unless an entrepreneur has something worth going after, they are just a “risk taker” not an entrepreneur.
P_________ 



O_________ 




Could not parse Checkbox Group



A well structured Family Bank does the following (choose all that apply):

Has a committee  of family members who give out money to next generation members for their new companies
Funds education for members of the next generation
Requires members of the next generation to write a business plan to explain their business ideas and proposed strategies for their new businesses
Gives money to family members to help them start any company
Provides loans to family members on favourable terms, if their ideas are deemed worthy of investment
Supports all new ideas and dreams of family members who want to start new ventures
Has a committee of experienced professionals who must review and approve new business ventures before they will receive any funding



Could not parse Checkbox Group



According the Raphael Amit, Professor of Entrepreneurship at Wharton, it is important to keep entrepreneurship alive in family businesses because it (choose all that apply):

Can diffuse tension between siblings and cousins.
Can help elder generation to be proud of their offspring.
Enables individual family members to pursue their own dreams.
Enables family members to follow in their parents footsteps.
Shifts focus to “what I can do”, rather than “what can I get”.
Links personal greed to value creation and new products.
Can lead to greater fulfillment and happiness for family members.
Rising generations can see themselves as wealth creators.



Could not parse problem


  According to Dr Raphael Amit, it is essential to stimulate the rising generation to 
"Think about 1) ____________ and learn about 2) _________________"
1)




2)





Could not parse problem
Antoine Mayoud contrasts Entrepreneurship and Intrapreneurship. 
   Fill in the blanks:Intrapreneurs work i______________ the company and add new products and solutions 


Entrepreneurs  work o______________ creating new ventures and adding to what the company already has


Could not parse problem


  Antoine Mayoud begs family enterprise successors to not choose the easy road. Instead, he recommends choosing the more difficult road, of an entrepreneur because :
 
1)   It is more _________




2)   It is the most _________ road




3)   The road is not _________





Multiple Choice JSON Ready
Assessment JSON Ready
FamBiz1x_1T2017 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
FamBiz1x_1T2017 wrangle_video already exists. Ignoring.
FamBiz1x_1T2017 wrangle_link_page already exists. Ignoring.
FamBiz1x_1T2017 wrangle_general already exists. Ignoring.
FamBiz1x_1T2017 wrangle_assessments already exists. Ignoring.
Forest222x_1T2015 demographic_multiple_choice already exists. Ignoring.
Forest222x_1T2015 open_assessment already exists. Ignoring.
Forest222x_1T2015 generalized_video_heat already exists. Ignoring.
Forest222x_1T2015 generalized_video_axis already exists. Ignoring.
Forest222x_1T2015 generalized_demographics already exists. Ignoring.
Forest222x_1T2015 forum_posts already exists. Ignoring.
Forest222x_1T2015 forum_searches already exists. Ignoring.
Forest222x_1T2015 forum_views already exists. Ignoring.
Forest222x_1T2015 tower_item already exists. Ignoring.
Forest222x_1T2015 tower_engage_dirt already exists. Ignoring.
Forest222x_1T2015 course_axis already exists. Ignoring.
Forest222x_1T2015 external_link_dirt already exists. Ignoring.
Forest222x_1T2015 page_dirt already exists. Ignoring.
Could not parse problem

In which country were you born?	



In which country do you currently reside?	



If you currently live in Canada, what are the first three characters of your postal code?



What is the main language that you speak at home? 	




Could not parse problem

This question has been removed from grading. 
 

Could not parse problem

SMFEs tend to operate at a scale that is conducive to conservation based strategies and sustainability. True or false?




Could not parse problem

SMFEs account for more than 50% of forest-related employment in forested countries. True or false?




Multiple Choice JSON Ready
Assessment JSON Ready
Forest222x_1T2015 wrangle_overview_engagement already exists. Ignoring.
Forest222x_1T2015 wrangle_forum already exists. Ignoring.
Forest222x_1T2015 wrangle_video already exists. Ignoring.
Forest222x_1T2015 wrangle_link_page already exists. Ignoring.
Forest222x_1T2015 wrangle_general already exists. Ignoring.
HtC1x_2T2017 demographic_multiple_choice already exists. Ignoring.
HtC1x_2T2017 open_assessment already exists. Ignoring.
HtC1x_2T2017 generalized_video_heat already exists. Ignoring.
HtC1x_2T2017 generalized_video_axis already exists. Ignoring.
HtC1x_2T2017 generalized_demographics already exists. Ignoring.
HtC1x_2T2017 forum_posts already exists. Ignoring.
HtC1x_2T2017 forum_searches already exists. Ignoring.
HtC1x_2T2017 forum_views already exists. Ignoring.
HtC1x_2T2017 tower_item already exists. Ignoring.
HtC1x_2T2017 tower_engage_dirt already exists. Ignoring.
HtC1x_2T2017 course_axis already exists. Ignoring.
HtC1x_2T2017 external_link_dirt already exists. Ignoring.
HtC1x_2T2017 page_dirt already exists. Ignoring.
Could not parse problem

What is the next step in the following evaluation? 
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
   Step 1: (/ 12 (+ (- 7 4) 3)) 
   Step 2:  __________________





Explanation
The second operand to / is an expression, so it must be evaluated. And the first operand to + is an expression, so it must be evaluated. All of the operands to - are values, so - can be called with 7 and 4 as arguments. This replaces the - call expression with 3.



Could not parse problem


What is the next step in the following evaluation? 
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
Step 1: (/ 12 (+ (- 7 4) 3)) 
Step 2: (/ 12 (+ 3 3)) 
Step 3:  ______________





Explanation:
All of the operands to + have been evaluated, so + can be called with the arguments 3 and 3.




Could not parse problem


What is the next step in the following evaluation?
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
Step 1: (/ 12 (+ (- 7 4) 3)) 
Step 2: (/ 12 (+ 3 3)) 
Step 3: (/ 12 6) 
Step 4: _________





Explanation:
All of the operands to / have been evaluated, so the primitive can be called with the arguments 12 and 6.




Could not parse problem

Consider the following program:

(define FOO (* 2 3))
(define BAR (* FOO 2))

(* FOO BAR)
What result is produced when the program is run? (The best way to figure this out would be to work through the evaluation rules you know one at a time until you have the final result.)




Could not parse problem


A "pointing on a picture" problem (also called an "image mapped input" problem) presents an image, and asks you to click on an area in the image. To help ensure accuracy, make sure you click near the middle of what the question asks for.

    Click the mouse to move the green dot on top of one example of an operator.





Explanation
Operators are primitives built into BSL that consume primitive data and produce  results. Examples include +, *, -, / and many more.  
      		




Could not parse problem



	Click the mouse to move the green dot on top of one example of a function name.





Explanation
	Recall:





Could not parse problem



	Click the mouse to move the green dot on top of one example of a function body.





Explanation
	Recall:





Could not parse problem



	Click the mouse to move the green dot on top of one example of a parameter.





Explanation
	Recall:





Could not parse problem

Problem: Design a function that pluralizes a given word. (Pluralize means to convert the word
          to its plural form.) For simplicity you may assume that just adding s is enough to pluralize a word.
  	

    What is an appropriate signature for this function? Leave out the two semi-colons and the space, but
    otherwise be sure to get the capitalization and all other aspects of the signature correct.
  





Explanation
The most appropriate way to represent a word is with a string, so the primitive type the function should consume and produce is String. This means the signature line, including the semi-colons, is:
;; String -> String
 Note: type names should use upper camel case.



Could not parse problem

A "pointing on a picture" problem (also called an "image mapped input" problem) presents an image, and asks you to click on an area in the image. To help ensure accuracy, make sure you click near the middle of what the question asks for.
In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
The signature shows the function as producing String. But this doesn't match the purpose, the check-expects or the stub, all of which have the function producing Number.



Could not parse problem

In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
In the second check-expect, the operand in the call to empty-string? is 0. But 0 is a number, the signature says the function must consume String, and all the other parts of the design have the function consuming String. 



Could not parse problem

In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
The false answer in the if expression produces true. But true is a boolean, which does not match the signature, purpose or any of the check-expects. 



Could not parse problem

The issue of how many tests a function needs is something we will discuss in more and more detail as the course moves forwards.  
_____________________________________________________________________________
Take a moment to think about how many tests are necessary for the function in the previous video?





Explanation
Continue watching part 2 of the video for an explanation of why each test is necessary. 



Could not parse problem








Build a cond expression equivalent to the above nested if expressions by dragging each of the parts below into the proper place in the cond.
















correct_answer = [{
    'draggables': ['2', '5', '3', '4', '1', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5', 't6'],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        


Could not parse problem

Match each of the following problem statement fragments to the corresponding form of data definition.
 1 - "percentage score"
      2 - "TV volume level 1-30, or mute"
      3 - "primary colors: red, green, blue"
      4 - "height of a rocket"












correct_answer = {'1d':'tb', '2d':'td', '3d':'tc', '4d':'ta'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        


ExplanationGiven the problem statement fragments, the types comments should look something like this:

;; RocketHeight is Natural

;; PercentageScore is Number[0, 100]

;; PrimaryColor is one of:
;; - "red"
;; - "green"
;; - "blue"

;; TelevisionVolume is one of:
;; - Number[1, 30]    
;; - "mute"



Could not parse problem


What is the minimum number of data examples needed to illustrate this data definition? [Enter a number]





Explanation
We need at least 1 example that represents Natural[1, 100], and 1 that represents "standby".




Could not parse problem

How many function examples (tests) would a function need if it consumes Reservation and produces true if the reservation is the last one? [Enter a number]





Explanation
We need at least 3 tests: 2 for the interval case, because the result is true if the reservation is 100, and false otherwise, and we need at least 1 test for the second case, "standby".



Could not parse problem

















correct_answer = correct_answer = [
    {
      'draggables': ['1'],
      'targets': ['t2', 't5'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['2'],
      'targets': ['t1', 't6'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['4', '3'],
      'targets': ['t3', 't4'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem



Drag the Cat data onto its corresponding image in the world program.











correct_answer = {'1': 't2', '2': 't3', '3': 't1'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Move the green dot to the set of images which most accurately reflects what the domain analysis should look like for the countdown program. Assume the images were drawn from left to right to represent different clock ticks in the program.






Explanation
 The bottom left is the best domain analysis because it shows the numbers in the center of the screen, decreasing until reaching zero.



Could not parse problem



Again consider the countdown program. Categorize each piece of information as either constant or changing.














correct_answer = {
        '1': 'constant', '2': 'constant', '3': 'constant', '4': 'constant', '5': 'change', '6': 'constant', '7': 'constant', '8': 'constant'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem



Drag the Countdown data to complete each check-expect for our handle-mouse function. Note, each value can be used more than once, and you don't need to use every one.












correct_answer = [{
      'draggables': ['1'],
      'targets': ['t1', 't3', 't4'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['3'],
      'targets': ['t2'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Here is the signature and purpose for the function that produces true if the list contains a negative number.
;; ListOfNumber -> Boolean
;; produce true if a lon contains a negative number
What is the result of the following tests?
(check-expect (contains-negative? (cons 1 empty)) _____)





Explanation
The list has only 1 element and it is positive.



Could not parse problem

(check-expect (contains-negative? (cons 1 (cons -1.5 empty))) _____)





Explanation
The second element of the list is negative.



Could not parse problem

(check-expect (contains-negative? empty) _____)





Explanation
The list is empty, so it contains no negative numbers.



Could not parse problem

Is this self-referential type comment well-formed?
;; ListOfNumber is one of:
;; - (cons Number ListOfNumber)





Explanation
Although it has a self-referential case, it does not have a base case, so it is not well formed.



Could not parse problem

Is this self-referential type comment well-formed?
;; NonEmptyListOfNumber is one of:
;; - (cons Number empty)
;; - (cons Number NonEmptyListOfNumber)





Explanation
This is a type comment for a non-empty list - a list that at it's shortest just has a single element. It is well-formed because it has both a base case which has no self-reference: (cons Number empty), and a self-referential case: (cons Number NonEmptyListOfNumber).



Could not parse problem

Choose the part of the template that results from each highlighted part of the Type Comment.






Explanation
ListOfNumber has two cases, so we need a cond expression. empty is the first case, and it is atomic distinct, so the answer clause is (...).



Could not parse problem







Explanation
(cons Number ListOfNumber) is compound, so we separate it into two parts, the first being (first lon).



Could not parse problem







Explanation
The second part of the compound is (rest lon) which is ListOfNumber. This is a self-reference in the type comment, so (rest lon) is wrapped in a call to fn-for-lon to form a natural recursion.



Could not parse problem


Drag the template rules to create the correct template rules for foo. Only use as many template rules as are necessary.











correct_answer = [{
    'draggables': ['compound', 'atomic', 'reference' ],
    'targets': ['t1', 't2', 't3' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Use the options below to create the correct template rules for ListOfConcert.
You can use up to six template rules, but you do not need to use all the space.
Note, if you drap the options out of the bar at the bottom, they become bigger and you will be able to read the template rules.
















correct_answer = [{
    'draggables': ['2', '3', '4', '5', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

The factorial of a natural number n is n*n-1*n-2*...1. So factorial of 3 is 3*2*1*1. Let's design a function called fact to compute the factorial.

factorial of 0 is 1
factorial of n is n*factorial(n-1)

Here is the signature and purpose for fact:
;; Natural -> Natural
;; compute n * n-1 * n-2 * ... * 1
What is the result of each check-expect?
(check-expect (fact 0) ____ )



(check-expect (fact 3) ____ )





Explanation
0 factorial is 1, so (fact 0) should produce 1. 
3 factorial is 3*2*1 whihc is 6.



Could not parse problem

In the two boxes below, complete the two cases in the types comment for the data definition for a list of images. 

;; ListOfImage is one of:




















Explanation
The correct type comment for a list of images is 
;; ListOfImage is one of:
;; - empty
;; - (cons Image ListOfImage)



Could not parse problem

After we run the program, we notice that one test in arrange-strings is still failing. Are we done working on layout-strings?






Explanation
We didn't complete the sorting part of this program, so that test for arrange-strings should fail. But since the tests for layout-strings are passing we are ready to move on to completing the rest of the program. 



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
First we look at the root, the node 3:c. It does not have the key 4. We go down the right subtree since the key we are looking for is greater than 3. Then we look at the node 4:d, and it has key 4 and we are done. So we looked at 2 nodes, 3:c and 4:d.



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
To find key 4, we need to look at nodes 1:a, 2:b, 3:c, and then 4:d. So 4 nodes in total.



Could not parse problem



Suppose instead of producing the value of a node with a given key, we would like to 
    produce the path that we took when we searched for that key. So the function that we 
    would like to design should produce a list of "L" or "R", and should end with either
    "Fail" or "Succeed", depending on whether we found the key.
  

    We're almost done designing this function. We have the signature, purpose, tests,
    and we've even started filling in the template.
Drag the expressions below, into the appropriate box on the partially filled in template.












        
correct_answer = {'1': 'second', '2': 'third', '3': 'fourth', '4': 'first'}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


    You're still not comfortable with the idea that trees are layed out from above to below in computer 
    science, instead you would prefer to have your trees layed out left to right. So the root is at the 
    left, it's children are to it's right etc. For example, with your new version the result of 
    evaluating:
(render-bst (make-node 100 "C"
                       (make-node  50  "L" false false)
                       (make-node 150 "CL" false false)))
would look something like:




Again, that would look a lot better with a little extra whitespace in it, but please ignore that for now.
By remembering the role that combination positions play in templates, you realize that the new function definition should be very close to the old function definition. Edit the current render function definition so that it has the new left-to-right behavior by dragging one or more function names from the scrollbar below, onto the  function definition where you want to replace one function name with another.









        
correct_answer = {'2': [[130, 75], 45], '4': [[200, 95], 50]}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference.










correct_answer = [
      {
      'draggables': ['R'], 
      'targets': ['Rt'], 
      'rule':'exact'
      },
      {
      'draggables': ['SR'], 
      'targets': ['SRt'], 
      'rule':'exact'
      },
      {
      'draggables': ['MR', 'MR'],
      'targets': ['MRt1', 'MRt2'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference. (The arrows are coloured to help distinguish between them).














correct_answer = [
      {
      'draggables': ['SR', 'SR'],
      'targets': ['SRt1', 'SRt2'],
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['MR', 'MR', 'MR', 'MR', 'MR', 'MR'],
      'targets': ['MRt1', 'MRt2', 'MRt3', 'MRt4', 'MRt5', 'MRt6'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Below are the templates for the above type comments. Select the correct number for each arrow to show the correspondence between the templates and the type comments










correct_answer = [
      {
      'draggables': ['1'], 
      'targets': ['t1'], 
      'rule':'exact'
      },
      {
      'draggables': ['2', '2'], 
      'targets': ['t2', 't4'], 
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['3'],
      'targets': ['t3'],
      'rule':'exact'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

 How many self-references are there?




ExplanationListOfPerson has a self-reference in it.
 


 
 How many references are there?





Explanation
 All remaining references are part of a mutual reference cycle, so there are 0. 


 How many mutual-references are there?




ExplanationListOfPerson has a reference to Person and vice versa.
 



Could not parse problem


Complete the function design for names-under-20--person and names-under-20--lop.







correct_answer = [{
      'draggables': ['cons', 'append'],
      'targets': ['t1', 't2'],
      'rule':'exact'
      }]
        
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Correctly label each arrow on the template with one of R, SR, MR, NH, NR, or NMR.













correct_answer = [{
    'draggables': ['NH', 'NR'],
    'targets': ['t1', 't4'],
    'rule':'exact'
},
{   'draggables': ['NMR', 'NMR'],
    'targets': ['t2', 't3'],
    'rule':'unordered_equal+number'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Design the function has-path? that consumes a BinaryTree and a Path. The function should produce true if following the path through the tree leads to a node. If the path leads to false or runs into false before reaching the end of the path, the function should produce false.

;; BinaryTree Path -> Boolean
;; prodcue true if following p through bt leads to a node; false otherwise

Lets design a cross product of type comments table to help us write tests for this function. Note Nat, Str and BT stand for Natural, String and BinaryTree.

   p        bt  | false | (make-node Nat Str BT BT)
----------------|-------|----------------------------
empty           |       |            
----------------|-------|----------------------------
(cons "L" Path) |       |            
----------------|-------|----------------------------
(cons "R" Path) |       |            

Recall:

(define BT1 (make-node 1 "a" false false))
(define BT4 (make-node 4 "d"
                       (make-node 2 "b")
                                  (make-node 1 "a" false false)
                                  (make-node 3 "c" false false))
                       (make-node 5 "e" false false))) 
We need at least one check-expect for every cell in the table.
What is the value of each check-expcet?
(check-expect (has-path? false empty) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path ends at false. 




Could not parse problem

(check-expect (has-path? false (list "L")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? false (list "R")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? BT1 empty) _____ )




Explanationhas-path should produce true if the path leads to a node. 




Could not parse problem

(check-expect (has-path? BT4 (list "R")) _____ )





Explanation
Following the given path leads to a node. 



Could not parse problem

(check-expect (has-path? BT4 (list "L" "L" "R")) _____ )





Explanation
Following the given path leads to false. 



Could not parse problem

Look at the table again:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|-------|--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|-------|--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))

How many cases can we reduce it to?





Explanation
The table can be reduced to these four cases:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|       |--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|       |--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))




Could not parse problem

In the practice problem find-person-starter.rkt we asked you to use local to improve your functions performance as the tree gets larger. Would the following be a correct use of local for that purpose?

(define (find--lop n lop)
  (local [(define try (find--person n (first lop)))]
    (cond [(empty? lop) false]
          [else
           (if (not (false? (find--person n (first lop))))
               (find--person n (first lop))
               (find--lop n (rest lop)))])))





Explanation
In this case the local has not been moved to surround the nearest expression that encloses all occurrences of the repeated computation. That would be around the if. Instead it moved outside of the cond answer the if appeared in. Try running it with this definition and see what happens. Step it carefully to be sure you understand why. 



Could not parse problem

Would this version that doesn't use local work?

(define try (find--person n (first lop)))

(define (find--lop n lop)
  (cond [(empty? lop) false]
        [else
         (if (not (false? try))
             try
             (find--lop n (rest lop)))]))





Explanation
The paramaters n and lop are not defined outside of find--lop, so this will not work either.



Could not parse problem


Use the pieces below.













correct_answer = [
    {
      'draggables': ['3'],
      'targets': ['t2', 't3'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['7'],
      'targets': ['t1'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


    An image mapped input problem presents an image for the student.
    Input is given by the location of mouse clicks on the image.
    Correctness of input can be evaluated based on expected dimensions of a rectangle.
  
Which animal shown below is a kitten?





Explanation
The animal on the right is a kitten. The animal on the left is a puppy, not a kitten.



Could not parse problem

In adding the accumulator paramater, we have missed a spot where it should be added. Click to move the green dot to the location of the missing accumulator paramater.





Explanation
We need to add acc at all of the ...s, as well as adding an extra paramater to every call of number-list.



Multiple Choice JSON Ready
Assessment JSON Ready
HtC1x_2T2017 wrangle_overview_engagement already exists. Ignoring.
HtC1x_2T2017 wrangle_forum already exists. Ignoring.
HtC1x_2T2017 wrangle_video already exists. Ignoring.
HtC1x_2T2017 wrangle_link_page already exists. Ignoring.
HtC1x_2T2017 wrangle_general already exists. Ignoring.
HtC1x_2T2017 wrangle_assessments already exists. Ignoring.
ITSx_1T2016 demographic_multiple_choice already exists. Ignoring.
ITSx_1T2016 open_assessment already exists. Ignoring.
ITSx_1T2016 generalized_video_heat already exists. Ignoring.
ITSx_1T2016 generalized_video_axis already exists. Ignoring.
ITSx_1T2016 generalized_demographics already exists. Ignoring.
ITSx_1T2016 forum_posts already exists. Ignoring.
ITSx_1T2016 forum_searches already exists. Ignoring.
ITSx_1T2016 forum_views already exists. Ignoring.
ITSx_1T2016 tower_item already exists. Ignoring.
ITSx_1T2016 tower_engage_dirt already exists. Ignoring.
ITSx_1T2016 course_axis already exists. Ignoring.
ITSx_1T2016 external_link_dirt already exists. Ignoring.
ITSx_1T2016 page_dirt already exists. Ignoring.
Could not parse problem


Using your mouse, drag and drop each name in the scrollbar to the matching study design shown in the image.









correct_answer = {'1': 't2', '2': 't3', '3': 't1'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
To correctly identify the different study designs, be sure to pay attention to the number of groups being studied and the number of time periods. Starting from the left, the first study design has two groups and two time periods, making it a pre-post with control. The second has one group at two time periods, so is a pre-post (it does not have a control). Finally, the furthest right has two groups at one time point, so is a post-only with control study.



Could not parse problem


Using your mouse, drag and drop each type of level and trend change in the scrollbar to the matching result from the image.












correct_answer = {'4': 't1', '3': 't2', '1': 't3', '2': 't4'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
To determine the changes present in the charts, be sure to compare the observed line in the post period (solid line on right of charts) to the counterfactual (dashed). Starting from the top left, the red chart shows both a level change and trend change from the counterfactual, the green a level change and no trend change, the purple no level change or trend change, and the blue no level change but a trend change.



Could not parse problem


Using your mouse, drag and drop each estimate that Sophie will estimate from her interrupted time series onto her chart.












correct_answer = {'1': 't1', '3': 't2', '2': 't3', '4': 't4'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
From left to right, the arrows represent the (1) Existing level, (2) Existing trend, (3) Level Change, and (4) Trend change.



Could not parse problem

 Which function in R allows you to draw a figure?





Explanation
 The plot command is used in R to draw a figure.



Could not parse problem

What is the total number of time points in the dataset?



At what value of data$time did you draw the abline indicating the start of the prior authorization policy?





Explanation
The dataset runs for 19 calendar quarters, from Q1 2001 quarter 1 to Q4 2005. As the prior authorization started at time point 8 in the dataset, the policy line is most appropriate placed between that and the next time point at 8.5.



Could not parse problem

 Which of the plots is consistent with a change in level following the policy change?





Explanation
Remember that a level change is an immediate drop in the outcome that is sustained over the post period. As the drop in Series 2 is abrupt and continues the pre-existing flat trend, it is representative of a level change.



Could not parse problem

What function do you use in R to run a standard linear regression?






Explanation
The lm function in R allows you to run a standard linear regression model.



Could not parse problem

Aside from the intercept term, how many variables are necessary to model a single-series interrupted time series model?





Explanation
A standard segmented regression model for interrupted time series requires 3 variables aside from the intercept term: (1) an existing trend, (2) a level change, and (3) a trend change.



Could not parse problem

With reference to the standard regression for the West Virginia data, what are your estimates of the following variables:
The existing level?



The pre-existing trend per quarter?



The estimated level change following the prior authorization policy?



The estimated change in the trend per quarter following the policy change?





Explanation
Rounded to two significant figures, your coefficients should be as follows:
Existing Level: 0.51
Existing Trend: -0.0020
Level Change: -0.017
Trend Change: -0.015



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots show a spike in the PACF at 3 and exponential decay in the ACF, which are suggestive of an AR(3) function underlying the data generation process.



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots show a spike in the ACF at 2 and exponential decay in the PACF, which are suggestive of an MA(2) function underlying the data generation process.



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots do not show significant spikes in either the ACF or PACF, suggesting neither an AR() or MA() process.



Could not parse problem

 Which of the plots above resembles the ones you produced?





Explanation
Your plots should have resembled Image 2.


Based on these plots, what AR() and MA() parameters would you use in your final model?
AR:



MA:





Explanation
There are no indications of significiant spikes in either the ACF or PACF for this data, suggesting that no AR() or MA() process underlies the data.



Could not parse problem

Compare the final model based on the ACF and PACF plots to one with 1 additional AR() term. What is the p-value?




Perform the same comparison to a model with 1 additional MA() term. What is the p-value for this comparison?






Explanation
Note that while the null hypothesis is not rejected in the AR(1) model, it is with the MA(1) model. This suggests that our final model should be modified to include an MA(1) parameter.



Could not parse problem

Using the coefficients above, please estimate the predicted outcome at time point 20 (to two decimal places):





Explanation
At time point 20, you would calculate the predicted change as follows. First, the model prediction:
pred = B0*intercept + B2*time + B3*level + B4*trend
pred = 12.24 - 0.13*20 - 2.46 - 0.29*5 (remember that you are 5 time periods after the intervention!)
pred = 5.73


Now, calculate the counterfactual at the same time point:





Explanation
At time point 20, you would calculate the counterfactual by leaving off the level and trend change variables as follows:
cfac = B0*intercept + B2*time
cfac = 12.24 - 0.13*20
cfac = 9.64


Finally, use these two numbers to calculate the absolute predicted change be at time period 20:





Explanation
At time point 20, you would calculate the counterfactual as follows:
predicted change = pred - cfac
  = 5.73 - 9.64
  = -3.91



Could not parse problem

What is the absolute predicted change in the market share for non-preferred agents in West Virginia at 6 quarters after the policy was introduced (as a proportion to 2 decimal places - e.g. 0.47)?






Explanation
To calculate the predicted value at 6 quarters after the policy change, first get the fitted values at time period 14. Remember there are 8 pre-policy quarters, and we are interested in 6 quarters after that, so 14 using fitted(). Then estimate the counterfactual at the same time point. Finally, calculate the absolute change at 6 quarters.



Could not parse problem

Now, what would the relative change be at 2 years after the policy change (as a percentage - e.g. 14.3)?





Explanation
To perform this caluclation use the method as above, but use 16 instead of 14. Then calculate the relative change using the following formula to get the relative change:
(pred - cfac) / cfac = -29.47



Could not parse problem

How many lines in total are contained in the controlled dataset?



On which line does the data for the control group start?





Explanation
There are 38 total lines in the dataset, and the data for the control group starts on line 20.



Could not parse problem

With reference to the standard regression for the West Virginia data with a control group, what are your estimates of the following variables:
The existing level difference?




The pre-existing difference in the trend per quarter?




The estimated level change following the prior authorization policy relative to the control group?




The estimated change in the trend per quarter following the policy change relative to the control group?






Explanation
Rounded to three significant figures, your coefficients should be as follows:
Level difference: 0.0268
Trend difference: -0.00117
Level Change difference: -0.0351
Trend Change difference: -0.0129
Note that these are the coefficients for the relative changes, not the values for the control group.



Could not parse problem

Using the model coefficients, calculate how much higher water flow was predicted to be in the Nile in 1880 compared to the Huron, and enter your answer below:





Explanation
To calculate the expected difference in 1880, or at point 10, we can do the following calculation:
1. Expected level in the Huron = 2464.7702 + -20.2181 * 10 = 2262.5892
2. Expected level in the Nile = 2464.7702 + -20.2181 * 10 + 885.428 + 26.8242 * 10 = 3416.2592
Subtracting the first expected value from the second results in an answer of 1153.67.



Could not parse problem

What is your estimate for the level change in West Virginia relative to the control states?



What is the lower bound on the 95% confidence interval for this estimate?



What is the higher bound on the 95% confidence interval?





Explanation
The estimate for the level change relative to the control group is -0.0351 (95% CI: -0.0563 to -0.0139).



Could not parse problem

What is your estimate for the trend change in West Virginia relative to the control states?



What is the lower bound on the 95% confidence interval for this estimate?



What is the higher bound on the 95% confidence interval?





Explanation
The estimate for the trend change relative to the control group is -0.0129 (95% CI: -0.0173 to -0.00843).



Could not parse problem

Using the coefficients above, please estimate the predicted outcome for the intervention group at time point 25 (to two decimal places):





Explanation
At time point 25, you would calculate the predicted change as follows. First, the model prediction:
pred = B0*intercept + B1*time + B2*leveldiff + B3*trenddiff + B4*levelchange + B5*trendchange + B6*levelchangediff + B7*trendchangediff
pred = 19.6 + 0.13*25 + 1.4 + 0.04 * 25 + -0.14 + -0.3*10 + -4.36 + -0.5*10 (remember that you are 10 time periods after the intervention!)
pred = 12.75


Now, calculate the counterfactual at the same time point:





Explanation
At time point 25, you would calculate the counterfactual by leaving off the level and trend change variables as follows:
cfac = B0*intercept + B1*time + B2*leveldiff + B3*trenddiff + B4*levelchange + B5*trendchange
cfac = 19.6 + 0.13*25 + 1.4 + 0.04 * 25 - 0.14 - 0.3*10
cfac = 22.11


Finally, use these two numbers to calculate the absolute predicted change be at time period 25:





Explanation
At time point 25, you would calculate the predicted change as follows:
predicted change = pred - cfac
  = 12.75 - 22.11
  = -9.36



Could not parse problem

What is the absolute predicted change in the market share for non-preferred agents in West Virginia at 6 quarters after the policy was introduced (as a proportion to 2 decimal places - e.g. 0.47)?






Explanation
To calculate the predicted value at 6 quarters after the policy change, first get the fitted values at time period 14. Remember there are 8 pre-policy quarters, and we are interested in 6 quarters after that, so 14 using fitted(). Then estimate the counterfactual at the same time point, and be sure to include the variables for the control group in your caluclations. Finally, calculate the absolute change at 6 quarters.



Could not parse problem

Now, what would the relative change be at 2 years after the policy change (as a percentage to one decimal place - e.g. 14.3)?






Explanation
To perform this calculation use the method as above, but use 16 instead of 14. Then calculate the relative change using the following formula to get the relative change:
(pred - cfac) / cfac = -29.1



Could not parse problem

What is your estimate for the level change after the policy change?




What is your estimate for the trend change?




Finally, compare your estimate for the level change to a model that doesn't account for the anticipatory effect. What is the difference between them (i.e. estimate with wild point minus estimate without wild point)?






Explanation
After accounting for the wild point, your model coefficients should be as follows:
level: -2.455
trend: 0.015
For the difference, a standard model fit without the wild point gives an estimate of -2.645, so
difference = estimate with wild point - estimate without the wild point
difference = -2.455 - (-2.645)
difference = 0.190



Could not parse problem

What is your estimate for the level change in the percentage of youths prescribed an antidepressant after the FDA warning?




And what is your estimate for the trend change?




Finally, run your model again without the phase-in period and compare your estimate for the level change to this model. What is the difference between them (i.e. estimate with phase-in period minus estimate without the phase-in period)?






Explanation
For Item 1, your estimate for the level change should be −0.318.
For Item 2, your estimate for the trend change should be -0.021.
For Item 3, after removing the phase-in period from your model, your estimate for the level change should be 0.058. For the difference, calculate as follows:
difference = level estimate with a phase-in period - level estimate without a phase-in period
difference = -0.318 - 0.058
difference = -0.376



Could not parse problem

What is your estimate for the level change for the 3-drug-cap?




And what is your estimate for the trend change for the 3-drug-cap?




What is your estimate for the level change for the change from the cap to the $1 copay?




And what is your estimate for the trend change from the cap to the $1 copay?






Explanation
Your model results should be as follows:
Coefficients:
                Value  Std.Error   t-value p-value
(Intercept)  5.150702 0.10209657  50.44931  0.0000
time         0.001193 0.00895446   0.13323  0.8947
level       -2.454561 0.17186121 -14.28223  0.0000
trend        0.015171 0.02226371   0.68141  0.4994
level2       0.541176 0.16218575   3.33677  0.0018
trend2       0.059127 0.02296759   2.57435  0.0138
wild         1.025439 0.23691279   4.32834  0.0001



Could not parse problem

Using the model parameters, please calculate the predicted absolute change one year after the $1 copay (i.e. in July 1983) relative to the level and trend with the 3-drug-cap:






Explanation
To calculate the absolute change, you first use the fitted value from the final model at time period 43, which is 4.347. You then subtract from that the predicted value at the same time period, which you need to calculate using the first four beta coefficients from the model (remember your counterfactual is relative to the first policy at this point):
Subtracting this from your predicted value gives the result of 1.251.



Could not parse problem

What is your estimate for the level change after the FDA warning?




And what is your estimate for the trend change parameter (not the quadratic term)?




What is your estimate for the coefficient on the quadratic trend term?






Explanation
Your model results should be as follows:
Coefficients:
                 Value   Std.Error   t-value p-value
(Intercept)  1.5006176 0.015476587  96.96050       0
time         0.0261050 0.001742213  14.98383       0
level       -0.3001670 0.030208652  -9.93646       0
trend       -0.0569704 0.003714522 -15.33720       0
trend_2      0.0012056 0.000139141   8.66450       0



Could not parse problem

Using the model coefficients, please estimate the absolute change at 2 years after the phase-in period (i.e. in 2006, Quarter 4).






Explanation
The absolute change at 2 years after the intervention is calculated as follows:
1. First, use the predicated value from 2006Q4 from the model using the fitted values (remember that this is predicted value 23 not 28 as you have removed 5 lines from your dataset):
pred = 1.553
2. Second, calculate the counterfactual using the following formula:
cfac = B_0 + B_1*28
cfac = 1.501 + 0.026*28
cfac = 2.232
Remember that we have a phase-in period, so the baseline trend value is 28 at 2006Q4.
Subtracting these two values gives the estimated absolute change of -0.679.



Multiple Choice JSON Ready
Assessment JSON Ready
ITSx_1T2016 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
ITSx_1T2016 wrangle_video already exists. Ignoring.
ITSx_1T2016 wrangle_link_page already exists. Ignoring.
ITSx_1T2016 wrangle_general already exists. Ignoring.
ITSx_1T2016 wrangle_assessments already exists. Ignoring.
ITSx_1T2017 demographic_multiple_choice already exists. Ignoring.
ITSx_1T2017 open_assessment already exists. Ignoring.
ITSx_1T2017 generalized_video_heat already exists. Ignoring.
ITSx_1T2017 generalized_video_axis already exists. Ignoring.
ITSx_1T2017 generalized_demographics already exists. Ignoring.
ITSx_1T2017 forum_posts already exists. Ignoring.
ITSx_1T2017 forum_searches already exists. Ignoring.
ITSx_1T2017 forum_views already exists. Ignoring.
ITSx_1T2017 tower_item already exists. Ignoring.
ITSx_1T2017 tower_engage_dirt already exists. Ignoring.
ITSx_1T2017 course_axis already exists. Ignoring.
ITSx_1T2017 external_link_dirt already exists. Ignoring.
ITSx_1T2017 page_dirt already exists. Ignoring.
Could not parse problem


Using your mouse, drag and drop each name in the scrollbar to the matching study design shown in the image.









correct_answer = {'1': 't2', '2': 't3', '3': 't1'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
To correctly identify the different study designs, be sure to pay attention to the number of groups being studied and the number of time periods. Starting from the left, the first study design has two groups and two time periods, making it a pre-post with control. The second has one group at two time periods, so is a pre-post (it does not have a control). Finally, the furthest right has two groups at one time point, so is a post-only with control study.



Could not parse problem


Using your mouse, drag and drop each type of level and trend change in the scrollbar to the matching result from the image.












correct_answer = {'4': 't1', '3': 't2', '1': 't3', '2': 't4'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
To determine the changes present in the charts, be sure to compare the observed line in the post period (solid line on right of charts) to the counterfactual (dashed). Starting from the top left, the red chart shows both a level change and trend change from the counterfactual, the green a level change and no trend change, the purple no level change or trend change, and the blue no level change but a trend change.



Could not parse problem


Using your mouse, drag and drop each estimate that Sophie will estimate from her interrupted time series onto her chart.












correct_answer = {'1': 't1', '3': 't2', '2': 't3', '4': 't4'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
From left to right, the arrows represent the (1) Existing level, (2) Existing trend, (3) Level Change, and (4) Trend change.



Could not parse problem

 Which function in R allows you to draw a figure?





Explanation
 The plot command is used in R to draw a figure.



Could not parse problem

What is the total number of time points in the dataset?



At what value of data$time did you draw the abline indicating the start of the prior authorization policy?





Explanation
The dataset runs for 19 calendar quarters, from Q1 2001 quarter 1 to Q4 2005. As the prior authorization started at time point 8 in the dataset, the policy line is most appropriate placed between that and the next time point at 8.5.



Could not parse problem

 Which of the plots is consistent with a change in level following the policy change?





Explanation
Remember that a level change is an immediate drop in the outcome that is sustained over the post period. As the drop in Series 2 is abrupt and continues the pre-existing flat trend, it is representative of a level change.



Could not parse problem

What function do you use in R to run a standard linear regression?






Explanation
The lm function in R allows you to run a standard linear regression model.



Could not parse problem

Aside from the intercept term, how many variables are necessary to model a single-series interrupted time series model?





Explanation
A standard segmented regression model for interrupted time series requires 3 variables aside from the intercept term: (1) an existing trend, (2) a level change, and (3) a trend change.



Could not parse problem

With reference to the standard regression for the West Virginia data, what are your estimates of the following variables:
The existing level?



The pre-existing trend per quarter?



The estimated level change following the prior authorization policy?



The estimated change in the trend per quarter following the policy change?





Explanation
Rounded to two significant figures, your coefficients should be as follows:
Existing Level: 0.51
Existing Trend: -0.0020
Level Change: -0.017
Trend Change: -0.015



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots show a spike in the PACF at 3 and exponential decay in the ACF, which are suggestive of an AR(3) function underlying the data generation process.



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots show a spike in the ACF at 2 and exponential decay in the PACF, which are suggestive of an MA(2) function underlying the data generation process.



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots do not show significant spikes in either the ACF or PACF, suggesting neither an AR() or MA() process.



Could not parse problem

 Which of the plots above resembles the ones you produced?





Explanation
Your plots should have resembled Image 2.


Based on these plots, what AR() and MA() parameters would you use in your final model?
AR:



MA:





Explanation
There are no indications of significiant spikes in either the ACF or PACF for this data, suggesting that no AR() or MA() process underlies the data.



Could not parse problem

Compare the final model based on the ACF and PACF plots to one with 1 additional AR() term. What is the p-value?




Perform the same comparison to a model with 1 additional MA() term. What is the p-value for this comparison?






Explanation
Note that while the null hypothesis is not rejected in the AR(1) model, it is with the MA(1) model. This suggests that our final model should be modified to include an MA(1) parameter.



Could not parse problem

Using the coefficients above, please estimate the predicted outcome at time point 20 (to two decimal places):





Explanation
At time point 20, you would calculate the predicted change as follows. First, the model prediction:
pred = B0*intercept + B2*time + B3*level + B4*trend
pred = 12.24 - 0.13*20 - 2.46 - 0.29*5 (remember that you are 5 time periods after the intervention!)
pred = 5.73


Now, calculate the counterfactual at the same time point:





Explanation
At time point 20, you would calculate the counterfactual by leaving off the level and trend change variables as follows:
cfac = B0*intercept + B2*time
cfac = 12.24 - 0.13*20
cfac = 9.64


Finally, use these two numbers to calculate the absolute predicted change be at time period 20:





Explanation
At time point 20, you would calculate the counterfactual as follows:
predicted change = pred - cfac
  = 5.73 - 9.64
  = -3.91



Could not parse problem

What is the absolute predicted change in the market share for non-preferred agents in West Virginia at 6 quarters after the policy was introduced (as a proportion to 2 decimal places - e.g. 0.47)?






Explanation
To calculate the predicted value at 6 quarters after the policy change, first get the fitted values at time period 14. Remember there are 8 pre-policy quarters, and we are interested in 6 quarters after that, so 14 using fitted(). Then estimate the counterfactual at the same time point. Finally, calculate the absolute change at 6 quarters.



Could not parse problem

Now, what would the relative change be at 2 years after the policy change (as a percentage - e.g. 14.3)?





Explanation
To perform this caluclation use the method as above, but use 16 instead of 14. Then calculate the relative change using the following formula to get the relative change:
(pred - cfac) / cfac = -29.47



Could not parse problem

How many lines in total are contained in the controlled dataset?



On which line does the data for the control group start?





Explanation
There are 38 total lines in the dataset, and the data for the control group starts on line 20.



Could not parse problem

With reference to the standard regression for the West Virginia data with a control group, what are your estimates of the following variables:
The existing level difference?




The pre-existing difference in the trend per quarter?




The estimated level change following the prior authorization policy relative to the control group?




The estimated change in the trend per quarter following the policy change relative to the control group?






Explanation
Rounded to three significant figures, your coefficients should be as follows:
Level difference: 0.0268
Trend difference: -0.00117
Level Change difference: -0.0351
Trend Change difference: -0.0129
Note that these are the coefficients for the relative changes, not the values for the control group.



Could not parse problem

Using the model coefficients, calculate how much higher water flow was predicted to be in the Nile in 1880 compared to the Huron, and enter your answer below:





Explanation
To calculate the expected difference in 1880, or at point 10, we can do the following calculation:
1. Expected level in the Huron = 2464.7702 + -20.2181 * 10 = 2262.5892
2. Expected level in the Nile = 2464.7702 + -20.2181 * 10 + 885.428 + 26.8242 * 10 = 3416.2592
Subtracting the first expected value from the second results in an answer of 1153.67.



Could not parse problem

What is your estimate for the level change in West Virginia relative to the control states?



What is the lower bound on the 95% confidence interval for this estimate?



What is the higher bound on the 95% confidence interval?





Explanation
The estimate for the level change relative to the control group is -0.0351 (95% CI: -0.0563 to -0.0139).



Could not parse problem

What is your estimate for the trend change in West Virginia relative to the control states?



What is the lower bound on the 95% confidence interval for this estimate?



What is the higher bound on the 95% confidence interval?





Explanation
The estimate for the trend change relative to the control group is -0.0129 (95% CI: -0.0173 to -0.00843).



Could not parse problem

Using the coefficients above, please estimate the predicted outcome for the intervention group at time point 25 (to two decimal places):





Explanation
At time point 25, you would calculate the predicted change as follows. First, the model prediction:
pred = B0*intercept + B1*time + B2*leveldiff + B3*trenddiff + B4*levelchange + B5*trendchange + B6*levelchangediff + B7*trendchangediff
pred = 19.6 + 0.13*25 + 1.4 + 0.04 * 25 + -0.14 + -0.3*10 + -4.36 + -0.5*10 (remember that you are 10 time periods after the intervention!)
pred = 12.75


Now, calculate the counterfactual at the same time point:





Explanation
At time point 25, you would calculate the counterfactual by leaving off the level and trend change variables as follows:
cfac = B0*intercept + B1*time + B2*leveldiff + B3*trenddiff + B4*levelchange + B5*trendchange
cfac = 19.6 + 0.13*25 + 1.4 + 0.04 * 25 - 0.14 - 0.3*10
cfac = 22.11


Finally, use these two numbers to calculate the absolute predicted change be at time period 25:





Explanation
At time point 25, you would calculate the predicted change as follows:
predicted change = pred - cfac
  = 12.75 - 22.11
  = -9.36



Could not parse problem

What is the absolute predicted change in the market share for non-preferred agents in West Virginia at 6 quarters after the policy was introduced (as a proportion to 2 decimal places - e.g. 0.47)?






Explanation
To calculate the predicted value at 6 quarters after the policy change, first get the fitted values at time period 14. Remember there are 8 pre-policy quarters, and we are interested in 6 quarters after that, so 14 using fitted(). Then estimate the counterfactual at the same time point, and be sure to include the variables for the control group in your caluclations. Finally, calculate the absolute change at 6 quarters.



Could not parse problem

Now, what would the relative change be at 2 years after the policy change (as a percentage to one decimal place - e.g. 14.3)?






Explanation
To perform this calculation use the method as above, but use 16 instead of 14. Then calculate the relative change using the following formula to get the relative change:
(pred - cfac) / cfac = -29.1



Could not parse problem

What is your estimate for the level change after the policy change?




What is your estimate for the trend change?




Finally, compare your estimate for the level change to a model that doesn't account for the anticipatory effect. What is the difference between them (i.e. estimate with wild point minus estimate without wild point)?






Explanation
After accounting for the wild point, your model coefficients should be as follows:
level: -2.455
trend: 0.015
For the difference, a standard model fit without the wild point gives an estimate of -2.645, so
difference = estimate with wild point - estimate without the wild point
difference = -2.455 - (-2.645)
difference = 0.190



Could not parse problem

What is your estimate for the level change in the percentage of youths prescribed an antidepressant after the FDA warning?




And what is your estimate for the trend change?




Finally, run your model again without the phase-in period and compare your estimate for the level change to this model. What is the difference between them (i.e. estimate with phase-in period minus estimate without the phase-in period)?






Explanation
For Item 1, your estimate for the level change should be −0.318.
For Item 2, your estimate for the trend change should be -0.021.
For Item 3, after removing the phase-in period from your model, your estimate for the level change should be 0.058. For the difference, calculate as follows:
difference = level estimate with a phase-in period - level estimate without a phase-in period
difference = -0.318 - 0.058
difference = -0.376



Could not parse problem

What is your estimate for the level change for the 3-drug-cap?




And what is your estimate for the trend change for the 3-drug-cap?




What is your estimate for the level change for the change from the cap to the $1 copay?




And what is your estimate for the trend change from the cap to the $1 copay?






Explanation
Your model results should be as follows:
Coefficients:
                Value  Std.Error   t-value p-value
(Intercept)  5.150702 0.10209657  50.44931  0.0000
time         0.001193 0.00895446   0.13323  0.8947
level       -2.454561 0.17186121 -14.28223  0.0000
trend        0.015171 0.02226371   0.68141  0.4994
level2       0.541176 0.16218575   3.33677  0.0018
trend2       0.059127 0.02296759   2.57435  0.0138
wild         1.025439 0.23691279   4.32834  0.0001



Could not parse problem

Using the model parameters, please calculate the predicted absolute change one year after the $1 copay (i.e. in July 1983) relative to the level and trend with the 3-drug-cap:






Explanation
To calculate the absolute change, you first use the fitted value from the final model at time period 43, which is 4.347. You then subtract from that the predicted value at the same time period, which you need to calculate using the first four beta coefficients from the model (remember your counterfactual is relative to the first policy at this point):
Subtracting this from your predicted value gives the result of 1.251.



Could not parse problem

What is your estimate for the level change after the FDA warning?




And what is your estimate for the trend change parameter (not the quadratic term)?




What is your estimate for the coefficient on the quadratic trend term?






Explanation
Your model results should be as follows:
Coefficients:
                 Value   Std.Error   t-value p-value
(Intercept)  1.5006176 0.015476587  96.96050       0
time         0.0261050 0.001742213  14.98383       0
level       -0.3001670 0.030208652  -9.93646       0
trend       -0.0569704 0.003714522 -15.33720       0
trend_2      0.0012056 0.000139141   8.66450       0



Could not parse problem

Using the model coefficients, please estimate the absolute change at 2 years after the phase-in period (i.e. in 2006, Quarter 4).






Explanation
The absolute change at 2 years after the intervention is calculated as follows:
1. First, use the predicated value from 2006Q4 from the model using the fitted values (remember that this is predicted value 23 not 28 as you have removed 5 lines from your dataset):
pred = 1.553
2. Second, calculate the counterfactual using the following formula:
cfac = B_0 + B_1*28
cfac = 1.501 + 0.026*28
cfac = 2.232
Remember that we have a phase-in period, so the baseline trend value is 28 at 2006Q4.
Subtracting these two values gives the estimated absolute change of -0.679.



Multiple Choice JSON Ready
Assessment JSON Ready
ITSx_1T2017 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
ITSx_1T2017 wrangle_video already exists. Ignoring.
ITSx_1T2017 wrangle_link_page already exists. Ignoring.
ITSx_1T2017 wrangle_general already exists. Ignoring.
ITSx_2T2015 demographic_multiple_choice already exists. Ignoring.
ITSx_2T2015 open_assessment already exists. Ignoring.
ITSx_2T2015 generalized_video_heat already exists. Ignoring.
ITSx_2T2015 generalized_video_axis already exists. Ignoring.
ITSx_2T2015 generalized_demographics already exists. Ignoring.
ITSx_2T2015 forum_posts already exists. Ignoring.
ITSx_2T2015 forum_searches already exists. Ignoring.
ITSx_2T2015 forum_views already exists. Ignoring.
ITSx_2T2015 tower_item already exists. Ignoring.
ITSx_2T2015 tower_engage_dirt already exists. Ignoring.
ITSx_2T2015 course_axis already exists. Ignoring.
ITSx_2T2015 external_link_dirt already exists. Ignoring.
ITSx_2T2015 page_dirt already exists. Ignoring.
Could not parse problem


Using your mouse, drag and drop each name in the scrollbar to the matching study design shown in the image.









correct_answer = {'1': 't2', '2': 't3', '3': 't1'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
To correctly identify the different study designs, be sure to pay attention to the number of groups being studied and the number of time periods. Starting from the left, the first study design has two groups and two time periods, making it a pre-post with control. The second has one group at two time periods, so is a pre-post (it does not have a control). Finally, the furthest right has two groups at one time point, so is a post-only with control study.



Could not parse problem


Using your mouse, drag and drop each type of level and trend change in the scrollbar to the matching result from the image.












correct_answer = {'4': 't1', '3': 't2', '1': 't3', '2': 't4'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
To determine the changes present in the charts, be sure to compare the observed line in the post period (solid line on right of charts) to the counterfactual (dashed). Starting from the top left, the red chart shows both a level change and trend change from the counterfactual, the green a level change and no trend change, the purple no level change or trend change, and the blue no level change but a trend change.



Could not parse problem


Using your mouse, drag and drop each estimate that Sophie will estimate from her interrupted time series onto her chart.












correct_answer = {'1': 't1', '3': 't2', '2': 't3', '4': 't4'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
From left to right, the arrows represent the (1) Existing level, (2) Existing trend, (3) Level Change, and (4) Trend change.



Could not parse problem

 Which function in R allows you to draw a figure?





Explanation
 The plot command is used in R to draw a figure.



Could not parse problem

What is the total number of time points in the dataset?



At what value of data$time did you draw the abline indicating the start of the prior authorization policy?





Explanation
The dataset runs for 19 calendar quarters, from Q1 2001 quarter 1 to Q4 2005. As the prior authorization started at time point 8 in the dataset, the policy line is most appropriate placed between that and the next time point at 8.5.



Could not parse problem

 Which of the plots is consistent with a change in level following the policy change?





Explanation
Remember that a level change is an immediate drop in the outcome that is sustained over the post period. As the drop in Series 2 is abrupt and continues the pre-existing flat trend, it is representative of a level change.



Could not parse problem

What function do you use in R to run a standard linear regression?






Explanation
The lm function in R allows you to run a standard linear regression model.



Could not parse problem

Aside from the intercept term, how many variables are necessary to model a single-series interrupted time series model?





Explanation
A standard segmented regression model for interrupted time series requires 3 variables aside from the intercept term: (1) an existing trend, (2) a level change, and (3) a trend change.



Could not parse problem

With reference to the standard regression for the West Virginia data, what are your estimates of the following variables:
The existing level?



The pre-existing trend per quarter?



The estimated level change following the prior authorization policy?



The estimated change in the trend per quarter following the policy change?





Explanation
Rounded to two significant figures, your coefficients should be as follows:
Existing Level: 0.51
Existing Trend: -0.0020
Level Change: -0.017
Trend Change: -0.015



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots show a spike in the PACF at 3 and exponential decay in the ACF, which are suggestive of an AR(3) function underlying the data generation process.



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots show a spike in the ACF at 2 and exponential decay in the PACF, which are suggestive of an MA(2) function underlying the data generation process.



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots do not show significant spikes in either the ACF or PACF, suggesting neither an AR() or MA() process.



Could not parse problem

 Which of the plots above resembles the ones you produced?





Explanation
Your plots should have resembled Image 2.


Based on these plots, what AR() and MA() parameters would you use in your final model?
AR:



MA:





Explanation
There are no indications of significiant spikes in either the ACF or PACF for this data, suggesting that no AR() or MA() process underlies the data.



Could not parse problem

Compare the final model based on the ACF and PACF plots to one with 1 additional AR() term. What is the p-value?




Perform the same comparison to a model with 1 additional MA() term. What is the p-value for this comparison?






Explanation
Note that while the null hypothesis is not rejected in the AR(1) model, it is with the MA(1) model. This suggests that our final model should be modified to include an MA(1) parameter.



Could not parse problem

Using the coefficients above, please estimate the predicted outcome at time point 20 (to two decimal places):





Explanation
At time point 20, you would calculate the predicted change as follows. First, the model prediction:
pred = B0*intercept + B2*time + B3*level + B4*trend
pred = 12.24 - 0.13*20 - 2.46 - 0.29*5 (remember that you are 5 time periods after the intervention!)
pred = 5.73


Now, calculate the counterfactual at the same time point:





Explanation
At time point 20, you would calculate the counterfactual by leaving off the level and trend change variables as follows:
cfac = B0*intercept + B2*time
cfac = 12.24 - 0.13*20
cfac = 9.64


Finally, use these two numbers to calculate the absolute predicted change be at time period 20:





Explanation
At time point 20, you would calculate the counterfactual as follows:
predicted change = pred - cfac
  = 5.73 - 9.64
  = -3.91



Could not parse problem

What is the absolute predicted change in the market share for non-preferred agents in West Virginia at 6 quarters after the policy was introduced (as a proportion to 2 decimal places - e.g. 0.47)?






Explanation
To calculate the predicted value at 6 quarters after the policy change, first get the fitted values at time period 14. Remember there are 8 pre-policy quarters, and we are interested in 6 quarters after that, so 14 using fitted(). Then estimate the counterfactual at the same time point. Finally, calculate the absolute change at 6 quarters.



Could not parse problem

Now, what would the relative change be at 2 years after the policy change (as a percentage - e.g. 14.3)?





Explanation
To perform this caluclation use the method as above, but use 16 instead of 14. Then calculate the relative change using the following formula to get the relative change:
(pred - cfac) / cfac = -29.47



Could not parse problem

How many lines in total are contained in the controlled dataset?



On which line does the data for the control group start?





Explanation
There are 38 total lines in the dataset, and the data for the control group starts on line 20.



Could not parse problem

With reference to the standard regression for the West Virginia data with a control group, what are your estimates of the following variables:
The existing level difference?




The pre-existing difference in the trend per quarter?




The estimated level change following the prior authorization policy relative to the control group?




The estimated change in the trend per quarter following the policy change relative to the control group?






Explanation
Rounded to three significant figures, your coefficients should be as follows:
Level difference: 0.0268
Trend difference: -0.00117
Level Change difference: -0.0351
Trend Change difference: -0.0129
Note that these are the coefficients for the relative changes, not the values for the control group.



Could not parse problem

Using the model coefficients, calculate how much higher water flow was predicted to be in the Nile in 1880 compared to the Huron, and enter your answer below:





Explanation
To calculate the expected difference in 1880, or at point 10, we can do the following calculation:
1. Expected level in the Huron = 2464.7702 + -20.2181 * 10 = 2262.5892
2. Expected level in the Nile = 2464.7702 + -20.2181 * 10 + 885.428 + 26.8242 * 10 = 3416.2592
Subtracting the first expected value from the second results in an answer of 1153.67.



Could not parse problem

What is your estimate for the level change in West Virginia relative to the control states?



What is the lower bound on the 95% confidence interval for this estimate?



What is the higher bound on the 95% confidence interval?





Explanation
The estimate for the level change relative to the control group is -0.0351 (95% CI: -0.0563 to -0.0139).



Could not parse problem

What is your estimate for the trend change in West Virginia relative to the control states?



What is the lower bound on the 95% confidence interval for this estimate?



What is the higher bound on the 95% confidence interval?





Explanation
The estimate for the trend change relative to the control group is -0.0129 (95% CI: -0.0173 to -0.00843).



Could not parse problem

Using the coefficients above, please estimate the predicted outcome for the intervention group at time point 25 (to two decimal places):





Explanation
At time point 25, you would calculate the predicted change as follows. First, the model prediction:
pred = B0*intercept + B1*time + B2*leveldiff + B3*trenddiff + B4*levelchange + B5*trendchange + B6*levelchangediff + B7*trendchangediff
pred = 19.6 + 0.13*25 + 1.4 + 0.04 * 25 + -0.14 + -0.3*10 + -4.36 + -0.5*10 (remember that you are 10 time periods after the intervention!)
pred = 12.75


Now, calculate the counterfactual at the same time point:





Explanation
At time point 25, you would calculate the counterfactual by leaving off the level and trend change variables as follows:
cfac = B0*intercept + B1*time + B2*leveldiff + B3*trenddiff + B4*levelchange + B5*trendchange
cfac = 19.6 + 0.13*25 + 1.4 + 0.04 * 25 - 0.14 - 0.3*10
cfac = 22.11


Finally, use these two numbers to calculate the absolute predicted change be at time period 25:





Explanation
At time point 25, you would calculate the predicted change as follows:
predicted change = pred - cfac
  = 12.75 - 22.11
  = -9.36



Could not parse problem

What is the absolute predicted change in the market share for non-preferred agents in West Virginia at 6 quarters after the policy was introduced (as a proportion to 2 decimal places - e.g. 0.47)?






Explanation
To calculate the predicted value at 6 quarters after the policy change, first get the fitted values at time period 14. Remember there are 8 pre-policy quarters, and we are interested in 6 quarters after that, so 14 using fitted(). Then estimate the counterfactual at the same time point, and be sure to include the variables for the control group in your caluclations. Finally, calculate the absolute change at 6 quarters.



Could not parse problem

Now, what would the relative change be at 2 years after the policy change (as a percentage to one decimal place - e.g. 14.3)?






Explanation
To perform this calculation use the method as above, but use 16 instead of 14. Then calculate the relative change using the following formula to get the relative change:
(pred - cfac) / cfac = -29.1



Could not parse problem

What is your estimate for the level change after the policy change?




What is your estimate for the trend change?




Finally, compare your estimate for the level change to a model that doesn't account for the anticipatory effect. What is the difference between them (i.e. estimate with wild point minus estimate without wild point)?






Explanation
After accounting for the wild point, your model coefficients should be as follows:
level: -2.455
trend: 0.015
For the difference, a standard model fit without the wild point gives an estimate of -2.645, so
difference = estimate with wild point - estimate without the wild point
difference = -2.455 - (-2.645)
difference = 0.190



Could not parse problem

What is your estimate for the level change in the percentage of youths prescribed an antidepressant after the FDA warning?




And what is your estimate for the trend change?




Finally, run your model again without the phase-in period and compare your estimate for the level change to this model. What is the difference between them (i.e. estimate with phase-in period minus estimate without the phase-in period)?






Explanation
For Item 1, your estimate for the level change should be −0.318.
For Item 2, your estimate for the trend change should be -0.021.
For Item 3, after removing the phase-in period from your model, your estimate for the level change should be 0.058. For the difference, calculate as follows:
difference = level estimate with a phase-in period - level estimate without a phase-in period
difference = -0.318 - 0.058
difference = -0.376



Could not parse problem

What is your estimate for the level change for the 3-drug-cap?




And what is your estimate for the trend change for the 3-drug-cap?




What is your estimate for the level change for the change from the cap to the $1 copay?




And what is your estimate for the trend change from the cap to the $1 copay?






Explanation
Your model results should be as follows:
Coefficients:
                Value  Std.Error   t-value p-value
(Intercept)  5.150702 0.10209657  50.44931  0.0000
time         0.001193 0.00895446   0.13323  0.8947
level       -2.454561 0.17186121 -14.28223  0.0000
trend        0.015171 0.02226371   0.68141  0.4994
level2       0.541176 0.16218575   3.33677  0.0018
trend2       0.059127 0.02296759   2.57435  0.0138
wild         1.025439 0.23691279   4.32834  0.0001



Could not parse problem

Using the model parameters, please calculate the predicted absolute change one year after the $1 copay (i.e. in July 1983) relative to the level and trend with the 3-drug-cap:






Explanation
To calculate the absolute change, you first use the fitted value from the final model at time period 43, which is 4.347. You then subtract from that the predicted value at the same time period, which you need to calculate using the first four beta coefficients from the model (remember your counterfactual is relative to the first policy at this point):
Subtracting this from your predicted value gives the result of 1.251.



Could not parse problem

What is your estimate for the level change after the FDA warning?




And what is your estimate for the trend change parameter (not the quadratic term)?




What is your estimate for the coefficient on the quadratic trend term?






Explanation
Your model results should be as follows:
Coefficients:
                 Value   Std.Error   t-value p-value
(Intercept)  1.5006176 0.015476587  96.96050       0
time         0.0261050 0.001742213  14.98383       0
level       -0.3001670 0.030208652  -9.93646       0
trend       -0.0569704 0.003714522 -15.33720       0
trend_2      0.0012056 0.000139141   8.66450       0



Could not parse problem

Using the model coefficients, please estimate the absolute change at 2 years after the phase-in period (i.e. in 2006, Quarter 4).






Explanation
The absolute change at 2 years after the intervention is calculated as follows:
1. First, use the predicated value from 2006Q4 from the model using the fitted values (remember that this is predicted value 23 not 28 as you have removed 5 lines from your dataset):
pred = 1.553
2. Second, calculate the counterfactual using the following formula:
cfac = B_0 + B_1*28
cfac = 1.501 + 0.026*28
cfac = 2.232
Remember that we have a phase-in period, so the baseline trend value is 28 at 2006Q4.
Subtracting these two values gives the estimated absolute change of -0.679.



Multiple Choice JSON Ready
Assessment JSON Ready
ITSx_2T2015 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
ITSx_2T2015 wrangle_video already exists. Ignoring.
ITSx_2T2015 wrangle_link_page already exists. Ignoring.
ITSx_2T2015 wrangle_general already exists. Ignoring.
ITSx_2T2015 wrangle_assessments already exists. Ignoring.
ITSx_3T2016 demographic_multiple_choice already exists. Ignoring.
ITSx_3T2016 open_assessment already exists. Ignoring.
ITSx_3T2016 generalized_video_heat already exists. Ignoring.
ITSx_3T2016 generalized_video_axis already exists. Ignoring.
ITSx_3T2016 generalized_demographics already exists. Ignoring.
ITSx_3T2016 forum_posts already exists. Ignoring.
ITSx_3T2016 forum_searches already exists. Ignoring.
ITSx_3T2016 forum_views already exists. Ignoring.
ITSx_3T2016 tower_item already exists. Ignoring.
ITSx_3T2016 tower_engage_dirt already exists. Ignoring.
ITSx_3T2016 course_axis already exists. Ignoring.
ITSx_3T2016 external_link_dirt already exists. Ignoring.
ITSx_3T2016 page_dirt already exists. Ignoring.
Could not parse problem


Using your mouse, drag and drop each name in the scrollbar to the matching study design shown in the image.









correct_answer = {'1': 't2', '2': 't3', '3': 't1'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
To correctly identify the different study designs, be sure to pay attention to the number of groups being studied and the number of time periods. Starting from the left, the first study design has two groups and two time periods, making it a pre-post with control. The second has one group at two time periods, so is a pre-post (it does not have a control). Finally, the furthest right has two groups at one time point, so is a post-only with control study.



Could not parse problem


Using your mouse, drag and drop each type of level and trend change in the scrollbar to the matching result from the image.












correct_answer = {'4': 't1', '3': 't2', '1': 't3', '2': 't4'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
To determine the changes present in the charts, be sure to compare the observed line in the post period (solid line on right of charts) to the counterfactual (dashed). Starting from the top left, the red chart shows both a level change and trend change from the counterfactual, the green a level change and no trend change, the purple no level change or trend change, and the blue no level change but a trend change.



Could not parse problem


Using your mouse, drag and drop each estimate that Sophie will estimate from her interrupted time series onto her chart.












correct_answer = {'1': 't1', '3': 't2', '2': 't3', '4': 't4'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        



Explanation
From left to right, the arrows represent the (1) Existing level, (2) Existing trend, (3) Level Change, and (4) Trend change.



Could not parse problem

 Which function in R allows you to draw a figure?





Explanation
 The plot command is used in R to draw a figure.



Could not parse problem

What is the total number of time points in the dataset?



At what value of data$time did you draw the abline indicating the start of the prior authorization policy?





Explanation
The dataset runs for 19 calendar quarters, from Q1 2001 quarter 1 to Q4 2005. As the prior authorization started at time point 8 in the dataset, the policy line is most appropriate placed between that and the next time point at 8.5.



Could not parse problem

 Which of the plots is consistent with a change in level following the policy change?





Explanation
Remember that a level change is an immediate drop in the outcome that is sustained over the post period. As the drop in Series 2 is abrupt and continues the pre-existing flat trend, it is representative of a level change.



Could not parse problem

What function do you use in R to run a standard linear regression?






Explanation
The lm function in R allows you to run a standard linear regression model.



Could not parse problem

Aside from the intercept term, how many variables are necessary to model a single-series interrupted time series model?





Explanation
A standard segmented regression model for interrupted time series requires 3 variables aside from the intercept term: (1) an existing trend, (2) a level change, and (3) a trend change.



Could not parse problem

With reference to the standard regression for the West Virginia data, what are your estimates of the following variables:
The existing level?



The pre-existing trend per quarter?



The estimated level change following the prior authorization policy?



The estimated change in the trend per quarter following the policy change?





Explanation
Rounded to two significant figures, your coefficients should be as follows:
Existing Level: 0.51
Existing Trend: -0.0020
Level Change: -0.017
Trend Change: -0.015



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots show a spike in the PACF at 3 and exponential decay in the ACF, which are suggestive of an AR(3) function underlying the data generation process.



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots show a spike in the ACF at 2 and exponential decay in the PACF, which are suggestive of an MA(2) function underlying the data generation process.



Could not parse problem

 What would the appropriate AR() and MA() terms be for the above plots?
AR:



MA:





Explanation
The plots do not show significant spikes in either the ACF or PACF, suggesting neither an AR() or MA() process.



Could not parse problem

 Which of the plots above resembles the ones you produced?





Explanation
Your plots should have resembled Image 2.


Based on these plots, what AR() and MA() parameters would you use in your final model?
AR:



MA:





Explanation
There are no indications of significiant spikes in either the ACF or PACF for this data, suggesting that no AR() or MA() process underlies the data.



Could not parse problem

Compare the final model based on the ACF and PACF plots to one with 1 additional AR() term. What is the p-value?




Perform the same comparison to a model with 1 additional MA() term. What is the p-value for this comparison?






Explanation
Note that while the null hypothesis is not rejected in the AR(1) model, it is with the MA(1) model. This suggests that our final model should be modified to include an MA(1) parameter.



Could not parse problem

Using the coefficients above, please estimate the predicted outcome at time point 20 (to two decimal places):





Explanation
At time point 20, you would calculate the predicted change as follows. First, the model prediction:
pred = B0*intercept + B2*time + B3*level + B4*trend
pred = 12.24 - 0.13*20 - 2.46 - 0.29*5 (remember that you are 5 time periods after the intervention!)
pred = 5.73


Now, calculate the counterfactual at the same time point:





Explanation
At time point 20, you would calculate the counterfactual by leaving off the level and trend change variables as follows:
cfac = B0*intercept + B2*time
cfac = 12.24 - 0.13*20
cfac = 9.64


Finally, use these two numbers to calculate the absolute predicted change be at time period 20:





Explanation
At time point 20, you would calculate the counterfactual as follows:
predicted change = pred - cfac
  = 5.73 - 9.64
  = -3.91



Could not parse problem

What is the absolute predicted change in the market share for non-preferred agents in West Virginia at 6 quarters after the policy was introduced (as a proportion to 2 decimal places - e.g. 0.47)?






Explanation
To calculate the predicted value at 6 quarters after the policy change, first get the fitted values at time period 14. Remember there are 8 pre-policy quarters, and we are interested in 6 quarters after that, so 14 using fitted(). Then estimate the counterfactual at the same time point. Finally, calculate the absolute change at 6 quarters.



Could not parse problem

Now, what would the relative change be at 2 years after the policy change (as a percentage - e.g. 14.3)?





Explanation
To perform this caluclation use the method as above, but use 16 instead of 14. Then calculate the relative change using the following formula to get the relative change:
(pred - cfac) / cfac = -29.47



Could not parse problem

How many lines in total are contained in the controlled dataset?



On which line does the data for the control group start?





Explanation
There are 38 total lines in the dataset, and the data for the control group starts on line 20.



Could not parse problem

With reference to the standard regression for the West Virginia data with a control group, what are your estimates of the following variables:
The existing level difference?




The pre-existing difference in the trend per quarter?




The estimated level change following the prior authorization policy relative to the control group?




The estimated change in the trend per quarter following the policy change relative to the control group?






Explanation
Rounded to three significant figures, your coefficients should be as follows:
Level difference: 0.0268
Trend difference: -0.00117
Level Change difference: -0.0351
Trend Change difference: -0.0129
Note that these are the coefficients for the relative changes, not the values for the control group.



Could not parse problem

Using the model coefficients, calculate how much higher water flow was predicted to be in the Nile in 1880 compared to the Huron, and enter your answer below:





Explanation
To calculate the expected difference in 1880, or at point 10, we can do the following calculation:
1. Expected level in the Huron = 2464.7702 + -20.2181 * 10 = 2262.5892
2. Expected level in the Nile = 2464.7702 + -20.2181 * 10 + 885.428 + 26.8242 * 10 = 3416.2592
Subtracting the first expected value from the second results in an answer of 1153.67.



Could not parse problem

What is your estimate for the level change in West Virginia relative to the control states?



What is the lower bound on the 95% confidence interval for this estimate?



What is the higher bound on the 95% confidence interval?





Explanation
The estimate for the level change relative to the control group is -0.0351 (95% CI: -0.0563 to -0.0139).



Could not parse problem

What is your estimate for the trend change in West Virginia relative to the control states?



What is the lower bound on the 95% confidence interval for this estimate?



What is the higher bound on the 95% confidence interval?





Explanation
The estimate for the trend change relative to the control group is -0.0129 (95% CI: -0.0173 to -0.00843).



Could not parse problem

Using the coefficients above, please estimate the predicted outcome for the intervention group at time point 25 (to two decimal places):





Explanation
At time point 25, you would calculate the predicted change as follows. First, the model prediction:
pred = B0*intercept + B1*time + B2*leveldiff + B3*trenddiff + B4*levelchange + B5*trendchange + B6*levelchangediff + B7*trendchangediff
pred = 19.6 + 0.13*25 + 1.4 + 0.04 * 25 + -0.14 + -0.3*10 + -4.36 + -0.5*10 (remember that you are 10 time periods after the intervention!)
pred = 12.75


Now, calculate the counterfactual at the same time point:





Explanation
At time point 25, you would calculate the counterfactual by leaving off the level and trend change variables as follows:
cfac = B0*intercept + B1*time + B2*leveldiff + B3*trenddiff + B4*levelchange + B5*trendchange
cfac = 19.6 + 0.13*25 + 1.4 + 0.04 * 25 - 0.14 - 0.3*10
cfac = 22.11


Finally, use these two numbers to calculate the absolute predicted change be at time period 25:





Explanation
At time point 25, you would calculate the predicted change as follows:
predicted change = pred - cfac
  = 12.75 - 22.11
  = -9.36



Could not parse problem

What is the absolute predicted change in the market share for non-preferred agents in West Virginia at 6 quarters after the policy was introduced (as a proportion to 2 decimal places - e.g. 0.47)?






Explanation
To calculate the predicted value at 6 quarters after the policy change, first get the fitted values at time period 14. Remember there are 8 pre-policy quarters, and we are interested in 6 quarters after that, so 14 using fitted(). Then estimate the counterfactual at the same time point, and be sure to include the variables for the control group in your caluclations. Finally, calculate the absolute change at 6 quarters.



Could not parse problem

Now, what would the relative change be at 2 years after the policy change (as a percentage to one decimal place - e.g. 14.3)?






Explanation
To perform this calculation use the method as above, but use 16 instead of 14. Then calculate the relative change using the following formula to get the relative change:
(pred - cfac) / cfac = -29.1



Could not parse problem

What is your estimate for the level change after the policy change?




What is your estimate for the trend change?




Finally, compare your estimate for the level change to a model that doesn't account for the anticipatory effect. What is the difference between them (i.e. estimate with wild point minus estimate without wild point)?






Explanation
After accounting for the wild point, your model coefficients should be as follows:
level: -2.455
trend: 0.015
For the difference, a standard model fit without the wild point gives an estimate of -2.645, so
difference = estimate with wild point - estimate without the wild point
difference = -2.455 - (-2.645)
difference = 0.190



Could not parse problem

What is your estimate for the level change in the percentage of youths prescribed an antidepressant after the FDA warning?




And what is your estimate for the trend change?




Finally, run your model again without the phase-in period and compare your estimate for the level change to this model. What is the difference between them (i.e. estimate with phase-in period minus estimate without the phase-in period)?






Explanation
For Item 1, your estimate for the level change should be −0.318.
For Item 2, your estimate for the trend change should be -0.021.
For Item 3, after removing the phase-in period from your model, your estimate for the level change should be 0.058. For the difference, calculate as follows:
difference = level estimate with a phase-in period - level estimate without a phase-in period
difference = -0.318 - 0.058
difference = -0.376



Could not parse problem

What is your estimate for the level change for the 3-drug-cap?




And what is your estimate for the trend change for the 3-drug-cap?




What is your estimate for the level change for the change from the cap to the $1 copay?




And what is your estimate for the trend change from the cap to the $1 copay?






Explanation
Your model results should be as follows:
Coefficients:
                Value  Std.Error   t-value p-value
(Intercept)  5.150702 0.10209657  50.44931  0.0000
time         0.001193 0.00895446   0.13323  0.8947
level       -2.454561 0.17186121 -14.28223  0.0000
trend        0.015171 0.02226371   0.68141  0.4994
level2       0.541176 0.16218575   3.33677  0.0018
trend2       0.059127 0.02296759   2.57435  0.0138
wild         1.025439 0.23691279   4.32834  0.0001



Could not parse problem

Using the model parameters, please calculate the predicted absolute change one year after the $1 copay (i.e. in July 1983) relative to the level and trend with the 3-drug-cap:






Explanation
To calculate the absolute change, you first use the fitted value from the final model at time period 43, which is 4.347. You then subtract from that the predicted value at the same time period, which you need to calculate using the first four beta coefficients from the model (remember your counterfactual is relative to the first policy at this point):
Subtracting this from your predicted value gives the result of 1.251.



Could not parse problem

What is your estimate for the level change after the FDA warning?




And what is your estimate for the trend change parameter (not the quadratic term)?




What is your estimate for the coefficient on the quadratic trend term?






Explanation
Your model results should be as follows:
Coefficients:
                 Value   Std.Error   t-value p-value
(Intercept)  1.5006176 0.015476587  96.96050       0
time         0.0261050 0.001742213  14.98383       0
level       -0.3001670 0.030208652  -9.93646       0
trend       -0.0569704 0.003714522 -15.33720       0
trend_2      0.0012056 0.000139141   8.66450       0



Could not parse problem

Using the model coefficients, please estimate the absolute change at 2 years after the phase-in period (i.e. in 2006, Quarter 4).






Explanation
The absolute change at 2 years after the intervention is calculated as follows:
1. First, use the predicated value from 2006Q4 from the model using the fitted values (remember that this is predicted value 23 not 28 as you have removed 5 lines from your dataset):
pred = 1.553
2. Second, calculate the counterfactual using the following formula:
cfac = B_0 + B_1*28
cfac = 1.501 + 0.026*28
cfac = 2.232
Remember that we have a phase-in period, so the baseline trend value is 28 at 2006Q4.
Subtracting these two values gives the estimated absolute change of -0.679.



Multiple Choice JSON Ready
Assessment JSON Ready
ITSx_3T2016 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
ITSx_3T2016 wrangle_video already exists. Ignoring.
ITSx_3T2016 wrangle_link_page already exists. Ignoring.
ITSx_3T2016 wrangle_general already exists. Ignoring.
ITSx_3T2016 wrangle_assessments already exists. Ignoring.
IndEdu200x_1T2015 demographic_multiple_choice already exists. Ignoring.
IndEdu200x_1T2015 open_assessment already exists. Ignoring.
IndEdu200x_1T2015 generalized_video_heat already exists. Ignoring.
IndEdu200x_1T2015 generalized_video_axis already exists. Ignoring.
IndEdu200x_1T2015 generalized_demographics already exists. Ignoring.
IndEdu200x_1T2015 forum_posts already exists. Ignoring.
IndEdu200x_1T2015 forum_searches already exists. Ignoring.
IndEdu200x_1T2015 forum_views already exists. Ignoring.
IndEdu200x_1T2015 tower_item already exists. Ignoring.
IndEdu200x_1T2015 tower_engage_dirt already exists. Ignoring.
IndEdu200x_1T2015 course_axis already exists. Ignoring.
IndEdu200x_1T2015 external_link_dirt already exists. Ignoring.
IndEdu200x_1T2015 page_dirt already exists. Ignoring.
Could not parse problem

In which country were you born?	



In which country do you currently reside?	



If you currently live in Canada, what are the first three characters of your postal code?



What is the main language that you speak at home? 	




Multiple Choice JSON Ready
Assessment JSON Ready
IndEdu200x_1T2015 wrangle_overview_engagement already exists. Ignoring.
IndEdu200x_1T2015 wrangle_forum already exists. Ignoring.
IndEdu200x_1T2015 wrangle_video already exists. Ignoring.
IndEdu200x_1T2015 wrangle_link_page already exists. Ignoring.
IndEdu200x_1T2015 wrangle_general already exists. Ignoring.
IndEdu200x_1T2015 wrangle_assessments already exists. Ignoring.
IndEdu200x_1T2017 demographic_multiple_choice already exists. Ignoring.
IndEdu200x_1T2017 open_assessment already exists. Ignoring.
IndEdu200x_1T2017 generalized_video_heat already exists. Ignoring.
IndEdu200x_1T2017 generalized_video_axis already exists. Ignoring.
IndEdu200x_1T2017 generalized_demographics already exists. Ignoring.
IndEdu200x_1T2017 forum_posts already exists. Ignoring.
IndEdu200x_1T2017 forum_searches already exists. Ignoring.
IndEdu200x_1T2017 forum_views already exists. Ignoring.
IndEdu200x_1T2017 tower_item already exists. Ignoring.
IndEdu200x_1T2017 tower_engage_dirt already exists. Ignoring.
IndEdu200x_1T2017 course_axis already exists. Ignoring.
IndEdu200x_1T2017 external_link_dirt already exists. Ignoring.
IndEdu200x_1T2017 page_dirt already exists. Ignoring.
Multiple Choice JSON Ready
Assessment JSON Ready
IndEdu200x_1T2017 wrangle_overview_engagement already exists. Ignoring.
IndEdu200x_1T2017 wrangle_forum already exists. Ignoring.
IndEdu200x_1T2017 wrangle_video already exists. Ignoring.
IndEdu200x_1T2017 wrangle_link_page already exists. Ignoring.
IndEdu200x_1T2017 wrangle_general already exists. Ignoring.
IndEdu200x_1T2017 wrangle_assessments already exists. Ignoring.
IndEdu200x_3T2015 demographic_multiple_choice already exists. Ignoring.
IndEdu200x_3T2015 open_assessment already exists. Ignoring.
IndEdu200x_3T2015 generalized_video_heat already exists. Ignoring.
IndEdu200x_3T2015 generalized_video_axis already exists. Ignoring.
IndEdu200x_3T2015 generalized_demographics already exists. Ignoring.
IndEdu200x_3T2015 forum_posts already exists. Ignoring.
IndEdu200x_3T2015 forum_searches already exists. Ignoring.
IndEdu200x_3T2015 forum_views already exists. Ignoring.
IndEdu200x_3T2015 tower_item already exists. Ignoring.
IndEdu200x_3T2015 tower_engage_dirt already exists. Ignoring.
IndEdu200x_3T2015 course_axis already exists. Ignoring.
IndEdu200x_3T2015 external_link_dirt already exists. Ignoring.
IndEdu200x_3T2015 page_dirt already exists. Ignoring.
Could not parse problem

In which country were you born?	



In which country do you currently reside?	



If you currently live in Canada, what are the first three characters of your postal code?



What is the main language that you speak at home? 	




Multiple Choice JSON Ready
Assessment JSON Ready
IndEdu200x_3T2015 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
IndEdu200x_3T2015 wrangle_video already exists. Ignoring.
IndEdu200x_3T2015 wrangle_link_page already exists. Ignoring.
IndEdu200x_3T2015 wrangle_general already exists. Ignoring.
IndEdu200x_3T2015 wrangle_assessments already exists. Ignoring.
Marketing1x_3T2015 demographic_multiple_choice already exists. Ignoring.
Marketing1x_3T2015 open_assessment already exists. Ignoring.
Requesting query... ok.
Query running...
  Elapsed 12.96 s. Waiting...
  Elapsed 23.42 s. Waiting...
Marketing1x_3T2015 generalized_video_axis already exists. Ignoring.
Marketing1x_3T2015 generalized_demographics already exists. Ignoring.
Marketing1x_3T2015 forum_posts already exists. Ignoring.
Marketing1x_3T2015 forum_searches already exists. Ignoring.
Marketing1x_3T2015 forum_views already exists. Ignoring.
Marketing1x_3T2015 tower_item already exists. Ignoring.
Marketing1x_3T2015 tower_engage_dirt already exists. Ignoring.
Marketing1x_3T2015 course_axis already exists. Ignoring.
Marketing1x_3T2015 external_link_dirt already exists. Ignoring.
Requesting query... ok.
Query running...
  Elapsed 12.85 s. Waiting...
Multiple Choice JSON Ready
Assessment JSON Ready
Marketing1x_3T2015 wrangle_overview_engagement already exists. Ignoring.
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Marketing1x_3T2015 wrangle_link_page already exists. Ignoring.
Marketing1x_3T2015 wrangle_general already exists. Ignoring.
Marketing5501x_2T2015 demographic_multiple_choice already exists. Ignoring.
Marketing5501x_2T2015 open_assessment already exists. Ignoring.
Marketing5501x_2T2015 generalized_video_heat already exists. Ignoring.
Marketing5501x_2T2015 generalized_video_axis already exists. Ignoring.
Marketing5501x_2T2015 generalized_demographics already exists. Ignoring.
Marketing5501x_2T2015 forum_posts already exists. Ignoring.
Marketing5501x_2T2015 forum_searches already exists. Ignoring.
Requesting query... ok.
Query running...
Query done.
Cache hit.

Retrieving results...
Got 10901 rows.

Total time taken 1.88 s.
Finished at 2017-06-30 19:42:56.
Saved to ./../data/Marketing5501x_2T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 46.1 KB

Retrieving results...
Got 420 rows.

Total time taken 0.82 s.
Finished at 2017-06-30 19:42:58.
Saved to ./../data/Marketing5501x_2T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 6.2 MB

Retrieving results...
Got 10983 rows.

Total time taken 2.26 s.
Finished at 2017-06-30 19:43:02.
Saved to ./../data/Marketing5501x_2T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 147.5 KB

Retrieving results...
Got 420 rows.

Total time taken 0.98 s.
Finished at 2017-06-30 19:43:04.
Saved to ./../data/Marketing5501x_2T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 227.5 KB

Retrieving results...
Got 1 rows.

Total time taken 4.14 s.
Finished at 2017-06-30 19:43:10.
Saved to ./../data/Marketing5501x_2T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 132.3 KB

Retrieving results...
Got 479 rows.

Total time taken 5.78 s.
Finished at 2017-06-30 19:43:17.
Saved to ./../data/Marketing5501x_2T2015/page_dirt.csv
Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 9.4 MB

Retrieving results...
  Got page: 1; 25% done. Elapsed 12.18 s.
  Got page: 2; 49% done. Elapsed 17.49 s.
  Got page: 3; 74% done. Elapsed 22.94 s.
  Got page: 4; 99% done. Elapsed 27.33 s.
  Got page: 5; 100% done. Elapsed 28.0 s.
Got 157281 rows.

Total time taken 32.36 s.
Finished at 2017-06-30 19:44:23.
Saved to ./../data/PSYC_1x_3T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 12.85 s. Waiting...
Query done.
Processed: 1.3 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 17.2 s.
Got 9076 rows.

Total time taken 17.43 s.
Finished at 2017-06-30 19:44:44.
Saved to ./../data/PSYC_1x_3T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 12.31 s. Waiting...
  Elapsed 22.69 s. Waiting...
Query done.
Processed: 1.2 GB

Retrieving results...
  Got page: 1; 3% done. Elapsed 32.17 s.
  Got page: 2; 6% done. Elapsed 37.14 s.
  Got page: 3; 9% done. Elapsed 41.66 s.
  Got page: 4; 12% done. Elapsed 52.14 s.
  Got page: 5; 15% done. Elapsed 56.72 s.
  Got page: 6; 18% done. Elapsed 61.38 s.
  Got page: 7; 21% done. Elapsed 65.38 s.
  Got page: 8; 24% done. Elapsed 70.8 s.
  Got page: 9; 27% done. Elapsed 76.4 s.
  Got page: 10; 30% done. Elapsed 81.67 s.
  Got page: 11; 33% done. Elapsed 86.57 s.
  Got page: 12; 36% done. Elapsed 91.58 s.
  Got page: 13; 39% done. Elapsed 97.04 s.
  Got page: 14; 42% done. Elapsed 101.36 s.
  Got page: 15; 45% done. Elapsed 105.72 s.
  Got page: 16; 48% done. Elapsed 113.99 s.
  Got page: 17; 51% done. Elapsed 122.18 s.
  Got page: 18; 54% done. Elapsed 131.46 s.
  Got page: 19; 57% done. Elapsed 138.34 s.
  Got page: 20; 60% done. Elapsed 142.99 s.
  Got page: 21; 63% done. Elapsed 152.38 s.
  Got page: 22; 66% done. Elapsed 158.43 s.
  Got page: 23; 69% done. Elapsed 164.63 s.
  Got page: 24; 72% done. Elapsed 169.1 s.
  Got page: 25; 75% done. Elapsed 173.96 s.
  Got page: 26; 78% done. Elapsed 178.81 s.
  Got page: 27; 81% done. Elapsed 185.22 s.
  Got page: 28; 84% done. Elapsed 190.79 s.
  Got page: 29; 87% done. Elapsed 195.79 s.
  Got page: 30; 90% done. Elapsed 200.37 s.
  Got page: 31; 93% done. Elapsed 206.38 s.
  Got page: 32; 96% done. Elapsed 211.4 s.
  Got page: 33; 99% done. Elapsed 217.25 s.
  Got page: 34; 100% done. Elapsed 221.73 s.
Got 778804 rows.

Requesting query... ok.
Query running...
Query done.
Processed: 1.8 KB

Retrieving results...
Got 24 rows.

Total time taken 1.05 s.
Finished at 2017-06-30 19:49:21.
Saved to ./../data/PSYC_1x_3T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.8 MB

Retrieving results...
Got 6060 rows.

Total time taken 3.78 s.
Finished at 2017-06-30 19:49:26.
Saved to ./../data/PSYC_1x_3T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 964.4 KB

Retrieving results...
Got 1354 rows.

Total time taken 1.94 s.
Finished at 2017-06-30 19:49:30.
Saved to ./../data/PSYC_1x_3T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1004.7 KB

Retrieving results...
Got 239 rows.

Total time taken 1.41 s.
Finished at 2017-06-30 19:49:33.
Saved to ./../data/PSYC_1x_3T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.0 MB

Retrieving results...
Got 8644 rows.

Total time taken 2.33 s.
Finished at 2017-06-30 19:49:36.
Saved to ./../data/PSYC_1x_3T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 56.1 KB

Retrieving results...
Got 548 rows.

Total time taken 0.92 s.
Finished at 2017-06-30 19:49:39.
Saved to ./../data/PSYC_1x_3T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 195.7 MB

Retrieving results...
  Got page: 1; 28% done. Elapsed 11.66 s.
  Got page: 2; 57% done. Elapsed 18.11 s.
  Got page: 3; 85% done. Elapsed 23.37 s.
  Got page: 4; 100% done. Elapsed 26.43 s.
Got 205120 rows.

Total time taken 30.65 s.
Finished at 2017-06-30 19:50:11.
Saved to ./../data/PSYC_1x_3T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 192.1 KB

Retrieving results...
Got 548 rows.

Total time taken 1.22 s.
Finished at 2017-06-30 19:50:15.
Saved to ./../data/PSYC_1x_3T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.1 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 9.66 s.
Got 7159 rows.

Total time taken 9.81 s.
Finished at 2017-06-30 19:50:26.
Saved to ./../data/PSYC_1x_3T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.12 s. Waiting...
  Elapsed 22.61 s. Waiting...
Query done.
Processed: 155.4 MB

Retrieving results...
  Got page: 1; 7% done. Elapsed 31.04 s.
  Got page: 2; 14% done. Elapsed 36.15 s.
  Got page: 3; 21% done. Elapsed 42.36 s.
  Got page: 4; 28% done. Elapsed 48.47 s.
  Got page: 5; 34% done. Elapsed 55.33 s.
  Got page: 6; 41% done. Elapsed 61.67 s.
  Got page: 7; 48% done. Elapsed 67.47 s.
  Got page: 8; 55% done. Elapsed 73.6 s.
  Got page: 9; 62% done. Elapsed 79.72 s.
  Got page: 10; 69% done. Elapsed 86.51 s.
  Got page: 11; 76% done. Elapsed 93.01 s.
  Got page: 12; 82% done. Elapsed 98.45 s.
  Got page: 13; 89% done. Elapsed 104.61 s.
  Got page: 14; 96% done. Elapsed 111.74 s.
  Got page: 15; 100% done. Elapsed 116.58 s.
Got 765216 rows.

Total time taken 132.68 s.
Finished at 2017-06-30 19:52:41.
Saved to ./../data/PSYC_1x_3T2016/page_dirt.csv
Could not parse problem


Please provide a 1-2 sentence reflection on your performance on the free-response portion of the exam: What did you find particularly difficult? Where do you see room for improvement?



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 5.2 MB

Retrieving results...
  Got page: 1; 46% done. Elapsed 10.21 s.
  Got page: 2; 91% done. Elapsed 16.32 s.
  Got page: 3; 100% done. Elapsed 17.69 s.
Got 85147 rows.

Total time taken 20.96 s.
Finished at 2017-06-30 19:59:36.
Saved to ./../data/PSYC_2x_3T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 15.97 s. Waiting...
Query done.
Processed: 711.1 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 21.9 s.
Got 4516 rows.

Total time taken 21.99 s.
Finished at 2017-06-30 20:00:00.
Saved to ./../data/PSYC_2x_3T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 13.04 s. Waiting...
  Elapsed 23.26 s. Waiting...
Query done.
Processed: 673.3 MB

Retrieving results...
  Got page: 1; 5% done. Elapsed 28.3 s.
  Got page: 2; 11% done. Elapsed 33.67 s.
  Got page: 3; 16% done. Elapsed 38.17 s.
  Got page: 4; 22% done. Elapsed 43.29 s.
  Got page: 5; 27% done. Elapsed 48.5 s.
  Got page: 6; 32% done. Elapsed 54.13 s.
  Got page: 7; 38% done. Elapsed 63.65 s.
  Got page: 8; 43% done. Elapsed 68.19 s.
  Got page: 9; 49% done. Elapsed 73.54 s.
  Got page: 10; 54% done. Elapsed 79.36 s.
  Got page: 11; 59% done. Elapsed 83.92 s.
  Got page: 12; 65% done. Elapsed 88.38 s.
  Got page: 13; 70% done. Elapsed 93.39 s.
  Got page: 14; 75% done. Elapsed 97.92 s.
  Got page: 15; 81% done. Elapsed 103.52 s.
  Got page: 16; 86% done. Elapsed 109.5 s.
  Got page: 17; 92% done. Elapsed 114.52 s.
  Got page: 18; 97% done. Elapsed 119.99 s.
  Got page: 19; 100% done. Elapsed 122.99 s.
Got 432772 rows.

Total time taken 139.56 s.
Finished at 2017-06-30 20:02:21.
Saved to ./../data/PSYC_2x_3T2016/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 4.2 KB

Retrieving results...
Got 43 rows.

Total time taken 0.77 s.
Finished at 2017-06-30 20:02:30.
Saved to ./../data/PSYC_2x_3T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 839.4 KB

Retrieving results...
Got 2131 rows.

Total time taken 2.28 s.
Finished at 2017-06-30 20:02:33.
Saved to ./../data/PSYC_2x_3T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 329.5 KB

Retrieving results...
Got 246 rows.

Total time taken 1.13 s.
Finished at 2017-06-30 20:02:36.
Saved to ./../data/PSYC_2x_3T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 366.6 KB

Retrieving results...
Got 31 rows.

Total time taken 1.53 s.
Finished at 2017-06-30 20:02:39.
Saved to ./../data/PSYC_2x_3T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 645.0 KB

Retrieving results...
Got 1564 rows.

Total time taken 1.58 s.
Finished at 2017-06-30 20:02:42.
Saved to ./../data/PSYC_2x_3T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 92.3 KB

Retrieving results...
Got 881 rows.

Total time taken 0.95 s.
Finished at 2017-06-30 20:02:44.
Saved to ./../data/PSYC_2x_3T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 59.9 MB

Retrieving results...
  Got page: 1; 53% done. Elapsed 9.89 s.
  Got page: 2; 100% done. Elapsed 15.56 s.
Got 110266 rows.

Total time taken 16.8 s.
Finished at 2017-06-30 20:03:02.
Saved to ./../data/PSYC_2x_3T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 311.5 KB

Retrieving results...
Got 881 rows.

Total time taken 1.49 s.
Finished at 2017-06-30 20:03:06.
Saved to ./../data/PSYC_2x_3T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 581.2 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 11.31 s.
Got 1956 rows.

Total time taken 11.34 s.
Finished at 2017-06-30 20:03:19.
Saved to ./../data/PSYC_2x_3T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.03 s. Waiting...
Query done.
Processed: 78.8 MB

Retrieving results...
  Got page: 1; 13% done. Elapsed 20.62 s.
  Got page: 2; 26% done. Elapsed 26.67 s.
  Got page: 3; 39% done. Elapsed 32.93 s.
  Got page: 4; 52% done. Elapsed 38.97 s.
  Got page: 5; 65% done. Elapsed 44.81 s.
  Got page: 6; 78% done. Elapsed 50.63 s.
  Got page: 7; 92% done. Elapsed 56.05 s.
  Got page: 8; 100% done. Elapsed 60.29 s.
Got 401448 rows.

Total time taken 69.12 s.
Finished at 2017-06-30 20:04:29.
Saved to ./../data/PSYC_2x_3T2016/page_dirt.csv
Could not parse problem


  Sally was taking careful and well drawn notes during this video lecture on the neuron.  She drew this great picture of a neuron.  But she forgot to label the parts. Drag each of the labels in the scrollbar into the location where it belongs on her notes.
  









correct_answer = {
        '1':      [[135, 110], 60],
        '2':      [[310, 115], 60],
        '3':      [[380, 300], 60],
        '4':     [[515, 300], 60],
        '5':      [[520, 375], 60]}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Acronyms
Drag each of the terms in the slider into the box with the appropriate acronym.  Multiple terms can go in one box.









correct_answer = {
        '1': [[400, 160], 120],
        '2': [[120, 160], 120],
        '3': [[640, 160], 120],
        '4': [[400, 160], 120],
        '5': [[640, 160], 120],
        '6': [[120, 160], 120]}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Drag each of the terms in the slider next to the appropriate colored area of the graph of an action potential.






correct_answer = {
        '1': [[335, 255], 120],
        '2': [[480, 455], 120],
        '3': [[265, 240], 120]}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Behnaz was taking careful and well drawn notes during this video.  She drew this great picture of the layout of the nervous system (notice that the nervous system is a system of '2s'). But she forgot to label the boxes. Drag each of the labels in the scrollbar into the box where it belongs.














correct_answer = {
        '1':      [[290, 200], 60],
        '2':      [[125, 175], 60],
        '3':      [[125, 260], 60],
        '4':     [[290, 30], 60],
      '4':     [[290, 110], 60],
        '5':      [[290, 275], 60],
      	'6':      [[290, 110], 60],
      '6':      [[290, 30], 60],
    	'7':      [[440, 250], 60],
      '8':      [[440, 300], 60],
      '9':      [[650, 245], 60],
      '9':      [[650, 300], 60],
      '10':      [[650, 245], 60],
      '10':      [[650, 300], 60]
      }
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Hermione was taking careful and well drawn notes during this video.  She drew this great picture of the brain.  But she forgot to label the lobes of the cerebral cortex and the two visible fissures. Drag each of the labels in the scrollbar to its correct position next to the end of the arrow that points to the appropriate anatomical location.










correct_answer = {
        '1':      [[290, 60], 60],
        '2':      [[280, 330], 60],
        '3':      [[140, 160], 60],
        '4':     [[505, 270], 60],
        '5':      [[470, 110], 60],
      '6':      [[370, 70], 60]
      }
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Please provide a 1-2 sentence reflection on your performance on the free-response portion of the exam: What did you find particularly difficult? Where do you see room for improvement?



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 3.1 MB

Retrieving results...
  Got page: 1; 76% done. Elapsed 8.51 s.
  Got page: 2; 100% done. Elapsed 10.45 s.
Got 51020 rows.

Total time taken 11.59 s.
Finished at 2017-06-30 20:08:48.
Saved to ./../data/PSYC_3x_3T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 13.55 s. Waiting...
Query done.
Processed: 320.7 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 14.7 s.
Got 2003 rows.

Total time taken 14.74 s.
Finished at 2017-06-30 20:09:05.
Saved to ./../data/PSYC_3x_3T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 12.47 s. Waiting...
Query done.
Processed: 304.7 MB

Retrieving results...
  Got page: 1; 14% done. Elapsed 21.8 s.
  Got page: 2; 28% done. Elapsed 29.7 s.
  Got page: 3; 42% done. Elapsed 34.36 s.
  Got page: 4; 56% done. Elapsed 39.17 s.
  Got page: 5; 70% done. Elapsed 44.31 s.
  Got page: 6; 85% done. Elapsed 48.71 s.
  Got page: 7; 99% done. Elapsed 52.83 s.
  Got page: 8; 100% done. Elapsed 53.64 s.
Got 165622 rows.

Total time taken 59.37 s.
Finished at 2017-06-30 20:10:05.
Saved to ./../data/PSYC_3x_3T2016/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.5 KB

Retrieving results...
Got 21 rows.

Total time taken 0.94 s.
Finished at 2017-06-30 20:10:10.
Saved to ./../data/PSYC_3x_3T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 774.3 KB

Retrieving results...
Got 1792 rows.

Total time taken 1.43 s.
Finished at 2017-06-30 20:10:13.
Saved to ./../data/PSYC_3x_3T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 260.9 KB

Retrieving results...
Got 143 rows.

Total time taken 2.62 s.
Finished at 2017-06-30 20:10:17.
Saved to ./../data/PSYC_3x_3T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 305.7 KB

Retrieving results...
Got 14 rows.

Total time taken 2.97 s.
Finished at 2017-06-30 20:10:21.
Saved to ./../data/PSYC_3x_3T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 481.2 KB

Retrieving results...
Got 559 rows.

Total time taken 1.28 s.
Finished at 2017-06-30 20:10:24.
Saved to ./../data/PSYC_3x_3T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 63.0 KB

Retrieving results...
Got 611 rows.

Total time taken 0.83 s.
Finished at 2017-06-30 20:10:26.
Saved to ./../data/PSYC_3x_3T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 37.4 MB

Retrieving results...
  Got page: 1; 91% done. Elapsed 8.99 s.
  Got page: 2; 100% done. Elapsed 9.7 s.
Got 63901 rows.

Total time taken 10.43 s.
Finished at 2017-06-30 20:10:38.
Saved to ./../data/PSYC_3x_3T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 215.5 KB

Retrieving results...
Got 611 rows.

Total time taken 0.9 s.
Finished at 2017-06-30 20:10:40.
Saved to ./../data/PSYC_3x_3T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 277.5 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 9.31 s.
Got 1231 rows.

Total time taken 9.32 s.
Finished at 2017-06-30 20:10:51.
Saved to ./../data/PSYC_3x_3T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.28 s. Waiting...
Query done.
Processed: 32.0 MB

Retrieving results...
  Got page: 1; 32% done. Elapsed 18.84 s.
  Got page: 2; 64% done. Elapsed 25.04 s.
  Got page: 3; 95% done. Elapsed 30.77 s.
  Got page: 4; 100% done. Elapsed 32.21 s.
Got 165999 rows.

Total time taken 36.4 s.
Finished at 2017-06-30 20:11:29.
Saved to ./../data/PSYC_3x_3T2016/page_dirt.csv
Could not parse problem


Please provide a 1-2 sentence reflection on your performance on the free-response portion of the exam: What did you find particularly difficult? Where do you see room for improvement?



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 3.5 MB

Retrieving results...
  Got page: 1; 69% done. Elapsed 11.34 s.
  Got page: 2; 100% done. Elapsed 14.44 s.
Got 56651 rows.

Total time taken 15.71 s.
Finished at 2017-06-30 20:13:51.
Saved to ./../data/PSYC_4x_1T2017/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
Query done.
Processed: 251.5 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 12.28 s.
Got 1446 rows.

Total time taken 12.32 s.
Finished at 2017-06-30 20:14:05.
Saved to ./../data/PSYC_4x_1T2017/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 12.77 s. Waiting...
Query done.
Processed: 238.4 MB

Retrieving results...
  Got page: 1; 18% done. Elapsed 23.9 s.
  Got page: 2; 35% done. Elapsed 29.01 s.
  Got page: 3; 53% done. Elapsed 33.3 s.
  Got page: 4; 70% done. Elapsed 37.86 s.
  Got page: 5; 88% done. Elapsed 43.67 s.
  Got page: 6; 100% done. Elapsed 47.32 s.
Got 132851 rows.

Total time taken 60.08 s.
Finished at 2017-06-30 20:15:06.
Saved to ./../data/PSYC_4x_1T2017/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.4 KB

Retrieving results...
Got 45 rows.

Total time taken 0.78 s.
Finished at 2017-06-30 20:15:13.
Saved to ./../data/PSYC_4x_1T2017/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 719.8 KB

Retrieving results...
Got 1015 rows.

Total time taken 1.41 s.
Finished at 2017-06-30 20:15:16.
Saved to ./../data/PSYC_4x_1T2017/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 302.2 KB

Retrieving results...
Got 249 rows.

Total time taken 1.89 s.
Finished at 2017-06-30 20:15:21.
Saved to ./../data/PSYC_4x_1T2017/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 264.1 KB

Retrieving results...
Got 2 rows.

Total time taken 1.56 s.
Finished at 2017-06-30 20:15:25.
Saved to ./../data/PSYC_4x_1T2017/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 389.5 KB

Retrieving results...
Got 240 rows.

Total time taken 1.42 s.
Finished at 2017-06-30 20:15:29.
Saved to ./../data/PSYC_4x_1T2017/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 102.0 KB

Retrieving results...
Got 968 rows.

Total time taken 0.99 s.
Finished at 2017-06-30 20:15:33.
Saved to ./../data/PSYC_4x_1T2017/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 43.1 MB

Retrieving results...
  Got page: 1; 81% done. Elapsed 10.92 s.
  Got page: 2; 100% done. Elapsed 13.17 s.
Got 71954 rows.

Total time taken 16.6 s.
Finished at 2017-06-30 20:15:52.
Saved to ./../data/PSYC_4x_1T2017/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 342.1 KB

Retrieving results...
Got 968 rows.

Total time taken 1.54 s.
Finished at 2017-06-30 20:15:59.
Saved to ./../data/PSYC_4x_1T2017/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 166.1 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 9.42 s.
Got 385 rows.

Total time taken 9.44 s.
Finished at 2017-06-30 20:16:12.
Saved to ./../data/PSYC_4x_1T2017/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.52 s. Waiting...
Query done.
Processed: 19.7 MB

Retrieving results...
  Got page: 1; 52% done. Elapsed 18.69 s.
  Got page: 2; 100% done. Elapsed 23.63 s.
Got 101200 rows.

Total time taken 25.68 s.
Finished at 2017-06-30 20:16:40.
Saved to ./../data/PSYC_4x_1T2017/page_dirt.csv
Could not parse problem


Please provide a 1-2 sentence reflection on your performance on the free-response portion of the exam: What did you find particularly difficult? Where do you see room for improvement?



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 1.6 MB

Retrieving results...
Got 25073 rows.

Total time taken 7.33 s.
Finished at 2017-06-30 20:18:15.
Saved to ./../data/PSYC_5x_1T2017/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
Query done.
Processed: 165.6 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 11.65 s.
Got 1043 rows.

Total time taken 11.68 s.
Finished at 2017-06-30 20:18:29.
Saved to ./../data/PSYC_5x_1T2017/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 12.81 s. Waiting...
Query done.
Processed: 157.8 MB

Retrieving results...
  Got page: 1; 33% done. Elapsed 21.52 s.
  Got page: 2; 66% done. Elapsed 25.62 s.
  Got page: 3; 98% done. Elapsed 29.94 s.
  Got page: 4; 100% done. Elapsed 30.53 s.
Got 71201 rows.

Total time taken 33.0 s.
Finished at 2017-06-30 20:19:03.
Saved to ./../data/PSYC_5x_1T2017/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.3 KB

Retrieving results...
Got 25 rows.

Total time taken 0.84 s.
Finished at 2017-06-30 20:19:06.
Saved to ./../data/PSYC_5x_1T2017/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 518.1 KB

Retrieving results...
Got 703 rows.

Total time taken 1.3 s.
Finished at 2017-06-30 20:19:08.
Saved to ./../data/PSYC_5x_1T2017/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 185.7 KB

Retrieving results...
Got 104 rows.

Total time taken 1.03 s.
Finished at 2017-06-30 20:19:10.
Saved to ./../data/PSYC_5x_1T2017/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 190.5 KB

Retrieving results...
Got 1 rows.

Total time taken 1.37 s.
Finished at 2017-06-30 20:19:13.
Saved to ./../data/PSYC_5x_1T2017/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 277.1 KB

Retrieving results...
Got 168 rows.

Total time taken 2.52 s.
Finished at 2017-06-30 20:19:17.
Saved to ./../data/PSYC_5x_1T2017/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 72.1 KB

Retrieving results...
Got 695 rows.

Total time taken 0.92 s.
Finished at 2017-06-30 20:19:19.
Saved to ./../data/PSYC_5x_1T2017/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 19.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 7.08 s.
Got 31046 rows.

Total time taken 7.51 s.
Finished at 2017-06-30 20:19:28.
Saved to ./../data/PSYC_5x_1T2017/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 245.2 KB

Retrieving results...
Got 695 rows.

Total time taken 1.26 s.
Finished at 2017-06-30 20:19:30.
Saved to ./../data/PSYC_5x_1T2017/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 108.2 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 8.03 s.
Got 174 rows.

Total time taken 8.03 s.
Finished at 2017-06-30 20:19:40.
Saved to ./../data/PSYC_5x_1T2017/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.16 s. Waiting...
Query done.
Processed: 12.7 MB

Retrieving results...
  Got page: 1; 97% done. Elapsed 17.26 s.
  Got page: 2; 100% done. Elapsed 17.77 s.
Got 54267 rows.

Total time taken 18.64 s.
Finished at 2017-06-30 20:20:00.
Saved to ./../data/PSYC_5x_1T2017/page_dirt.csv
Could not parse problem


Please provide a 1-2 sentence reflection on your performance on the free-response portion of the exam: What did you find particularly difficult? Where do you see room for improvement?



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 292.2 KB

Retrieving results...
Got 4027 rows.

Total time taken 2.26 s.
Finished at 2017-06-30 20:21:08.
Saved to ./../data/PSYC_6x_1T2017/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 12.6 s. Waiting...
Query done.
Processed: 31.9 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 13.07 s.
Got 64 rows.

Total time taken 13.08 s.
Finished at 2017-06-30 20:21:23.
Saved to ./../data/PSYC_6x_1T2017/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 13.03 s. Waiting...
Query done.
Processed: 30.7 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 19.12 s.
Got 15070 rows.

Total time taken 19.65 s.
Finished at 2017-06-30 20:21:44.
Saved to ./../data/PSYC_6x_1T2017/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 677.0 B

Retrieving results...
Got 9 rows.

Total time taken 0.9 s.
Finished at 2017-06-30 20:21:47.
Saved to ./../data/PSYC_6x_1T2017/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 303.3 KB

Retrieving results...
Got 527 rows.

Total time taken 1.01 s.
Finished at 2017-06-30 20:21:49.
Saved to ./../data/PSYC_6x_1T2017/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 102.6 KB

Retrieving results...
Got 48 rows.

Total time taken 1.08 s.
Finished at 2017-06-30 20:21:51.
Saved to ./../data/PSYC_6x_1T2017/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 114.6 KB

Retrieving results...
Got 0 rows.

Total time taken 1.04 s.
Finished at 2017-06-30 20:21:53.
Saved to ./../data/PSYC_6x_1T2017/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 174.0 KB

Retrieving results...
Got 144 rows.

Total time taken 1.02 s.
Finished at 2017-06-30 20:21:56.
Saved to ./../data/PSYC_6x_1T2017/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 31.3 KB

Retrieving results...
Got 335 rows.

Total time taken 0.7 s.
Finished at 2017-06-30 20:21:58.
Saved to ./../data/PSYC_6x_1T2017/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 6.2 MB

Retrieving results...
Got 5937 rows.

Total time taken 1.69 s.
Finished at 2017-06-30 20:22:01.
Saved to ./../data/PSYC_6x_1T2017/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 116.2 KB

Retrieving results...
Got 335 rows.

Total time taken 0.86 s.
Finished at 2017-06-30 20:22:03.
Saved to ./../data/PSYC_6x_1T2017/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 25.0 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 10.16 s.
Got 106 rows.

Total time taken 10.16 s.
Finished at 2017-06-30 20:22:15.
Saved to ./../data/PSYC_6x_1T2017/external_link_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 12.23 s.
Got 14493 rows.

Total time taken 12.48 s.
Finished at 2017-06-30 20:22:29.
Saved to ./../data/PSYC_6x_1T2017/page_dirt.csv
Could not parse problem


Please provide a 1-2 sentence reflection on your performance on the free-response portion of the exam: What did you find particularly difficult? Where do you see room for improvement?



Could not parse problem


Please provide a 1-2 sentence reflection on your performance on the free-response portion of the exam: What did you find particularly difficult? Where do you see room for improvement?



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 7.5 MB

Retrieving results...
Got 7525 rows.

Total time taken 6.3 s.
Finished at 2017-06-30 20:23:15.
Saved to ./../data/Phot1x_1T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 12.55 s. Waiting...
Query done.
Processed: 397.8 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 15.64 s.
Got 234 rows.

Total time taken 15.65 s.
Finished at 2017-06-30 20:23:32.
Saved to ./../data/Phot1x_1T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 12.65 s. Waiting...
  Elapsed 23.07 s. Waiting...
Query done.
Processed: 363.7 MB

Retrieving results...
  Got page: 1; 6% done. Elapsed 37.2 s.
  Got page: 2; 11% done. Elapsed 42.1 s.
  Got page: 3; 17% done. Elapsed 48.53 s.
  Got page: 4; 23% done. Elapsed 54.63 s.
  Got page: 5; 28% done. Elapsed 59.16 s.
  Got page: 6; 34% done. Elapsed 64.11 s.
  Got page: 7; 40% done. Elapsed 69.91 s.
  Got page: 8; 45% done. Elapsed 74.56 s.
  Got page: 9; 51% done. Elapsed 79.67 s.
  Got page: 10; 57% done. Elapsed 85.79 s.
  Got page: 11; 62% done. Elapsed 90.44 s.
  Got page: 12; 68% done. Elapsed 95.52 s.
  Got page: 13; 74% done. Elapsed 101.52 s.
  Got page: 14; 79% done. Elapsed 106.73 s.
  Got page: 15; 85% done. Elapsed 111.57 s.
  Got page: 16; 91% done. Elapsed 116.62 s.
  Got page: 17; 96% done. Elapsed 123.26 s.
  Got page: 18; 100% done. Elapsed 127.49 s.
Got 412226 rows.

Total time taken 142.92 s.
Finished at 2017-06-30 20:25:57.
Saved to ./../data/Phot1x_1T2016/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 9.9 KB

Retrieving results...
Got 147 rows.

Total time taken 0.76 s.
Finished at 2017-06-30 20:26:06.
Saved to ./../data/Phot1x_1T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 20.1 KB

Retrieving results...
Got 129 rows.

Total time taken 0.88 s.
Finished at 2017-06-30 20:26:08.
Saved to ./../data/Phot1x_1T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 700.5 KB

Retrieving results...
Got 1708 rows.

Total time taken 1.55 s.
Finished at 2017-06-30 20:26:11.
Saved to ./../data/Phot1x_1T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 761.4 KB

Retrieving results...
Got 474 rows.

Total time taken 1.05 s.
Finished at 2017-06-30 20:26:13.
Saved to ./../data/Phot1x_1T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.4 MB

Retrieving results...
Got 22253 rows.

Total time taken 3.36 s.
Finished at 2017-06-30 20:26:18.
Saved to ./../data/Phot1x_1T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 81.8 KB

Retrieving results...
Got 784 rows.

Total time taken 0.91 s.
Finished at 2017-06-30 20:26:20.
Saved to ./../data/Phot1x_1T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 102.1 MB

Retrieving results...
Got 12949 rows.

Total time taken 3.4 s.
Finished at 2017-06-30 20:26:25.
Saved to ./../data/Phot1x_1T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 259.8 KB

Retrieving results...
Got 784 rows.

Total time taken 0.9 s.
Finished at 2017-06-30 20:26:27.
Saved to ./../data/Phot1x_1T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 204.5 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 10.01 s.
Got 659 rows.

Total time taken 10.02 s.
Finished at 2017-06-30 20:26:39.
Saved to ./../data/Phot1x_1T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.44 s. Waiting...
Query done.
Processed: 92.1 MB

Retrieving results...
  Got page: 1; 11% done. Elapsed 24.34 s.
  Got page: 2; 21% done. Elapsed 30.16 s.
  Got page: 3; 31% done. Elapsed 35.95 s.
  Got page: 4; 41% done. Elapsed 40.2 s.
  Got page: 5; 51% done. Elapsed 46.27 s.
  Got page: 6; 61% done. Elapsed 51.37 s.
  Got page: 7; 72% done. Elapsed 56.74 s.
  Got page: 8; 83% done. Elapsed 64.84 s.
  Got page: 9; 93% done. Elapsed 71.69 s.
  Got page: 10; 100% done. Elapsed 75.08 s.
Got 476397 rows.

Total time taken 83.45 s.
Finished at 2017-06-30 20:28:03.
Saved to ./../data/Phot1x_1T2016/page_dirt.csv
Could not parse problem


Click "run" to execute the code.  



      %%    
      
      



a=1
b=2
c=a+b
        
% Practice figures:        
x=1:0.1:10;
figure; plot (x, sin(x)); title ('The First figure');
figure; plot (x, exp(x)); title ('The Second figure');
        
      



%%     
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem




The thickness of the silicon layer in the SOI wafer is a very important parameter when designing silicon photonic components.  
What is the most common silicon thickness used by the silicon photonic foundries? [units: nm]





Explanation
220 nm. We will discuss and simulate the reason behind this choice next.



Could not parse problem




Consider a silicon photonic chip operating over a wide range of temperatures (e.g., in a data centre), and operating over a wide range of wavelengths (e.g., using wavelength division multiplexing, WDM). The waveguide consists of a Si core, and SiO2 cladding; assume that the light is travelling 100% in silicon (we will later see this is not the case). 
If the wavelength changes by 100 nm, by what percentage (absolute value) will the index change? [Answer 0-100, Units: %, Accuracy +/- 0.1]




If the temperature changes by 100 C, by what percentage will the index change? [Answer 0-100, Units: %, Accuracy +/- 0.1]






Explanation
For a 100 nm change in wavelength: abs ( 100 nm * (-7.6e-5 /nm)  / 3.47 * 100 ) = 0.21 %
For a 100 C change in temperature, but only considering dn_Si / dT: abs ( 100 nm * ( 1.87e-4 /K )  / 3.47 * 100 ) = 0.54 %.   



Use the parameters provided on slide #12. 


Could not parse problem




 Which of the following is the largest in a dielectric waveguide?





Explanation
 A pulse of light, and information, travels at the group velocity, which is slower than the speed of light in the material (phase velocity).



Could not parse problem


You can use this MATLAB window to perform the calculations necessary for the problems.
  

      Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.


  



      %%    
      
      


        
format long;  % display many significant digits; optional

delta_T = 10;
Thermal_coefficient = 0.01;  % replace with correct value
delta_n = Thermal_coefficient * delta_T
        
      



        %%
   
        
      



Could not parse problem




Consider a Si/SiO2 waveguide, and assume that the light is travelling as follows: 90% in silicon, and 10% in silicon dioxide.  Assume the mode profile does not change in the following questions:
Q1: If the wavelength increases by 10 nm, by how much will the effective index change?




Q2: If the temperature increases by 10 C, by how much will the effective index change?




Q3: Let's find out if we can ignore the temperature dependance of SiO2 in our models.  Repeat the above Q2 calculation, this time assuming a constant SiO2 material model.  How much error would be introduced in the change in effective index versus temperature, if a constant SiO2 material model was used? (answer in %) 
 \( \% error = \frac{\text{Correct}-\text{Incorrect}}{\text{Correct}} \cdot 100 \)






Explanation
For a 10 nm change in wavelength: 10 nm * ( 0.9 * -7.6e-5 /nm + 0.1 * -1.2e-5 /nm ) = -6.96e-4
For a 10 C change in temperature: 10 K * ( 0.9 * 1.87e-4 /K + 0.1 * 8.5e-6 /K ) = 1.6915e-3
For a 10 C change in temperature, but only considering dn_Si / dT, 10 nm * ( 0.9 * 1.87e-4 /K ) = 1.683e-4.  Hence, the error is: 
(1.6915-1.683) / (1.6915) = 0.00502, or 0.5%



For the effective index, in Q1-3, approximate this as a weighted average of the refractive index values in each medium. 
For Q3: Modify your equation in Q2 to assume that there is no temperature dependence in the SiO2.  Note that 10% of the light is still in the SiO2, and 90% is in silicon. 
For Q3, the answer is a number.  Don't include the % symbol in the answer. 


Could not parse problem




Consider a silicon photonic slab waveguide consisting of a thin layer of silicon (with index 3.47), with thickness t, surrounded by an infinite amount of silicon dioxide (with index of 1.44).
Consider the fundamental mode (TE0).  For a thickness t=220 nm, the effective index is 2.8. 
What value does the effective index approach as t gets close to 0 nm (very thin slab waveguide)? [Ans +/- 0.1]




What value does the effective index approach as t approaches infinity (very thick slab waveguide)? [Ans +/- 0.1]






Explanation
In a very thin slab waveguide, the light is mostly in the silicon dioxide, hence the index approaches 1.44.
In a very thick slab waveguide, the light is mostly in the silicon, hence the index approaches 3.47.



Could not parse problem




In this exercise, we wish to understand why the wafers we are using have a thickness of 220 nm. 
 You can use the analytic method with the script provided below (in MATLAB) to answer this question (Note: you do need to understand the details of this script, just use it as a tool).  
  
You can download the script (wg_1D_slab.m). 
What is the maximum Si thickness before the slab waveguide supports more than one TE mode? Enter the thickness [Units: nm, accuracy +/-5 nm]:






Explanation




Use the Matlab code below.  You can do this problem by trial and error, with your own iterations.  
Change the thickness of the waveguide -- the default is 0.22e-6 m.  You will see that nTE = xxxx: namely it supports a single mode.  Try increasing it, say to 0.5e-6.  You will see that nTE = xxxx, xxxx, xxx: namely it supports multiple (3) modes.  Find the value where the 2nd mode just disappears.  
You could also make a script with a "for" loop, and plot the number of modes versus the thickness.  The number of modes would be found by the command length(nTE).  


Could not parse problem





Use the following Matlab code to answer the question on slab waveguides.
  
To change the thickness, change the number 220e-9 in the following line: 



thickness=220e-9;     %%% thickness of the silicon layer, [units: m]
  



The default is to plot the E-field for the TE polarization. You may also view the field profile for the TM polarization.
  

Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% MATLAB Script to solve for the modes of the slab waveguide,
% calculate the effective indices
% plot the E-field profile for all the modes
% the user provides:
%  - thickness of the silicon layer
%  - desired polarization to plot

function main
	thickness=220e-9;     %%% thickness of the silicon layer, [units: m]
	polarization = 'TM';  %%% polarization, 'TE' or 'TM'

	[x, TE_E, TE_H, TM_E, TM_H, nTE, nTM] = wg_1D_mode_profile ...
		(1.55e-6, thickness, 1.444, 3.47, 1.444, 100, 3);

	figure;
	g=rectangle('Position',[-thickness*1e9/2,-1,thickness*1e9,2],'FaceColor',[.8 .8 .8 0.2]); hold all;
	if polarization=='TE'       
		plot (x*1e9, TE_E/max(max(TE_E)), 'LineWidth',3);
		title('TE polarized mode(s)');
	else
		plot (x*1e9, TM_E/max(max(TM_E)), 'LineWidth',3);
		title('TM polarized mode(s)');
	end
	xlabel('Position - perpendicular to wafer [nm]');
	ylabel('E-Field Amplitude');
	ax=gca;
	set(ax, 'FontSize',15);
%	ax.XTick = [floor(min(x)*1e9/100)*100:200:floor(max(x)*1e9/100)*100];
	axis tight;
	grid on; box on;

	disp(['Effective index value(s) of the TE mode(s):  ' sprintf('%g  ',nTE)])
	disp(['Effective index value(s) of the TM mode(s):  ' sprintf('%g  ',nTM)])


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
% wg_1D_mode_profile.m - Calculate the 1D mode profile of a slab waveguide
% by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3.2
% - function returns mode profiles for TE and TM modes (E, H components)
% usage, e.g.:
%  [x, TE_E, TE_H, TM_E, TM_H, nTE, nTM] = wg_1D_mode_profile (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444, 100, 4)
%  plot (x, TE_E); 
%  plot (x, TM_E); 
function [x, TE_E, TE_H, TM_E, TM_H, nTE, nTM]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
	x1=linspace( -M*t, -t/2, pts); x2=linspace( -t/2, t/2, pts); 
	x3=linspace( t/2, M*t, pts); x=[x1 x2 x3];
	nx=[n1*ones(pts,1); n2*ones(pts,1); n3*ones(pts,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% wg_1D_analytic.m - Analytic solution of a slab waveguide
% by Lumerical Solutions, http://www.lumerical.com/mode_online_help/slab_wg.m
% modified by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3
% finds the TE and TM effective indices of a 3-layer slab waveguide

% usage:
%  - get effective indices for supported modes:
%  [nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
%  - optional, for plotting: TEparam,TMparam: h, q, p parameters of the mode.

function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);     
      
      



        %%
   
        
      



Could not parse problem


Use the following Matlab code to answer the question on slab waveguides.
  
To change the thickness, change the number 0.22e-6 in the following line: 



[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
  



Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_analytic.m - Analytic solution of a slab waveguide
% by Lumerical Solutions, http://www.lumerical.com/mode_online_help/slab_wg.m
% modified by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3
% finds the TE and TM effective indices of a 3-layer slab waveguide

% usage:
%  - get effective indices for supported modes:
%  [nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
%  - optional, for plotting: TEparam,TMparam: h, q, p parameters of the mode.


function main
	[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
      



        %%
   
        
      



Could not parse problem




 We know that some of the light is travelling outside the waveguide.  This is an important concept to understand as it has several implications: 
  It leads to the concept of waveguide dispersion, and has a huge impact on the group index, \( n_g \) The field outside the waveguide can be used to make evanescent field sensors, e.g., bio applications.  (Note - replace SiO2 with air, water, etc, for biosensors) 
  Hence, we wish to study how far the fields extend above the waveguides.  We consider the two polarizations (TE, TM) guided by the 220 nm slab waveguide. 
          Question - For the TE polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point (of the value at the interface):




Question - For the TM polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point:






Explanation
TE Polarization:

Measure the field at the interface.
Find the 1/e point.  If the field is 0.66 at the interface, take 0.66 / e = 0.66 / 2.71 = 0.243.  Find the x value for this point, which is approximately 200 nm.
Measure the distance from the interface: 200-110 = 90 nm.

TM Polarization:

The MATLAB code needs to be motified to plot TM_E (the E-field for the TM polarization) instead of TE_E (the E-field for the TM polarization)
Measure the field at the interface.
find the 1/e point.  if the field is 0.77 at the interface, take 0.77 / e = 0.28.  Find the x value for this point, which is approximately 280 nm.
measure the distance from the interface: 280-110 = 170 nm.




Could not parse problem

You can run the MATLAB code provided in the web browser below.  Or, you can download the code and run it directly on your computer (wg_1D_mode_profile_main.m)
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_mode_profile.m - Calculate the 1D mode profile of a slab waveguide
% by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3.2
% - function returns mode profiles for TE and TM modes (E, H components)
% usage, e.g.:
%  [x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444, 100, 4)
%  plot (x, TE_E); 
%  plot (x, TM_E); 



function main
	thickness=0.22e-6;  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	[x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile ...
		(1.55e-6, thickness, 1.444, 3.47, 1.444, 100, 3);
	g=rectangle('Position',[-thickness*1e9/2,0,thickness*1e9,1],'FaceColor',[.8 .8 .8 0.2]); hold all;
	plot (x*1e9, TE_E/max(max(TE_E)), 'LineWidth',3);
	xlabel('Position [nm]');
	ylabel('Field Amplitude');
	ax=gca;
	set(ax, 'FontSize',15);
	ax.XTick = [floor(min(x)*1e9/100)*100:200:floor(max(x)*1e9/100)*100];
	axis tight;
	grid on; box on;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
	x1=linspace( -M*t, -t/2, pts); x2=linspace( -t/2, t/2, pts); 
	x3=linspace( t/2, M*t, pts); x=[x1 x2 x3];
	nx=[n1*ones(pts,1); n2*ones(pts,1); n3*ones(pts,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);     
      



        %%
   
        
      



Could not parse problem




Simulation results for the strip waveguide, fundamental TE polarization, show that the effective index decreases with increasing wavelength.
What is the main reason that the waveguide's effective index decreases for a longer wavelength?





Explanation
Both Material and Waveguide dispersion contribute.  However, material dispersion accounts for a small portion of the total dispersion; recall that the group index of silicon is ~3.6, which is ~0.1 higher than the refractive index of silicon (n_Si).  In contrast, the group index for the waveguide is ~4.2, which is ~0.7 higher than n_Si.  If one was to simulate the waveguide without material dispersion (setting n_Si = 3.47, a constant), one would find that the group index is ~0.6 higher than the n_Si.  Thus, the waveguide dispersion is the dominant effect.
To get an intuitive understanding, simulate the mode for different wavelengths.  You will see that the mode is more spread out for longer wavelengths.  
Intuitively, more light is travelling through the lower index cladding for longer wavelengths.  The effective index can be thought of as a weighted average of the material indices, based on the mode profile.  Hence, less light in the silicon core for longer wavelengths leads to a lower effective index.



Could not parse problem




Simulation results for the strip waveguide show that the effective index increases with increasing geometry (width or thickness).
What is the main reason that the waveguide's effective index increases with width?





Explanation
The answer is similar to waveguide dispersion described above.  
To get an intuitive understanding, simulate the mode for different geometries.  You will see that the mode is more spread out for smaller waveguides with tails extending into the cladding.  In contrast, larger waveguides have more light inside the core.  
Hence, for larger geometries, more light in the silicon core, and this leads to a higher effective index.



Could not parse problem




Optical waveguides suffer from loss from a variety of sources.  
What is the dominant optical loss mechanism in a 500 nm wide strip waveguide, for a quasi-TE mode at 1550 nm?





Explanation
All of these mechanisms can contribute to optical loss in waveguides.
Absorption due to nearby metal is possible if there is metal in the process, and if it is close enough (e.g., less than 1 µm away)
Silicon material absorption is negligeable
Silicon dioxide material absorption becomes significant for wavelengths longer than ~3.0 µm
Surface-state absorption is possible, if the waveguides are not passivated, and is a contributing factor.
Side-wall roughness scattering is the dominant mechanism.
Top-of-waveguide roughness scattering is present, however, this interface is created during the wafer manufacturing process.  Smoothing steps are taken to ensure an exceptionally smooth surface.



Could not parse problem




Using the Effective Index Method, find the fundamental TE mode effective index at 1500 nm.
n_eff: Effective index of the waveguide:






Explanation
Change the wavelength in the code...  The first parameter is wavelength, in: wg_EIM_profile (1.50e-6, ...
Run the matlab code.
See the effective index displayed.



Could not parse problem


Use the Matlab code below (Effective Index Method, field profile) to view the field profile for a 500 x 220 nm waveguide.
  
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_EIM_profile.m - Effective Index Method - mode profile
% Lukas Chrostowski, 2012
% usage, e.g.:
%  wg_EIM_profile (1.55e-6, 0.22e-6, 0.5e-6, 90e-9, 3.47, 1, 1.44, 100, 2)

function main
	[neff_TEwg]=wg_EIM_profile (1.60e-6, 0.22e-6, 0.5e-6, 0, 3.47, 1.44, 1.44, 100, 2)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [neff_TEwg]=wg_EIM_profile (lambda, t, w, t_slab, n_core, n_clad, n_oxide, pts, M)

	% find TE (TM) modes of slab waveguide (waveguide core and slab portions):
	[nTE,nTM]=wg_1D_analytic (lambda, t, n_oxide, n_core, n_clad);
	if gt(t_slab,0)
		[nTE_slab,nTM_slab]=wg_1D_analytic (lambda, t_slab, n_oxide, n_core, n_clad);
	else
		nTE_slab=n_clad; nTM_slab=n_clad;
	end
	[xslab,TE_Eslab,TE_Hslab,TM_Eslab,TM_Hslab]=wg_1D_mode_profile (lambda, t, n_oxide, n_core, n_clad, pts, M);

	figure%(1);  clf; subplot (2,2,2); 
    Fontsize=15;
	plot(TE_Eslab/max(max(TE_Eslab)),xslab*1e9,'LineWidth',4);hold all;
	ylabel('Height [nm]','FontSize',Fontsize); 
	xlabel({' ','E-field (TE)'},'FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize,'XTick',[]);
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);
	Ax1 = gca; Ax2 = axes('Position',get(Ax1,'Position'));
	get(Ax1,'Position');
    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
	plot (nx, xslab*1e9,  'LineWidth',0.5,'LineStyle','--','parent',Ax2); 
	a2=axis; axis ([a2(1), a2(2), a(3), a(4)]);
	set(Ax2,'Color','none','XAxisLocation','top', 'YTick',[],'TickDir','in'); 
	set(gca,'YAxisLocation','right'); box off;
	xlabel('Material Index','FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize); 
%    print -dpdf eim1.pdf

	% TE-like modes of the etched waveguide (for fundamental slab mode)
	%   solve for the "TM" modes:
	[nTE,nTM]=wg_1D_analytic (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1));
	neff_TEwg=nTM;
	[xwg,TE_E_TEwg,TE_H_TEwg,TM_E_TEwg,TM_H_TEwg]=wg_1D_mode_profile (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1), pts, M);

    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
    figure%(1); subplot (2,2,3);
    % Plot the data on with a left and right axes. Return the axes and line
    % objects.
    [ax, h1, h2] = plotyy(xwg*1e9, TM_E_TEwg(:,1)/max(max(TM_E_TEwg)), xwg*1e9, nx);
    % Set the Xlabel and yLabel of each axes
    xlabel('Position [nm]','FontSize',Fontsize);
    ylabel(ax(1),'E-field (TM, TE-like mode)','FontSize',Fontsize);
    ylabel(ax(2), 'Slab Effective Index','FontSize',Fontsize);
    % Change the color of the right axes and the line style of line plot
    % associated with that axes.
    ax(2).YColor = 'b';
    h2.LineStyle = '--';
    h2.LineWidth = 0.5;
    h2.Color = 'b';
    % Set the Line width of the two line plots of the left axes.
    h1(1).LineWidth = 4;
    % Remove the left Tick labels.
    ax(1).YTick = [];
    % Set the YLim property so the plots line up.
    ax(2).YLim = [1.4, 2.6];
    ax(2).YTick = 1.4:0.2:2.6;
    
    % Plot the product of the two fields
	figure%(1); subplot (2,2,1);
	Exy=TM_E_TEwg(:,1)*(TE_Eslab(1,:));
	contourf(xwg*1e9,xslab*1e9,abs(Exy')/max(max(Exy))')
    % colormap('jet')
    axis equal
	xlabel ('X (nm)','FontSize',Fontsize); 
	ylabel ('Y (nm)','FontSize',Fontsize); 
	set (gca, 'FontSize',Fontsize); 
	A=axis; axis([A(1)+0.4, A(2)-0.4, A(3)+.2, A(4)-0.2]);
	title('Effective Index Method');
	% Draw the waveguide:
	rectangle ('Position',[-w/2,-t/2,w,t]*1e9, 'LineWidth',1, 'EdgeColor','white')
	if gt(t_slab,0)
		rectangle ('Position',[-M*w,-t/2,(M-0.5)*w, t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
		rectangle ('Position',[w/2,-t/2,(M-0.5),t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
    end

    
function draw_WG_vertical(M)
	pP=get(gca,'Position');pPw=pP(3); 
	pPc=pP(3)/2+pP(1); pP2=pPw/4/M;
	annotation ('line',[pPc-pP2,pPc-pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	annotation ('line',[pPc+pP2,pPc+pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	axis tight; a=axis; axis ([a(1), a(2), a(3)*1.1, a(4)*1.1]);

function draw_WG_horiz(M)
	pP=get(gca,'Position');pPw=pP(4); 
	pPc=pP(4)/2+pP(2); pP2=pPw/4/M;
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc-pP2,pPc-pP2],'LineStyle','--');
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc+pP2,pPc+pP2],'LineStyle','--');
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
    x1=linspace( -M*t, -t/2, pts); 
    x2=linspace( -t/2, t/2, pts); x2 = x2(2:end);
    x3=linspace( t/2, M*t, pts);  x3 = x3(2:end);
    x=[x1 x2 x3];
    nx=[n1*ones(pts,1); n2*ones(pts-1,1); n3*ones(pts-1,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
			     
      



        %%
   
        
      



Could not parse problem




Part 1

Using this tool, compute the mode profile and calculate the effective index of the fundamental TE mode for a 450x220 nm waveguide at 1550 nm.
    
Note:  This is a graded code box.  When ready, press "CHECK". After your code executes, additional code on the server will check your answer.  
  
Download script:  Phot1x_wg_2D_matlab.m



      %%    
      global neff
      



% This example computes the field components and the effective index of a
% silicon-on-insulator strip waveguide.
% slightly modified version, from: http://www.photonics.umd.edu/software/wgmodes/
function [neff]=main

	global neff w  % Used by the auto-graded to check your answer.

	n1 = 1.44;          % SiO2 lower cladding
	n2 = 3.47;          % Silicon core
	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 2.5;           % grid size (x)
	dy = dx;            % grid size (y)

	lambda = 1550;      % wavelength (nm)
	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

	fprintf (1,'post-processing... '); t = cputime;

	[Hz,Ex,Ey,Ez] = postprocess (lambda, neff, Hx, Hy, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf (1,'graphing... '); t = cputime;

	hn = abs(interp2(y,x,Hy,h1+h2/2,0));
	en = abs(interp2(yc,xc,Ex,h1+h2/2,min(dx)/2));

	% Plot |E| profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,sqrt(abs([-Ex(end:-1:1,:);Ex]).^2+abs([-Ey(end:-1:1,:);Ey]).^2+abs([-Ez(end:-1:1,:);Ez]).^2)/en);
	title('|E|');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% could normalize the |E| plot to show energy...
	%size (eps)

	% figure;
	% imagemode(x,y,Hx/hn);
	% title('Hx');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hy/hn);
	% title('Hy');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hz/hn);
	% title('Hz');
	% for v = edges, line(v{:}); end

	% Plot Ex profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,[-Ex(end:-1:1,:);Ex]/en);
	hold on;
	contourmode([-xc(end:-1:1);xc],yc,[-Ex(end:-1:1,:);Ex]/en,(0:-5:-60));
	title('Ex');
	v = xlim();
	line(v,[h1,h1], 'Color', 'k');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% figure;
	% imagemode(x,y,Ey/en);
	% title('Ey');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Ez/en);
	% title('Ez');
	% for v = edges, line(v{:}); end
	
	% figure;
	% imagemode(x,y,sqrt(abs(Ez).^2+abs(Ey).^2+abs(Ex).^2)/en);
	% title('|E|');
	% for v = edges, line(v{:}); end

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

end

function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end

      

	  % Change the width of the waveguide to 450 nm, via the following variable on line 22:
      w = 450;
	  

        %%
      global neff w
	  ansVar=2.34749;
	  var=neff;
	  assert(all(lt(abs(w-450), 2e-3)), 'Please find the effective index for a waveguide with w=450.')
	  assert(all(lt(abs(ansVar-var), 2e-3)), 'Incorrect answer.  Please double-check that you are solving for the effective index for a waveguide with width of w=450.  Also check that your simulations have converged and are accurate.  The tolerance on this checker is 2e-3.')
		
      



Could not parse problem




Part 2

Calculate and plot the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide.
    
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  
Download script:  Phot1x_wg_2D_sweep_matlab.m



      %%    
      global neff
      



function main

	% Example wavelength sweep parameters with refractive indices:
	global lambdas % for the auto-grader
	lambdas = [1500, 1525, 1550, 1575, 1600]; 
	n1s = [1.444, 1.444, 1.444, 1.444, 1.444];  % Silicon dioxide index of refraction
	n2s = [3.47998, 3.47768, 3.4755, 3.47344, 3.47147]; % Silicon index of refraction

	% Perform effective index calculations
	global neffs % for the auto-grader
	neffs=[]; % initialize empty matrix to store effective index values.
	for i=1:length(lambdas)
		neffs(end+1) = wgmodes_neff(lambdas(i), n1s(i), n2s(i));
	end

	% plot effective index versus wavelength
	figure
	plot (lambdas, neffs)

	% calculate group index versus wavelength ...

end

function [neff]=wgmodes_neff(lambda, n1, n2)
	% inputs:
		% lambda - wavelength, in nm
		% n1 - SiO2 lower cladding
		% n2 - Silicon core

	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 5;           % grid size (x)
	dy = dx;            % grid size (y)

	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

end

% require the functions "wgmodes", "waveguidemesh", "stretchmesh", etc.


function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end


      

Copy and paste the WGMODE codes from the previous unit at the bottom of the above code block.  

Change the material index of refraction values.
	  

		%%
      



Could not parse problem




Perform numerical calculations for the following waveguide:



500 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm


TE polarization



Enter the effective index:






Explanation
To arrive at the correct answer, make sure you have done the following:
    Change the wavelength to 1550 nm.Follow the steps in the preceeding tutorial.
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




Perform numerical calculations for the following waveguide:


600 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm



TM polarization



Enter the effective index:






Explanation
To arrive at the correct answer, make sure you have done the following:
    Look at the 2nd mode, which should be TM polarized. The effective index is smaller than the TE mode.Change the wavelength to 1550 nm.Change the width of the waveguide to 600 nm.Increase the simulation region.  Check that the fields have decayed to 1e-9 (in energy).  This is achieved for an FDE simulation width of 3 micron, and height of 3.5 micron.  
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




The group index of the waveguide is a very important parameter, which as we will see, determines one of the most important features of the Mach-Zehnder Interferometer circuit -- the Free Spectral Range.
Find the group index for the following waveguide:



        500 nm width
      

        220 nm height
      

        silicon core
      

        oxide cladding
      

        wavelength = 1550 nm
      

        TM polarization (hint: this is the 2nd mode; the one with the TE polarization fraction (Ex) that is close to 0.)
      


Enter the group index:  (answer checked within +/- 0.03 of the instructor's answer)






Explanation
Make sure you make the following changes in the simulation:
  Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.Increase the number of simulation mesh points, e.g., 200.  Check the simulation mesh, and make sure it lines up with the waveguide edges.Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode. Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
If you are still not getting the same answer (but are "close"), continue on.  There is a unit "Convergence tests", which analyzes the sources of error in the simulations.




 Make sure you make the following changes in the simulation: 
 1) Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.   
 2) Increase the number of simulation mesh points, e.g., 200, or even more.  
 3) Check the simulation mesh, and make sure it lines up with the waveguide edges.  
 4) Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode.  
 5) Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
	  
If you are still not getting the same answer (but are "close"), continue on.  There is a later unit "Convergence tests", which analyzes the sources of error in the simulations.


Could not parse problem





Find a polynomial curve fit for the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide, in the 1500 to 1600 nm range.
    
 Note: when your run the code, the last plot is generated by the instructor's code. It allows you to compare your answer with the instructor's.
If you are using Dropbox, you need to change the link to replace dl=0 with dl=1.
Download the matlab script, Phot1x_fit_wg_compactmodel.m
 Note: This is a graded problem.  Click "CHECK" to verify your answer.



      %%    

disp('****************************************************')
disp('The following output is generated by the instructor:')
	  
% Check fit:
if exist('r2')
  if lt(r2,0.8)
    disp 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.'
  end
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
end


% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

if gt(abs(X(1)-X_lukas(1)),0.01)
  disp ('The X(1) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(2)-X_lukas(2)),0.01)
  disp('The X(2) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(3)-X_lukas(3)),0.01)
  disp('The X(3) parameter is more than 1% different than the instructor answer.')
end

      



% User provides a matrix of neff values vs. wavelength
% Matlab curve fits to an expression.

% url='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
url='https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/wg-export-TM.mat'
a=websave('wg.mat',url); % get data from Dropbox
load('wg.mat');

neff = real(neff)  % take the real part of the effective index.

c=299792458;  % speed of light, m/s
lambdas = c ./ f;  % f is the matrix of frequency points, 
                   % where the effective index is recorded.
lambdas = lambdas * 1e6  % convert to microns.
lambda0 = 1.55;   % replace with desired centre wavelength

figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;

% use Matlab anonymous function for the effective index expression:
neff_eq = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 

% initial guess.
X=[2.4 0 0]; 

plot ( lambdas, neff_eq(X, lambdas), 'r')

% curve fit to find expression for neff.
format long
X = lsqcurvefit (neff_eq, X, lambdas, neff)

r=corrcoef(neff,neff_eq(X, lambdas));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

lambdas2=linspace(min(lambdas), max(lambdas), 100);

plot ( lambdas2, neff_eq(X, lambdas2), 'k')
xlabel ('Wavelength [nm]');
ylabel ('Effective Index');

legend ('Data','Initial Guess','Curve Fit')


      

If you don't have Dropbox, you can create the two variables to be used by the above code: neff, and lambdas.  Then proceed to curve fit this data, and compare to the instructor result.
	  

%%
% Grader:
%disp('****************************************************')
%disp('The following output is generated by the instructor:')

% Check:
if exist('url')
 url0='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
 assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
end
        
% Check fit:
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

% Check:
assert(lt(abs(X(1)-X_lukas(1)),0.01), 'The X(1) parameter is more than 1% different than the instructor answer.')
assert(lt(abs(X(2)-X_lukas(2)),0.02), 'The X(2) parameter is more than 2% different than the instructor answer.')
assert(lt(abs(X(3)-X_lukas(3)),0.1), 'The X(3) parameter is more than 10% different than the instructor answer.')
		
      



Could not parse problem





The objective of this problem is to create a compact model for the waveguide, in the form of an expression.  Find an expression for the effective index versus wavelength.

  Use (ONLY) the following parameters:
  lambda: units micronsthe other parameters should be numbers
Your expression will be verified with the instructor's answer.
The answer should be in the format such as "2.4 - 1 * (lambda-1.55) -0.1 *(lambda-1.55)^2" 

neff = "2.444509 -1.1273 * (lambda - 1.55) -0.03335 * (lambda-1.55)^2"







Explanation
The answer is in the form of \( n_\text{eff}(\lambda) = 2.4 - 1.1 (\lambda - 1.55) + 0.1 (\lambda-1.55)^2 \)



To check the answer, we evaluate your expression over a range of 1.5 to 1.6 microns.  We then compare to the instructor's answer, and check that the effective index you provide is within +/- 0.02 of the correct answer.  


Could not parse problem




What is the waveguide geometry that gives the smallest mode area, for the TE polarization at 1550, for a silicon thickness of 220 nm, strip waveguide?  Answer is the waveguide width, with units of nanometers (required accuracy with 20 nm).






Explanation
Find the smallest mode area to be for a waveguide of approximately 360 nm in width.



Modify the script to sweep (using a for loop), the waveguide width parameter (width_ridge in the script).  Plot the mode area and confinement factor, versus the waveguide width.  
Or do it manually, iteratively.


Could not parse problem

Assume that 1 mW of light is input into an ideal Y-Branch splitter (Port E_0).  
The port labels in this problem are based on the diagram at 1:00 in the video.
_____________________________________________________________________________
How much optical power comes out of output 1 (Port E_1)? [Answer in mW]





Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.



Could not parse problem

Assume that 1 mW of light is input into ONE of the branches of an ideal Y-Branch combiner (Port E_1).  
The port labels in this problem are based on the diagram at 1:45 in the video.
_____________________________________________________________________________
How much optical power comes out of output 0 (Port E_0)?   [Answer in mW]





Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.



Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions).  You can ignore the radiation losses (loss in dB/cm in MODE Solutions) since they are small.  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is joined to the bent waveguide with no shift.
 
Determine the bend radius required for a TE mode to ensure that the loss is less than 0.1% (which is 0.004 dB) [Answer in microns, accuracy with +/-0.5]:






Explanation
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap.  Or you can use scripts, as provided in the next unit.
(Sorry for the brief explanation.  Post in the discussion below for more info.)



You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap calculations.  Do it iteratively, which only takes a few minutes. 
Or you can use scripts, as provided in the next unit.
The desired total transmission through the bend is 0.999.  Make sure that you are searching for the overlap value of sqrt(0.999).


Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions) and radiation losses (loss in dB/cm in MODE Solutions).  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is joined to the bent waveguide with no shift.
 
Determine the bend radius required for a TM mode to ensure that the loss is less than 1% (which is 0.04 dB insertion loss)  [Answer in microns, accuracy with +/-1]:




Determine the bend radius required for a TM mode to ensure that the loss is less than 0.1%  [Answer in microns, accuracy with +/-3]:






Explanation
For 11 µm, we find:
  Propagation loss, coming from radiation loss:  0.277 dB/cm.  For a 1/4 circle, you can find the dB for the bend by: ?(-2*pi*11e-4/4*0.277); which is 0.000479 dB.  In linear units, this is   ?10^(-2*pi*11e-4/4*0.277 /10);  which is 0.99989.  Mode-mismatch loss, using overlap calculation:  0.99533Multiply the two together:  ?10^(-2*pi*11e-4/4*0.277 /10) *  (0.99533)^2; = 0.9906.

Quite likely your numbers will be slightly different, due to different simulation configuration (mesh, span, etc).   I used a span of 2.8 µm, with a 10 nm mesh.
  
              For 33 µm, we find:
  Propagation loss, coming from radiation loss: ~0 dB/cm. Mode-mismatch loss, using overlap calculation: 0.99951
(Post in the discussion below for more info.)



For the TM mode, you need to increase the thickness of the simulation, namely in the Z direction, so that the boundaries do not interfere with the simulation.  
If you are having trouble finding the TM mode: In the Eigenmode Analysis settings, you can also use search - near n - 1.8, to help the software find the correct TM mode. 
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap and radiation loss calculations.  Doing it manually, iteratively, only takes a few minutes.  
Or you can use scripts, as provided in the next unit.
Don't forget to consider that there are two mode-mismatch losses per bend, so square the overlap value.  And add the radiation loss in dB/cm times the length.


Could not parse problem




Calculate the mode-mismatch and radiation losses for the following bends, for TE polarization, 1550 nm wavelength [Answer in dB]:
Bend radius of 3 µm:




Bend radius of 5 µm:






Explanation
Can do it manually using mode overlap calculations, or using script.



Could not parse problem




Consider an interferometer with ideal lossless components (no waveguide loss, no additional loss in the splitter).
What is the maximum optical output power, if the input power is 1 mW?  [Answer in mW].





Explanation
Constructive interference with no loss in the circuit gives 100% transmission, or 1 mW output.



Could not parse problem




Assume a waveguide has the following effective index values:
  2.5 at 1.5 µm 2.4 at 1.6 µm 
What is the waveguide group index at 1.55 µm? [answer accuracy +/- 0.001]






Explanation
ng = 2.45 - 1.55 * (-0.1)/0.1.



Could not parse problem




Assume an interferometer with the following properties:
  Wavelength of operation is 1.55 µmWaveguide's group index is 4.2Path length mismatch ∆L is 100 µm
What is the Free Spectral Range, in [answer in nm, accuracy +/- 0.01]?






Explanation
FSR = 1.55e-6^2 / 100e-6 / 4.2 * 1e9
Don't forget to convert from meters to nanometers.



Make sure your answer is correct to +/- 0.01 nm.
The answer is in units of nanometers.


Could not parse problem


You may use this MATLAB window as a calculator to help you answer the questions.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem





  In this unit, we provide you with MATLAB code (download Phot1x_MZI_matlab.m) to simulate the optical transmission spectrum (or transfer function) of the Mach-Zehnder Interferometer.  You can use this code to experiment with the MZI behaviour, gain insight into how the spectrum changes as a function of L2-L1, see how loss impacts the extinction ratio, and so on.  Also, be sure to modify the compact waveguide model parameters to match the waveguide you have modelled and are planning on using in your design.
  

You will need to make adjustments to the constants in the model.  Specifically, change the following:
    n1, n2, n3: the compact waveguide model coefficients. lambda0: the centre wavelength used for the waveguide model. lambda_min, lambda_max: the wavelength range over which you want to plot.  lambda_step: the wavelength step for the plot. Keep in mind that the Agilent/Keysight Technologies laser (81600B) has a wavelength resolution of 0.1 pm, however, we perform automated measurements typically with a 10 pm resolution.  alpha: the propagation loss of the waveguide. L1, L2: the lengths of the two waveguides in the interferometer. 
Note that all constants are in units of microns, unless noted.

          


      %%    
      
      



% the wavelength range of interest.
lambda_min = 1.5;  % Units [µm, microns]
lambda_max = 1.6;
lambda_step = 0.01e-3; % wavelength step [microns]
                       % Typical minimum step for a tunable laser is 1-10 pm.
lambda=lambda_min:lambda_step:lambda_max;

% Define the MZI transfer function
%  use Matlab anonymous functions

% Effective index:
% - as a Taylor expansion around the central wavelength, lambda0
lambda0 = 1.55; n1=2.4; n2=-1; n3=0;  % these are constants from the waveguide model.
neff = @(lambda) ...
		(n1 + n2.*(lambda-lambda0) + n3.*(lambda-lambda0).^2); 
% plot, and check if this is as expected:
figure;
plot(lambda, neff(lambda),'LineWidth',3);

% Complex propagation constant
alpha = 1e-3;  % propagation loss [micron^-1]; constant
beta = @(lambda) ...
		(2*pi*neff(lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );


% MZI transfer function
T_MZI = @(L1, L2, lambda) ...
        ( 0.25* abs(exp(-1i*beta(lambda)*L1)+exp(-1i*beta(lambda)*L2)).^2);

% plot, and check if this is as expected:
L1=100;
L2=200;  % Units [µm, microns], variable
figure;
plot(lambda, T_MZI(L1, L2, lambda),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission');
axis tight
title ('MZI transfer function');

figure;
T_MZI_dB = 10*log10(T_MZI(L1, L2, lambda));
plot(lambda, T_MZI_dB,'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI transfer function');
      



        %%
var0=[n1, n2, n3, alpha, L1, L2];
var1=[2.4, -1, 0, 1e-3, 100, 200];
assert(not(isequal(var0,var1)), 'Looks like you just ran the code without changing the parameters: n1, n2, n3, alpha, L1, L2.  These are parameters specific to your waveguide and need to be changed.');
        
      



Could not parse problem




An optical frequency of 193.1 THz corresponds to what wavelength? [Answer in nm, accuracy +/- 0.01].






Explanation
Wavelength = Speed of light / Frequency.
In INTERCONNECT, you can write in the "Script Prompt": ?c/193.1e12;
and obtain the answer 1.55252e-6



Could not parse problem




Consider an ideal Y-branch. What is the transmission from the input to one of the outputs, in dB? (what is a dB?) [Answer accuracy +/- 0.001].






Explanation
In INTERCONNECT, you can write in the "Script Prompt": ?10*log10(0.5); which equals -3.0103



The insertion loss is a positive number in dB.  The transmission for a passive component is always less than 0 dB (negative number).  
Transmission in dB = 10 x log10 (T), where T is the transmission in the linear scale.  In INTERCONNECT, you can type in the Script Prompt to calculate:  ?10*log10(T);
The ideal Y-Branch has a transmission, T = 0.5.


Could not parse problem




Answer this question by constructing the following circuit in Lumerical INTERCONNECT:
  Two grating couplers   Connect to a network analyzer.
Measure the best-case fibre-to-fibre insertion loss.
  
          Best-case insertion loss of two grating couplers (positive value, in dB, required accuracy +/- 0.1):





Could not parse problem




Build a Michelson Interferometer circuit as follows:


One 2x2 splitter (Broadband Directional Coupler): Design kits/ebeam_v1.2/ebeam_bdc_1550

Two strip waveguides, TE 1550 nm, to create the interferometer, and connected to the outputs of the 2x2 splitter: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide lengths: L1 = 215 µm, L2 = 15 µm.
    
A loop-back mirror.  A loop-back mirror consists of one 1x2 splitter (y-branch) with both outputs connected together with a waveguide so the light "reflects" back to the input. It consists of:
    A Y-Branch, TE 1550 nm: Design kits/ebeam_v1.2/ebeam_y_1550.  
    A strip waveguide, TE 1550 nm, connected to the two outputs of the y-branch: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide length is arbitrary, e.g., 10 µm.
    

An Optical Network Analyzer.  Properties: centre frequency = 1550 nm; frequency range = large enough so that you can see multiple peaks; Results view: turn on annotation for "gain" and "free spectral range".
    







What is the free spectral range (FSR) of the peak nearest 1550 nm. [Answer in nm, accuracy +/- 0.1]






Explanation
Here is the INTERCONNECT project for the solution.








Could not parse problem





The free spectral range (FSR) of the Michelson Interferometer is different from the Mach-Zehnder Interferometer.
    Why? 

In this math expression input problem, your text represents a
mathematical expression, and text is converted to a symbolic
expression that appears below the field. You can refer to 

Entering Mathematical and Scientific Expressions in the edX Guide for information about how to enter text into the field.


  Determine the expression for the FSR (in terms of wavelength) of the Michelson Interferometer based on the path length difference, \(\Delta = | L_2-L_1 | \) (write it as "Delta" below), the centre wavelength, \( \lambda \) (write it as "lambda"), and the waveguide group index, \( n_g \) (write it as "n_g"). 





FSR = "lambda^2/(2 * Delta * n_g)"


Verify your formula using the example circuit we simulted above. 
You can review the derivation of the Free Spectral Range for the Mach-Zehnder Interferometer (unit: Photonic Circuits > Interferometers > FSR of imbalanced MZI.
Here is a paper of a fabricated Michselson Interferometer
Watch the video on in the unit: Photonic Circuits > Interferometers > Overview of interferometer types, applications, where the Michselson Interferometer is discussed at time 9:10.


Could not parse problem




Build a Michelson-like Interferometer circuit as follows (I'm sorry, I don't know what this is called):


Two 2x2 splitters (Broadband Directional Coupler): Design kits/ebeam_v1.2/ebeam_bdc_1550

Two strip waveguides, TE 1550 nm, in the interferometer section: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide lengths: L1 = 115 µm, L2 = 15 µm.
    
A strip waveguide, TE 1550 nm, for the loop-back mirror: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide length is arbitrary. (Loop-back mirror consists of one splitter with both outputs connected together with a waveguide so the light "reflects" back to the input.)
    
An Optical Network Analyzer.  Properties: centre frequency = 1550 nm; frequency range = large enough so that you can see multiple peaks; Results view: turn on annotation for "gain" and "free spectral range".
    







What is the free spectral range (FSR) of the peak nearest 1550 nm. [Answer in nm, accuracy +/- 0.1]






Explanation
Here is the INTERCONNECT project for the solution.








Could not parse problem




For your Mach-Zehnder Inteferometer designs, enter the parameter variations for the path length difference (∆L).  When you press "check", the system will give you some feedback - we are performing a simple sanity-check to make sure that your designs are reasonable.  
Keep in mind that the smallest laser step size is 1 pm, and the typical measurement bandwidth limited by the grating couplers is 50 nm.
 
Enter your design parameters separated by commas, in units of [µm]




def make_a_list(name_string):
    return name_string.split(',')

def count_names(name_list):
    return len(name_list)

def num(s):
    try:
        return float(s)
    except ValueError:
        return 0
      
def how_many_oli(expect, ans):
    names = make_a_list(ans)
    how_many = len(set(names))
    message_hint = ''
    check = True
    for e in names:
        e=e.strip('"')
        e=e.strip("'")
        e=e.strip()
        e=e.lower()
        dL=num(e)
        who_is = e
        if dL &lt; 22:
            if dL == 0:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" (0) micron, you may still have a path length mismatch due to fabrication variations.  \n "
                check = False
            else:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, you will not see oscillations within the measurement span; longer path length mismatch required.  \n"
                check = False
        if dL &gt; 57200:
            message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, we will not be able to resolve the oscillations since they the FSR is too small and the loss differential too high; shorter path length mismatch required.  \n"
            check = False
    if how_many &lt; 1:
        return { 'ok': False, 'msg': 'None at all?'}
    if how_many &lt; 5:
        return { 'ok': check, 'msg': 'Only '+str(how_many)+" variations?  "+message_hint}
    if how_many == 5:
        return { 'ok': check, 'msg': message_hint }
    if how_many &gt; 5:
        return { 'ok': check, 'msg': message_hint }
    return False

  





Explanation
Assuming you want to see oscillations versus wavelength, the minimum path length difference is limited by span.  For 50 nm, 2 oscillations, is FSR = 25 nm.  Assuming ng=4.2, the min dL is ~ 23 µm.

            The maximum path length difference, to be able to resolve oscillations with 10 points per oscillation: 1 point is 1 pm, 10 is 10 pm.  So FSR is 10 pm, hence max ∆L=57 mm.  Assuming 3 dB/cm, this would yield a 17 dB loss difference.  The oscillation fringes would not be visible.  For such a large path-length mismatch, lower loss waveguides would be required (e.g., 3 µm wide multi-mode waveguide).
          



Could not parse problem


Use the Matlab code below to download and plot the measurement data.  The data is for two TE grating couplers, connected with a short waveguide (about 150 microns).  
  

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
% or same file from aws:
url = 'https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/ZiheGao_MZI2_271_Scan1.mat'

PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');
     
      



%%        
      



Could not parse problem


Use the Matlab code below to download, plot, and analyze the measurement data for YBranches for the TM polarization.  The data is for two TM grating couplers, and several YBranches.  The GDS file for the layout used for this experiment is EBeam_LukasChrostowski_TM_YBranches.gds.
  
Note that you can download and run this Matlab file, lukasc_YBranch_TM.m.  If you have the Statistics Toolbox, the program will generate an error estimation.  In the following graph, the shaded region corresponds to the 95% confidence interval.
    

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the insertion loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess insertion loss of about 10 dB.  For example,
% if the DUT is estimated to have an insertion loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the insertion loss, we plot the measured insertion loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the insertion loss for one DUT.

% For the case of the YBranch, the circuit consists of two YBranches facing
% each other. This creates an interferometer.  Assuming the waveguides are
% perfectly matched, the interferometer insertion loss will be only due to
% the excess loss of the YBranch.

% The following layout implements test structures for the YBranch described
% in paper http://dx.doi.org/10.1364/OE.21.001310
% EBeam_LukasChrostowski_TM_YBranches.gds
% https://www.dropbox.com/s/vs0hvrggbn5f9ip/EBeam_LukasChrostowski_TM_YBranches.gds?dl=1

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'YBranch (TM)';
% At what wavelength do you want to find out the insertion loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'lukasc_YBranch3_1262.mat', ...
    'lukasc_YBranch9_1261.mat', ...
    'lukasc_YBranch15_1260.mat', ...
    'lukasc_YBranch21_1263.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 3, 9, 15, 21 ] * 2;
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/louspt78v28x1dw/lukasc_YBranch3_1262.mat', ...
        'https://www.dropbox.com/s/cqyc233aqm8b2rc/lukasc_YBranch9_1261.mat', ...
        'https://www.dropbox.com/s/xrvtv54hmvjpfh4/lukasc_YBranch15_1260.mat', ...
        'https://www.dropbox.com/s/eiypug7qkx1p1ry/lukasc_YBranch21_1263.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength, nm');
ylabel ('Insertion Loss, dB');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the insertion loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the insertion loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Number of YBranches');
ylabel ('Insertion Loss (dB)');
title (['Cut-back method, ' deviceName ' insertion loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/YBranch'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' insertion loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/YBranch'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/YBranch'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' insertion loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/YBranch'])
end



% wavelength dependance of the DUT insertion loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Insertion loss, 95% Confidence Interval', ...
        'Insertion loss, from polyfit', ...
        'Insertion loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Insertion loss, from polyfit', ...
        'Insertion loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' insertion loss, wavelength dependance'] )
ylabel ('Insertion Loss (dB)');
xlabel ('Wavelength, nm');
set(gca,'FontSize',FONTSIZE)
     
      



%%        
      



Could not parse problem

Given the space allocation for this course, what is the largest number of fibre grating couplers that can be connected to a single circuit? [Answer: an integer]





Explanation
The total height of 4 couplers is 127 µm x 3 = 381, plus some extra height for the coupler itself (about 20 µm). This is why the 405 µm height was chosen.



Could not parse problem

You can enter your license code here, to help you remember. When you click "Check", it will come back incorrect; don't worry. It's just there to for your convenience.





Explanation



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The fibre grating couplers must be vertically spaced exactly 127 µm apart, and horizontally aligned.  In this layout, the bottom grating coupler is offset hence light will not be efficiently coupled into the bottom fibre. 



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The highlighted waveguide has sharp 90º angles; these should be replaced with smooth 90º bends to provide low optical loss and low back-reflections.  



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
This layout is missing a label for the automated measurements, e.g., "opt_in_TE_1550_device_LukasChrostowski_MZI3".  



Could not parse problem

Consider an EBL system with a minimum writing grid of 1 nm, and a field size of 1 mm.   
How many bits are required in the Digital to Analog converter (DAC) to achieve the necessary resolution? [answer is an integer]





Explanation
The distance is twice that of the 500 µm example, hence one extra bit, thus 20.



Could not parse problem

Consider a single chip (25 x 25 mm), with four quarters each, with each quarter having a design area of 8.8 mm x 8.8 mm.  
Consider a single participant design size of 605 x 410 µm.  
How many participant designs can fit on a single chip? [required answer accuracy +/- 100]






Explanation
in MATLAB: answer = floor(8800/410)*floor(8800/605)*4 = 1176.
Spread the word about this course, since we have a lot more room for designers.



Our chip is at about 10% capacity.  Spread the word about this course, since we have a lot more room for designers.


Could not parse problem

Consider a single design area of 8.8 mm x 8.8 mm.  
Consider an extremely dense silicon photonic waveguide-based circuit, consisting of 500 nm wide waveguides, on a 3 µm centre-to-centre pitch.  Assume these waveguides are covering the entire design, as a series of parallel lines.  The layout is to be fabricated with a 6 nm shot pitch on the JEOL EBL system at UW, and written with a dose of 2800 uC/cm^2, with a current of 8 nA. 
How long would it take to write this chip? [answer in Hours, required answer accuracy +/- 1.0]






Explanation
in MATLAB:
Dose = 2800/1e4^2 % convert µC/cm^2 to µC/µm^2
A_written=(8800*.5/3)*(8800) % in µm^2
Ibeam = 8000/1e6 % convert pA to µA
t_seconds = Dose * A_written / Ibeam
t_minutes = t_seconds / 60
t_hours = t_minutes / 60
 ANSWER 12.5 hours.  



The gap between waveguides is not 3 µm.
You can use Matlab to calculate using the formula t_seconds = Dose * A_written / Ibeam.  Don't forget to convert the units.
You can use the provided online EBEAM calculator.
The machine can be left running overnight.


Could not parse problem




Consider an MZI that was designed to be balanced, with both path lengths being 100 µm.  Assume a lossless interferometer, such that if it was perfectly manufactured, it would have 100% transmission at 1550 nm.
Consider a chip where due to on-chip manufacturing variations, the effective index of both waveguides increases simultaneously by 1%.
What is the transmission of this MZI? [answer in percentage, an integer without the % symbol. required answer accuracy of +/-1%].






Explanation
no change in the transmission



No math required for this question.  This about it intuitively.
The ideal design has 100% transmission due to constructive interference.  What happens if the same phase shift is added to both arms of the interferometer?


Could not parse problem




Consider an MZI that was designed to be balanced, with both path lengths being 100 µm.  Assume a lossless interferometer, such that if it was perfectly manufactured, it would have 100% transmission at 1550 nm.
Consider a chip where due to on-chip manufacturing variations, the effective index of the two waveguides differs by 0.00775.
What is the transmission of this MZI? [answer in percentage, an integer without the % symbol. required answer accuracy of +/-1%].






Explanation
dneff=0.00775
L=100e-6
dbetaL = 2*3.1415*dneff*L/1550e-9 = 3.1415
Pi phase shift results in desctructive interference, or 0 transmission.



You'll probably need to go back to the interferometer equations (Photonic Circuits | Modelling - MATLAB | MZI Transfer Function).
The ideal design has 100% transmission due to constructive interference.  What happens if there is a relative phase shift between the waveguides?


Could not parse problem




Perform the corner analysis on the 500x220 nm waveguide, for TE, at 1550 nm.  Determine the range of values possible for the group index, ng.



Assume that the wafer thickness varies between 215.3 and 223.1 nm
Assume that the waveguide width varies between 470 and 510 nm


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Explanation
No explanation yet.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the 9 cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength).
  


Could not parse problem

Consider an MZI with a ∆L = 100 µm, with 500x220 nm waveguides, operating in the TE polarization, at 1550 nm.  Using a corner analysis, determine the range of values possible for the Free Spectral Range.
What is the minimum value for the FSR? [answer in units of nm, within an accuracy of 0.04] 




What is the maximum value for the FSR? [answer in units of nm, within an accuracy of 0.04]






Explanation
.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the corner cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength), then using the formula for FSR for the given ng values.
  


Could not parse problem

  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 



      %%    
      
      







        %%
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');


     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data (ZiheGao_MZI2_271_Scan1.mat). 
  
Choose the polynomial order (POLY_ORDER, or the value the polyfit function) to a value such at the polynomial follows the envelope of the MZI + Grating Couplers spectrum. Namely, the resulting polynomial should approximate the grating coupler insertion loss, and the flattened spectrum should look like the ideal MZI spectrum with the peaks at approximately 0 dB.
  



      %%    
      
      



% Enter the order of the polynomial for the curve fitting:
POLY_ORDER = 1;
        
% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, POLY_ORDER);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 
figure;
plot (lambda*1e6, amplitude); hold all;
plot (lambda*1e6, amplitude_baseline, 'LineWidth',4);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with polymial fit)');

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');
     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem




 What value for the polynomial order (POLY_ORDER) is appropriate for correcting the baseline? 


1 You need a higher order polynomial; try increasing POLY_ORDER.
2 Too few.
3 Ok.
4 Ok.
5+ Likely the polynomial has too high an order. Be very careful not to "overfit" the data.



Adjust POLY_ORDER above, and re-run the code.  You should see a polynomial that looks similar to a grating coupler response (as in the first plot at the top).


Could not parse problem




In this section, you can calibrate a measured spectrum using a "loopback" structure.
Objective:



remove the baseline shape of the grating couplers



Method:



curve-fit the spectrum of two grating couplers (or an MZI with ∆L=0) using a low-order polynomial
Restrict to ~10 dB from peak to avoid using data with a large error
Subtract this polynomial from subsequent data



You can download and run the Matlab code on your own computer. 

Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      




% Read data files from experiments
% Enter the Dropbox URLs here.  Make sure the URL has a =1 at the end:
%  Loopback structure:
	url_loopback = 'https://www.dropbox.com/s/w915qfix9kwlwv7/ZiheGao_MZI1_272_Scan1.mat?dl=1';
%  MZI:
	url_mzi = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
% Calibrate the MZI data using the loopback structure
% Plot


PORT=1; % Which Fibre array port is the output connected to?
FONTSIZE=20;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Loopback data:
a=websave('loopback.mat',url_loopback); % get data from Dropbox
load('loopback.mat');
% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda*1e6, amplitude);
title ('Calibration loopback'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)
hold all;

% Fit the data with a polynomial
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 5);
amplitude_LOOPBACK=polyval(p,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, amplitude_LOOPBACK);
% find wavelength range with usable data, in the loopback
loopback_IL = max(amplitude);
new_lambda_i=find(amplitude>loopback_IL-10);
lambda=lambda(new_lambda_i);
lambda_min = min(lambda);
lambda_max = max(lambda);
amplitude=amplitude(new_lambda_i);
% refit the loopback
LOOPBACK=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_LOOPBACK=polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, [amplitude_LOOPBACK],'r-','Linewidth',5);
axis tight;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data:
a=websave('mzi.mat',url_mzi); % get data from Dropbox
load('mzi.mat');
lambda1=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda1*1e6, amplitude);
title ('MZI (raw data)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data - calibrated
%
% data only within the bandwidth of interest.
lambda=lambda_min:min(diff(lambda1)):lambda_max;
amplitude=interp1(lambda1, amplitude, lambda,'linear');
amplitude(find(amplitude==-inf))=-50;
% calibrate data
amplitude_cal=amplitude-polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
figure;
plot (lambda*1e6, amplitude_cal);
title ('MZI (calibrated with loopback)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)


    
      



        %%
	url_mzi0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url_mzi0, url_mzi)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

You will need to make adjustments to the initial parameters for the fitting function.  Specifically, change the following line:
  


   nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
    

 Check your answer when you think you have a good fit.  
  
Please note that this code fits the response using the MZI transfer function. This function includes the path length difference, ∆L. This must match the design, in order to have meaningful results. 



      %%    
      
      




% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
lambda0 = mean(lambda)*1e6;		
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.

% initial function for fitting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];
figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');

% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      

nx_init = [2.4, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
      

        %%
%url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
%assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  
Note that two data file examples are provided. Note that the ∆L path length difference must be correctly set.



      %%    
      
      



% Lukas Chrostowski, curve fitting the MZI using findpeaks, 2015/08/14

% Enter the Dropbox URL here.  Make sure it has a =1 at the end:

% TE
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

% TM:
%url = 'https://www.dropbox.com/s/onjwrarapf6dumv/ADCL_1_1153_Scan1_L2-L1%3D100um.mat?dl=1';
%dL = 100;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
if not(exist('lambda_min'))
	lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
end
if not(exist('lambda_max'))
	lambda_max = max(lambda);   %  if the data on the edges is noisy
end
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find peaks, extract FSR and ng, and neff
% as initial parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% smooth (0.1% moving average filter)
windowSize = floor(1e-3*length(lambda)); b = (1/windowSize)*ones(1,windowSize);
amplitude_smooth=filter(b,1,amplitude);
% FIND PEAKS
[pks,x_values,w,p]=findpeaks(-amplitude_smooth, lambda, 'minPeakProminence',4,'Annotate','extents');

% plot spectrum with peaks
figure;
plot (x_values*1e6, interp1(lambda, amplitude, x_values,'pchip'), 'ro','MarkerSize',10); 
hold all;
plot (lambda*1e6, amplitude_smooth);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with peaks)');

% Calculate and plot ng data points from FSR
lambda_ng = (x_values(1:end-1)+x_values(2:end))/2;
FSR=(x_values(2:end)-x_values(1:end-1));
ng = abs(lambda_ng.^2/1/(dL*1e-6)./FSR);
% find average ng from all reasonable ng values:
indexes = find(gt(ng,3)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
indexes = find(lt(ng,5)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
ng_av = mean(ng);
if eq(length(ng),0)
  disp ('No group index values found.  Terminating script.');
  break
end
disp (['(estimate) Group index: ' num2str(ng_av)])

% plot FSR
figure;
plot (lambda_ng*1e6, FSR*1e9, '-o','LineWidth',1,'MarkerSize',7 );
xlabel ('Wavelength [\mum]')
ylabel ('Free Spectral Range [nm]')
xlim([min(lambda), max(lambda)]*1e6);
title ('Free Spectral Range, from Experimental data');

% plot ng
figure
plot (lambda_ng*1e6, ng, '-o','LineWidth',1,'MarkerSize',7 )
xlabel ('Wavelength [\mum]')
ylabel ('Group Index')
xlim([min(lambda), max(lambda)]*1e6);
title ('Waveguide Group Index, from Experimental data');


% find starting point for curve fitting MZI, using the ng data
% Part 1 - n1
% lambda0 is in microns.
lambda0 = x_values(floor(length(x_values)/2)) * 1e6;
n1_initial=2.4;
modeNumber = n1_initial * dL / lambda0 - 0.5;
n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
% Part 1 - n2 from ng_av
n2 = (n1-ng_av)/lambda0;
% Part 3 - n3 from slope of ng vs. lambda, to get the dispersion
f_line = @(x,xdata)x(2)*xdata+x(1);
[xfit,resnorm]  = lsqcurvefit(f_line,[ng_av 0],lambda_ng*1e6,ng);
r=corrcoef(ng,f_line(xfit, lambda_ng*1e6));
r2_ng=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2_ng)] )
hold all;
plot (lambda_ng*1e6, f_line(xfit, lambda_ng*1e6),'LineWidth',3)
n3 = -xfit(2)/2/lambda0;
Dispersion0 = -(lambda0*1e-6) / 299792458 * 2* (n3*1e12) * 1e12 /1e9 /1e-3;     	
disp (['(estimate from ng slope) Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
if lt(r2_ng,0.01)   % only use the result if the fit is good
  n3 = 0;
end

% Initial conditions for fitting:
nx_init = [n1 n2 n3];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];

	
% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'-','LineWidth',2);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  disp (['Waveguide parameters at wavelength [um]: ' num2str(lambda0)])
  ng0 = xfit(1) - lambda0*xfit(2);
  disp (['Group index: ' num2str(ng0)])

  % Dispersion:
  c=299792458;	
  Dispersion0 = -(lambda0*1e-6) / c * 2* (xfit(3)*1e12);  % [s/m^2]
  % [ps/nm/km]: 
  Dispersion0 = Dispersion0 * 1e12 /1e9 /1e-3;
  disp (['Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
  
  
end
      



        %%
		
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');

      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  
Note that two data file examples are provided. Note that the ∆L path length difference must be correctly set.



      %%    
      
      





% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

%url = 'https://www.dropbox.com/s/zojmleq3gu77dsw/ZiheGao_MZI17_265_Scan1.mat?dl=1';
%dL = 219.366;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find ng from autocorrelation-based frequency estimation of spectrum
% auto-correction
[r,lags]=xcorr(amplitude); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
figure
plot(lags,r);
% estimate the frequency
d=diff(r);
start = find(gt(d,0)); start=start(1);
[peak_m, peak_i]=max(r(start:end));
peak_i=peak_i+start;  % location of the 1st peak in the autocorrelation
hold on;
plot(peak_i,0,'s','MarkerSize',20);
title ('Autocorrelation of spectrum')
xlabel('lag, sample number');

fsr = peak_i * mean(diff(lambda))
ng_av = mean(lambda)^2/(dL*1e-6)/fsr


% find starting point for curve fitting, using the ng value
% lambda0 is in microns.
lambda0 = mean(lambda) * 1e6;
n1=2.4;
%modeNumber = n1_initial * dL / lambda0 - 0.5;
%n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
n2 = (n1-ng_av)/lambda0;
nx_init = [n1 n2 0];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Autocorrelation again, to find the shift between the fit function and experimental data
[r,lags]=xcorr(amplitude, T_MZI(x0, lambda*1e6)); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
[peak_m, peak_i]=max(r);
lambda_offset = peak_i(1) * mean(diff(lambda));
n_shift = lambda_offset*lambda0/fsr/dL;
x0(1)=x0(1)+n_shift;

figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters, with shift)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem






      %%    
      
      







        %%
   
        
      



Could not parse problem

Cut-back method, Spiral waveguide (TM) Loss, at 1550 nm is = 6.6 dB/cm 
Test structure for spiral waveguides, TM polarization

Use the Matlab code below to download, plot, and analyze the measurement data for waveguide propagation loss for the TM polarization.  The data is for two TM grating couplers, and spirals of length 0, 0.5, 1.0, 3.0 cm.  The GDS file for the layout used for this experiment is EBeam_lukasc_WGLoss_TM.gds.
  
Note that you can download and run this Matlab file, lukasc_spiralWG.m.  If you have the Statistics Toolbox, the program will generate an error estimation.  In the following graph, the shaded region corresponds to the 95% confidence interval.




Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the Loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess Loss of about 10 dB.  For example,
% if the DUT is estimated to have an Loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the Loss, we plot the measured Loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the Loss for one DUT.

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'Spiral waveguide (TM)';
% At what wavelength do you want to find out the Loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'LukasC_SpiralWG0kTM_1293.mat', ...
    'LukasC_SpiralWG5kTM_1296.mat', ...
    'LukasC_SpiralWG10kTM_1294.mat', ...
    'LukasC_SpiralWG30kTM_1295.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 0, 0.5, 1.0, 3.0 ];
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/anlo8zmydrji1f8/LukasC_SpiralWG0kTM_1293.mat', ...
        'https://www.dropbox.com/s/yvdfgl8qoq3d0fz/LukasC_SpiralWG5kTM_1296.mat', ...
        'https://www.dropbox.com/s/rossgslht5r5cq7/LukasC_SpiralWG10kTM_1294.mat', ...
        'https://www.dropbox.com/s/vj4uf6u59h9vt60/LukasC_SpiralWG30kTM_1295.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength (nm)');
ylabel ('Optical Power (dBm)');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the Loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the Loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Waveguide length (cm)');
ylabel ('Loss (dB/cm)');
title (['Cut-back method, ' deviceName ' Loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    a=annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    set(a,'FontSize',FONTSIZE);
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/cm'])
end



% wavelength dependance of the DUT Loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Loss, 95% Confidence Interval', ...
        'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' Loss, wavelength dependance'] )
ylabel ('Loss (dB/cm)');
xlabel ('Wavelength (nm)');
set(gca,'FontSize',FONTSIZE)
     
           
      



        %%
   
        
      



Could not parse problem

Cut-back method, Spiral waveguide (TE) Loss, at 1550 nm is = 11 dB/cm 
Test structure for spiral waveguides, TE polarization

Use the Matlab code below to download, plot, and analyze the measurement data for waveguide propagation loss for the TE polarization.  The data is for two TM grating couplers, and spirals of length 0, 0.5, 1.0, 3.0 cm.  The GDS file for the layout used for this experiment is EBeam_lukasc_WGLoss_TE.gds.
  

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the Loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess Loss of about 10 dB.  For example,
% if the DUT is estimated to have an Loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the Loss, we plot the measured Loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the Loss for one DUT.

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'Spiral waveguide (TE)';
% At what wavelength do you want to find out the Loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'LukasC_SpiralWG0kTE_1297.mat', ...
    'LukasC_SpiralWG5kTE_1300.mat', ...
    'LukasC_SpiralWG10kTE_1298.mat', ...
    'LukasC_SpiralWG30kTE_1299.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 0, 0.5, 1.0, 3.0 ];
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/1v5wzon5nexggn6/LukasC_SpiralWG0kTE_1297.mat', ...
        'https://www.dropbox.com/s/7r8svd1ukjae8ox/LukasC_SpiralWG5kTE_1300.mat', ...
        'https://www.dropbox.com/s/kfsv1yeghue0i38/LukasC_SpiralWG10kTE_1298.mat', ...
        'https://www.dropbox.com/s/5o66l3xd7rnxtgq/LukasC_SpiralWG30kTE_1299.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength (nm)');
ylabel ('Optical Power (dBm)');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the Loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the Loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Waveguide length (cm)');
ylabel ('Loss (dB/cm)');
title (['Cut-back method, ' deviceName ' Loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    a=annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    set(a,'FontSize',FONTSIZE);
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/cm'])
end



% wavelength dependance of the DUT Loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Loss, 95% Confidence Interval', ...
        'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' Loss, wavelength dependance'] )
ylabel ('Loss (dB/cm)');
xlabel ('Wavelength (nm)');
set(gca,'FontSize',FONTSIZE)
     
                 
      



        %%
   
        
      



Could not parse problem



Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 


Could not parse problem

Unbalanced MZI Interferometer, TM polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TM_1550_device_LukasChrostowski_MZI_TM_oneside". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.03]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.03]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TM_oneside.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.02]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100; within an accuracy of +/- 2 %]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/lukasc_TETM_simVSexp.zip  




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
Follow the Convergence Tests section, in Waveguide Modelling - Lumerical MODE
The TM layout used a bend radius of 10 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of lambda_min=1.54e-6; lambda_max=1.56e-6.
     


Could not parse problem

Unbalanced MZI Interferometer, TE polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TE_1550_device_LukasChrostowski_MZI_TE_oneside2". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.02]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.02]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.02]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.02]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TE_oneside2.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.04]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100 percent; within an accuracy of +/- 2 (%)]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/lukasc_TETM_simVSexp.zip 




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
The TE layout used a bend radius of 5 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of          lambda_min=1.543e-6; lambda_max=1.557e-6.
     


Could not parse problem


  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 




      %%    
      
      







        %%
      



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
Query done.
Processed: 5.8 MB

Retrieving results...
Got 6385 rows.

Total time taken 5.69 s.
Finished at 2017-06-30 20:32:46.
Saved to ./../data/Phot1x_1T2017/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
Query done.
Processed: 248.2 MB

Retrieving results...
Got 139 rows.

Total time taken 5.24 s.
Finished at 2017-06-30 20:32:53.
Saved to ./../data/Phot1x_1T2017/open_assessment.csv
Requesting query... ok.
Query running...
Query done.
Processed: 232.9 MB

Retrieving results...
  Got page: 1; 11% done. Elapsed 15.7 s.
  Got page: 2; 22% done. Elapsed 20.56 s.
  Got page: 3; 34% done. Elapsed 26.36 s.
  Got page: 4; 45% done. Elapsed 31.8 s.
  Got page: 5; 56% done. Elapsed 37.45 s.
  Got page: 6; 67% done. Elapsed 44.43 s.
  Got page: 7; 78% done. Elapsed 50.92 s.
  Got page: 8; 89% done. Elapsed 55.6 s.
  Got page: 9; 100% done. Elapsed 60.66 s.
Got 208692 rows.

Total time taken 69.98 s.
Finished at 2017-06-30 20:34:04.
Saved to ./../data/Phot1x_1T2017/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 10.6 KB

Retrieving results...
Got 155 rows.

Total time taken 0.73 s.
Finished at 2017-06-30 20:34:10.
Saved to ./../data/Phot1x_1T2017/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 18.5 KB

Retrieving results...
Got 102 rows.

Total time taken 1.33 s.
Finished at 2017-06-30 20:34:13.
Saved to ./../data/Phot1x_1T2017/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 315.9 KB

Retrieving results...
Got 801 rows.

Total time taken 1.47 s.
Finished at 2017-06-30 20:34:16.
Saved to ./../data/Phot1x_1T2017/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 261.0 KB

Retrieving results...
Got 32 rows.

Total time taken 1.21 s.
Finished at 2017-06-30 20:34:18.
Saved to ./../data/Phot1x_1T2017/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 829.0 KB

Retrieving results...
Got 6163 rows.

Total time taken 2.2 s.
Finished at 2017-06-30 20:34:22.
Saved to ./../data/Phot1x_1T2017/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 86.6 KB

Retrieving results...
Got 826 rows.

Total time taken 4.8 s.
Finished at 2017-06-30 20:34:28.
Saved to ./../data/Phot1x_1T2017/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 79.6 MB

Retrieving results...
Got 9744 rows.

Total time taken 3.3 s.
Finished at 2017-06-30 20:34:32.
Saved to ./../data/Phot1x_1T2017/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 274.2 KB

Retrieving results...
Got 826 rows.

Total time taken 1.08 s.
Finished at 2017-06-30 20:34:35.
Saved to ./../data/Phot1x_1T2017/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 210.1 MB

Retrieving results...
Got 1127 rows.

Total time taken 2.56 s.
Finished at 2017-06-30 20:34:38.
Saved to ./../data/Phot1x_1T2017/external_link_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 52.0 MB

Retrieving results...
  Got page: 1; 20% done. Elapsed 12.79 s.
  Got page: 2; 41% done. Elapsed 18.61 s.
  Got page: 3; 62% done. Elapsed 23.51 s.
  Got page: 4; 82% done. Elapsed 28.44 s.
  Got page: 5; 100% done. Elapsed 34.4 s.
Got 241371 rows.

Total time taken 39.08 s.
Finished at 2017-06-30 20:35:19.
Saved to ./../data/Phot1x_1T2017/page_dirt.csv
Could not parse problem


Click "run" to execute the code.  



      %%    
      
      



a=1
b=2
c=a+b
        
% Practice figures:        
x=1:0.1:10;
figure; plot (x, sin(x)); title ('The First figure');
figure; plot (x, exp(x)); title ('The Second figure');
        
      



%%     
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem




The thickness of the silicon layer in the SOI wafer is a very important parameter when designing silicon photonic components.  
What is the most common silicon thickness used by the silicon photonic foundries? [units: nm]





Explanation
220 nm. We will discuss and simulate the reason behind this choice next.



Could not parse problem




Consider a silicon photonic chip operating over a wide range of temperatures (e.g., in a data centre), and operating over a wide range of wavelengths (e.g., using wavelength division multiplexing, WDM). The waveguide consists of a Si core, and SiO2 cladding; assume that the light is travelling 100% in silicon (we will later see this is not the case). 
If the wavelength changes by 100 nm, by what percentage (absolute value) will the index change? [Answer 0-100, Units: %, Accuracy +/- 0.1]




If the temperature changes by 100 C, by what percentage will the index change? [Answer 0-100, Units: %, Accuracy +/- 0.1]






Explanation
For a 100 nm change in wavelength: abs ( 100 nm * (-7.6e-5 /nm)  / 3.47 * 100 ) = 0.21 %
For a 100 C change in temperature, but only considering dn_Si / dT: abs ( 100 nm * ( 1.87e-4 /K )  / 3.47 * 100 ) = 0.54 %.   



A change of temperature of ∆T = 100 C is the same as a change of ∆T = 100 K. 
Use the parameters provided on slide #12. 


Could not parse problem




 Which of the following is the largest in a dielectric waveguide?





Explanation
 A pulse of light, and information, travels at the group velocity, which is slower than the speed of light in the material (phase velocity).



Could not parse problem


You can use this MATLAB window to perform the calculations necessary for the problems.
  

      Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.


  



      %%    
      
      


        
format long;  % display many significant digits; optional

delta_T = 10;
Thermal_coefficient = 0.01;  % replace with correct value
delta_n = Thermal_coefficient * delta_T
        
      



        %%
   
        
      



Could not parse problem




Consider a Si/SiO2 waveguide, and assume that the light is travelling as follows: 90% in silicon, and 10% in silicon dioxide.  Assume the mode profile does not change in the following questions:
Q1: If the wavelength increases by 10 nm, by how much will the effective index change?




Q2: If the temperature increases by 10 C, by how much will the effective index change?




Q3: Let's find out if we can ignore the temperature dependance of SiO2 in our models.  Repeat the above Q2 calculation, this time assuming a constant SiO2 material model.  How much error would be introduced in the change in effective index versus temperature, if a constant SiO2 material model was used? (answer in %) 
 \( \% error = \frac{\text{Correct}-\text{Incorrect}}{\text{Correct}} \cdot 100 \)






Explanation
For a 10 nm change in wavelength: 10 nm * ( 0.9 * -7.6e-5 /nm + 0.1 * -1.2e-5 /nm ) = -6.96e-4
For a 10 C change in temperature: 10 K * ( 0.9 * 1.87e-4 /K + 0.1 * 8.5e-6 /K ) = 1.6915e-3
For a 10 C change in temperature, but only considering dn_Si / dT, 10 nm * ( 0.9 * 1.87e-4 /K ) = 1.683e-4.  Hence, the error is: 
(1.6915-1.683) / (1.6915) = 0.00502, or 0.5%



For the effective index, in Q1-3, approximate this as a weighted average of the refractive index values in each medium. 
For Q3: Modify your equation in Q2 to assume that there is no temperature dependence in the SiO2.  Note that 10% of the light is still in the SiO2, and 90% is in silicon. 
For Q3, the answer is a number.  Don't include the % symbol in the answer. 


Could not parse problem




Consider a silicon photonic slab waveguide consisting of a thin layer of silicon (with index 3.47), with thickness t, surrounded by an infinite amount of silicon dioxide (with index of 1.44).
Consider the fundamental mode (TE0).  For a thickness t=220 nm, the effective index is 2.8. 
What value does the effective index approach as t gets close to 0 nm (very thin slab waveguide)? [Ans +/- 0.1]




What value does the effective index approach as t approaches infinity (very thick slab waveguide)? [Ans +/- 0.1]






Explanation
In a very thin slab waveguide, the light is mostly in the silicon dioxide, hence the index approaches 1.44.
In a very thick slab waveguide, the light is mostly in the silicon, hence the index approaches 3.47.



Could not parse problem




In this exercise, we wish to understand why the wafers we are using have a thickness of 220 nm. 
 You can use the analytic method with the script provided below (in MATLAB) to answer this question (Note: you do need to understand the details of this script, just use it as a tool).  
  
You can download the script (wg_1D_slab.m). 
What is the maximum Si thickness before the slab waveguide supports more than one TE mode? Enter the thickness [Units: nm, accuracy +/-5 nm]:






Explanation




Use the Matlab code below.  You can do this problem by trial and error, with your own iterations.  
Change the thickness of the waveguide -- the default is 0.22e-6 m.  You will see that nTE = xxxx: namely it supports a single mode.  Try increasing it, say to 0.5e-6.  You will see that nTE = xxxx, xxxx, xxx: namely it supports multiple (3) modes.  Find the value where the 2nd mode just disappears.  
You could also make a script with a "for" loop, and plot the number of modes versus the thickness.  The number of modes would be found by the command length(nTE).  


Could not parse problem





Use the following Matlab code to answer the question on slab waveguides.
  
To change the thickness, change the number 220e-9 in the following line: 



thickness=220e-9;     %%% thickness of the silicon layer, [units: m]
  



The default is to plot the E-field for the TE polarization. You may also view the field profile for the TM polarization.
  

Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% MATLAB Script to solve for the modes of the slab waveguide,
% calculate the effective indices
% plot the E-field profile for all the modes
% the user provides:
%  - thickness of the silicon layer
%  - desired polarization to plot

function main
	thickness=220e-9;     %%% thickness of the silicon layer, [units: m]
	polarization = 'TM';  %%% polarization, 'TE' or 'TM'

	[x, TE_E, TE_H, TM_E, TM_H, nTE, nTM] = wg_1D_mode_profile ...
		(1.55e-6, thickness, 1.444, 3.47, 1.444, 100, 3);

	figure;
	g=rectangle('Position',[-thickness*1e9/2,-1,thickness*1e9,2],'FaceColor',[.8 .8 .8 0.2]); hold all;
	if polarization=='TE'       
		plot (x*1e9, TE_E/max(max(TE_E)), 'LineWidth',3);
		title('TE polarized mode(s)');
	else
		plot (x*1e9, TM_E/max(max(TM_E)), 'LineWidth',3);
		title('TM polarized mode(s)');
	end
	xlabel('Position - perpendicular to wafer [nm]');
	ylabel('E-Field Amplitude');
	ax=gca;
	set(ax, 'FontSize',15);
%	ax.XTick = [floor(min(x)*1e9/100)*100:200:floor(max(x)*1e9/100)*100];
	axis tight;
	grid on; box on;

	disp(['Effective index value(s) of the TE mode(s):  ' sprintf('%g  ',nTE)])
	disp(['Effective index value(s) of the TM mode(s):  ' sprintf('%g  ',nTM)])


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
% wg_1D_mode_profile.m - Calculate the 1D mode profile of a slab waveguide
% by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3.2
% - function returns mode profiles for TE and TM modes (E, H components)
% usage, e.g.:
%  [x, TE_E, TE_H, TM_E, TM_H, nTE, nTM] = wg_1D_mode_profile (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444, 100, 4)
%  plot (x, TE_E); 
%  plot (x, TM_E); 
% lambda: wavelength [units m]
% t: thickness of the waveguide core [units m]
% n1: index of refraction of the cladding (layer 1)
% n2: index of refraction of the core (layer 2)
% n3: index of refraction of the cladding (layer 3)
% pts: number of points in the field profile plot
% M: number of modes to calculate
function [x, TE_E, TE_H, TM_E, TM_H, nTE, nTM]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
	x1=linspace( -M*t, -t/2, pts); x2=linspace( -t/2, t/2, pts); 
	x3=linspace( t/2, M*t, pts); x=[x1 x2 x3];
	nx=[n1*ones(pts,1); n2*ones(pts,1); n3*ones(pts,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% wg_1D_analytic.m - Analytic solution of a slab waveguide
% by Lumerical Solutions, http://www.lumerical.com/mode_online_help/slab_wg.m
% modified by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3
% finds the TE and TM effective indices of a 3-layer slab waveguide

% usage:
%  - get effective indices for supported modes:
%  [nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
%  - optional, for plotting: TEparam,TMparam: h, q, p parameters of the mode.

% lambda: wavelength [units m]
% t: thickness of the waveguide core [units m]
% n1: index of refraction of the cladding (layer 1)
% n2: index of refraction of the core (layer 2)
% n3: index of refraction of the cladding (layer 3)

function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);     
      
      



        %%
   
        
      



Could not parse problem


Use the following Matlab code to answer the question on slab waveguides.
  
To change the thickness, change the number 0.22e-6 in the following line: 



[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
  



Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_analytic.m - Analytic solution of a slab waveguide
% by Lumerical Solutions, http://www.lumerical.com/mode_online_help/slab_wg.m
% modified by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3
% finds the TE and TM effective indices of a 3-layer slab waveguide

% usage:
%  - get effective indices for supported modes:
%  [nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
%  - optional, for plotting: TEparam,TMparam: h, q, p parameters of the mode.


function main
	[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
      



        %%
   
        
      



Could not parse problem




 We know that some of the light is travelling outside the waveguide.  This is an important concept to understand as it has several implications: 
  It leads to the concept of waveguide dispersion, and has a huge impact on the group index, \( n_g \) The field outside the waveguide can be used to make evanescent field sensors, e.g., bio applications.  (Note - replace SiO2 with air, water, etc, for biosensors) 
  Hence, we wish to study how far the fields extend above the waveguides.  We consider the two polarizations (TE, TM) guided by the 220 nm slab waveguide. 
          Question - For the TE polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point (of the value at the interface):




Question - For the TM polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point:






Explanation
TE Polarization:

Measure the field at the interface.
Find the 1/e point.  If the field is 0.66 at the interface, take 0.66 / e = 0.66 / 2.71 = 0.243.  Find the x value for this point, which is approximately 200 nm.
Measure the distance from the interface: 200-110 = 90 nm.

TM Polarization:

The MATLAB code needs to be motified to plot TM_E (the E-field for the TM polarization) instead of TE_E (the E-field for the TM polarization)
Measure the field at the interface.
find the 1/e point.  if the field is 0.77 at the interface, take 0.77 / e = 0.28.  Find the x value for this point, which is approximately 280 nm.
measure the distance from the interface: 280-110 = 170 nm.




Could not parse problem

You can run the MATLAB code provided in the web browser below.  Or, you can download the code and run it directly on your computer (wg_1D_mode_profile_main.m)
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_mode_profile.m - Calculate the 1D mode profile of a slab waveguide
% by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3.2
% - function returns mode profiles for TE and TM modes (E, H components)
% usage, e.g.:
%  [x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444, 100, 4)
%  plot (x, TE_E); 
%  plot (x, TM_E); 



function main
	thickness=0.22e-6;  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	[x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile ...
		(1.55e-6, thickness, 1.444, 3.47, 1.444, 100, 3);
	g=rectangle('Position',[-thickness*1e9/2,0,thickness*1e9,1],'FaceColor',[.8 .8 .8 0.2]); hold all;
	plot (x*1e9, TE_E/max(max(TE_E)), 'LineWidth',3);
	xlabel('Position [nm]');
	ylabel('Field Amplitude');
	ax=gca;
	set(ax, 'FontSize',15);
	ax.XTick = [floor(min(x)*1e9/100)*100:200:floor(max(x)*1e9/100)*100];
	axis tight;
	grid on; box on;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
	x1=linspace( -M*t, -t/2, pts); x2=linspace( -t/2, t/2, pts); 
	x3=linspace( t/2, M*t, pts); x=[x1 x2 x3];
	nx=[n1*ones(pts,1); n2*ones(pts,1); n3*ones(pts,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);     
      



        %%
   
        
      



Could not parse problem




Simulation results for the strip waveguide, fundamental TE polarization, show that the effective index decreases with increasing wavelength.
What is the main reason that the waveguide's effective index decreases for a longer wavelength?





Explanation
Both Material and Waveguide dispersion contribute.  However, material dispersion accounts for a small portion of the total dispersion; recall that the group index of silicon is ~3.6, which is ~0.1 higher than the refractive index of silicon (n_Si).  In contrast, the group index for the waveguide is ~4.2, which is ~0.7 higher than n_Si.  If one was to simulate the waveguide without material dispersion (setting n_Si = 3.47, a constant), one would find that the group index is ~0.6 higher than the n_Si.  Thus, the waveguide dispersion is the dominant effect.
To get an intuitive understanding, simulate the mode for different wavelengths.  You will see that the mode is more spread out for longer wavelengths.  
Intuitively, more light is travelling through the lower index cladding for longer wavelengths.  The effective index can be thought of as a weighted average of the material indices, based on the mode profile.  Hence, less light in the silicon core for longer wavelengths leads to a lower effective index.



Could not parse problem




Simulation results for the strip waveguide show that the effective index increases with increasing geometry (width or thickness).
What is the main reason that the waveguide's effective index increases with width?





Explanation
The answer is similar to waveguide dispersion described above.  
To get an intuitive understanding, simulate the mode for different geometries.  You will see that the mode is more spread out for smaller waveguides with tails extending into the cladding.  In contrast, larger waveguides have more light inside the core.  
Hence, for larger geometries, more light in the silicon core, and this leads to a higher effective index.



Could not parse problem




Optical waveguides suffer from loss from a variety of sources.  
What is the dominant optical loss mechanism in a 500 nm wide strip waveguide, for a quasi-TE mode at 1550 nm?





Explanation
All of these mechanisms can contribute to optical loss in waveguides.
Absorption due to nearby metal is possible if there is metal in the process, and if it is close enough (e.g., less than 1 µm away)
Silicon material absorption is negligeable
Silicon dioxide material absorption becomes significant for wavelengths longer than ~3.0 µm
Surface-state absorption is possible, if the waveguides are not passivated, and is a contributing factor.
Side-wall roughness scattering is the dominant mechanism.
Top-of-waveguide roughness scattering is present, however, this interface is created during the wafer manufacturing process.  Smoothing steps are taken to ensure an exceptionally smooth surface.



Could not parse problem




Using the Effective Index Method, find the fundamental TE mode effective index at 1500 nm.
n_eff: Effective index of the waveguide:






Explanation
Change the wavelength in the code...  The first parameter is wavelength, in: wg_EIM_profile (1.50e-6, ...
Run the matlab code.
See the effective index displayed.



Could not parse problem


Use the Matlab code below (Effective Index Method, field profile) to view the field profile for a 500 x 220 nm waveguide.
  
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_EIM_profile.m - Effective Index Method - mode profile
% Lukas Chrostowski, 2012
% usage, e.g.:
%  wg_EIM_profile (1.55e-6, 0.22e-6, 0.5e-6, 90e-9, 3.47, 1, 1.44, 100, 2)

function main
	[neff_TEwg]=wg_EIM_profile (1.60e-6, 0.22e-6, 0.5e-6, 0, 3.47, 1.44, 1.44, 100, 2)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [neff_TEwg]=wg_EIM_profile (lambda, t, w, t_slab, n_core, n_clad, n_oxide, pts, M)

	% find TE (TM) modes of slab waveguide (waveguide core and slab portions):
	[nTE,nTM]=wg_1D_analytic (lambda, t, n_oxide, n_core, n_clad);
	if gt(t_slab,0)
		[nTE_slab,nTM_slab]=wg_1D_analytic (lambda, t_slab, n_oxide, n_core, n_clad);
	else
		nTE_slab=n_clad; nTM_slab=n_clad;
	end
	[xslab,TE_Eslab,TE_Hslab,TM_Eslab,TM_Hslab]=wg_1D_mode_profile (lambda, t, n_oxide, n_core, n_clad, pts, M);

	figure%(1);  clf; subplot (2,2,2); 
    Fontsize=15;
	plot(TE_Eslab/max(max(TE_Eslab)),xslab*1e9,'LineWidth',4);hold all;
	ylabel('Height [nm]','FontSize',Fontsize); 
	xlabel({' ','E-field (TE)'},'FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize,'XTick',[]);
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);
	Ax1 = gca; Ax2 = axes('Position',get(Ax1,'Position'));
	get(Ax1,'Position');
    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
	plot (nx, xslab*1e9,  'LineWidth',0.5,'LineStyle','--','parent',Ax2); 
	a2=axis; axis ([a2(1), a2(2), a(3), a(4)]);
	set(Ax2,'Color','none','XAxisLocation','top', 'YTick',[],'TickDir','in'); 
	set(gca,'YAxisLocation','right'); box off;
	xlabel('Material Index','FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize); 
%    print -dpdf eim1.pdf

	% TE-like modes of the etched waveguide (for fundamental slab mode)
	%   solve for the "TM" modes:
	[nTE,nTM]=wg_1D_analytic (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1));
	neff_TEwg=nTM;
	[xwg,TE_E_TEwg,TE_H_TEwg,TM_E_TEwg,TM_H_TEwg]=wg_1D_mode_profile (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1), pts, M);

    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
    figure%(1); subplot (2,2,3);
    % Plot the data on with a left and right axes. Return the axes and line
    % objects.
    [ax, h1, h2] = plotyy(xwg*1e9, TM_E_TEwg(:,1)/max(max(TM_E_TEwg)), xwg*1e9, nx);
    % Set the Xlabel and yLabel of each axes
    xlabel('Position [nm]','FontSize',Fontsize);
    ylabel(ax(1),'E-field (TM, TE-like mode)','FontSize',Fontsize);
    ylabel(ax(2), 'Slab Effective Index','FontSize',Fontsize);
    % Change the color of the right axes and the line style of line plot
    % associated with that axes.
    ax(2).YColor = 'b';
    h2.LineStyle = '--';
    h2.LineWidth = 0.5;
    h2.Color = 'b';
    % Set the Line width of the two line plots of the left axes.
    h1(1).LineWidth = 4;
    % Remove the left Tick labels.
    ax(1).YTick = [];
    % Set the YLim property so the plots line up.
    ax(2).YLim = [1.4, 2.6];
    ax(2).YTick = 1.4:0.2:2.6;
    
    % Plot the product of the two fields
	figure%(1); subplot (2,2,1);
	Exy=TM_E_TEwg(:,1)*(TE_Eslab(1,:));
	contourf(xwg*1e9,xslab*1e9,abs(Exy')/max(max(Exy))')
    % colormap('jet')
    axis equal
	xlabel ('X (nm)','FontSize',Fontsize); 
	ylabel ('Y (nm)','FontSize',Fontsize); 
	set (gca, 'FontSize',Fontsize); 
	A=axis; axis([A(1)+0.4, A(2)-0.4, A(3)+.2, A(4)-0.2]);
	title('Effective Index Method');
	% Draw the waveguide:
	rectangle ('Position',[-w/2,-t/2,w,t]*1e9, 'LineWidth',1, 'EdgeColor','white')
	if gt(t_slab,0)
		rectangle ('Position',[-M*w,-t/2,(M-0.5)*w, t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
		rectangle ('Position',[w/2,-t/2,(M-0.5),t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
    end

    
function draw_WG_vertical(M)
	pP=get(gca,'Position');pPw=pP(3); 
	pPc=pP(3)/2+pP(1); pP2=pPw/4/M;
	annotation ('line',[pPc-pP2,pPc-pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	annotation ('line',[pPc+pP2,pPc+pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	axis tight; a=axis; axis ([a(1), a(2), a(3)*1.1, a(4)*1.1]);

function draw_WG_horiz(M)
	pP=get(gca,'Position');pPw=pP(4); 
	pPc=pP(4)/2+pP(2); pP2=pPw/4/M;
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc-pP2,pPc-pP2],'LineStyle','--');
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc+pP2,pPc+pP2],'LineStyle','--');
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
    x1=linspace( -M*t, -t/2, pts); 
    x2=linspace( -t/2, t/2, pts); x2 = x2(2:end);
    x3=linspace( t/2, M*t, pts);  x3 = x3(2:end);
    x=[x1 x2 x3];
    nx=[n1*ones(pts,1); n2*ones(pts-1,1); n3*ones(pts-1,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
			     
      



        %%
   
        
      



Could not parse problem




Part 1

Using this tool, compute the mode profile and calculate the effective index of the fundamental TE mode for a 450x220 nm waveguide at 1550 nm.
    
Note:  This is a graded code box.  When ready, press "CHECK". After your code executes, additional code on the server will check your answer.  
  
Download script:  Phot1x_wg_2D_matlab.m



      %%    
      global neff
      



% This example computes the field components and the effective index of a
% silicon-on-insulator strip waveguide.
% slightly modified version, from: http://www.photonics.umd.edu/software/wgmodes/
function [neff]=main

	global neff w  % Used by the auto-graded to check your answer.

	n1 = 1.44;          % SiO2 lower cladding
	n2 = 3.47;          % Silicon core
	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 2.5;           % grid size (x)
	dy = dx;            % grid size (y)

	lambda = 1550;      % wavelength (nm)
	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

	fprintf (1,'post-processing... '); t = cputime;

	[Hz,Ex,Ey,Ez] = postprocess (lambda, neff, Hx, Hy, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf (1,'graphing... '); t = cputime;

	hn = abs(interp2(y,x,Hy,h1+h2/2,0));
	en = abs(interp2(yc,xc,Ex,h1+h2/2,min(dx)/2));

	% Plot |E| profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,sqrt(abs([-Ex(end:-1:1,:);Ex]).^2+abs([-Ey(end:-1:1,:);Ey]).^2+abs([-Ez(end:-1:1,:);Ez]).^2)/en);
	title('|E|');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% could normalize the |E| plot to show energy...
	%size (eps)

	% figure;
	% imagemode(x,y,Hx/hn);
	% title('Hx');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hy/hn);
	% title('Hy');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hz/hn);
	% title('Hz');
	% for v = edges, line(v{:}); end

	% Plot Ex profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,[-Ex(end:-1:1,:);Ex]/en);
	hold on;
	contourmode([-xc(end:-1:1);xc],yc,[-Ex(end:-1:1,:);Ex]/en,(0:-5:-60));
	title('Ex');
	v = xlim();
	line(v,[h1,h1], 'Color', 'k');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% figure;
	% imagemode(x,y,Ey/en);
	% title('Ey');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Ez/en);
	% title('Ez');
	% for v = edges, line(v{:}); end
	
	% figure;
	% imagemode(x,y,sqrt(abs(Ez).^2+abs(Ey).^2+abs(Ex).^2)/en);
	% title('|E|');
	% for v = edges, line(v{:}); end

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

end

function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end

      

	  % Change the width of the waveguide to 450 nm, via the following variable on line 22:
      w = 450;
	  

        %%
      global neff w
	  ansVar=2.34749;
	  var=neff;
	  assert(all(lt(abs(w-450), 2e-3)), 'Please find the effective index for a waveguide with w=450.')
	  assert(all(lt(abs(ansVar-var), 2e-3)), 'Incorrect answer.  Please double-check that you are solving for the effective index for a waveguide with width of w=450.  Also check that your simulations have converged and are accurate.  The tolerance on this checker is 2e-3.')
		
      



Could not parse problem




Part 2

Calculate and plot the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide.
    
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  
Download script:  Phot1x_wg_2D_sweep_matlab.m



      %%    
      global neff
      



function main

	% Example wavelength sweep parameters with refractive indices:
	global lambdas % for the auto-grader
	lambdas = [1500, 1525, 1550, 1575, 1600]; 
	n1s = [1.444, 1.444, 1.444, 1.444, 1.444];  % Silicon dioxide index of refraction
	n2s = [3.47998, 3.47768, 3.4755, 3.47344, 3.47147]; % Silicon index of refraction

	% Perform effective index calculations
	global neffs % for the auto-grader
	neffs=[]; % initialize empty matrix to store effective index values.
	for i=1:length(lambdas)
		neffs(end+1) = wgmodes_neff(lambdas(i), n1s(i), n2s(i));
	end

	% plot effective index versus wavelength
	figure
	plot (lambdas, neffs)

	% calculate group index versus wavelength ...

end

function [neff]=wgmodes_neff(lambda, n1, n2)
	% inputs:
		% lambda - wavelength, in nm
		% n1 - SiO2 lower cladding
		% n2 - Silicon core

	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 5;           % grid size (x)
	dy = dx;            % grid size (y)

	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

end

% require the functions "wgmodes", "waveguidemesh", "stretchmesh", etc.


function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end


      

Copy and paste the WGMODE codes from the previous unit at the bottom of the above code block.  

Change the material index of refraction values.
	  

		%%
      



Could not parse problem




Perform numerical calculations for the following waveguide:



500 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm


TE polarization



Enter the effective index:






Explanation
To arrive at the correct answer, make sure you have done the following:
    Change the wavelength to 1550 nm.Follow the steps in the preceeding tutorial.
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




Perform numerical calculations for the following waveguide:


600 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm



TM polarization



Enter the effective index (within an accuracy of 0.02):






Explanation
To arrive at the correct answer, make sure you have done the following:
    Look at the 2nd mode, which should be TM polarized. The effective index is smaller than the TE mode.Change the wavelength to 1550 nm.Change the width of the waveguide to 600 nm.Increase the simulation region.  Check that the fields have decayed to 1e-9 (in energy).  This is achieved for an FDE simulation width of 3 micron, and height of 3.5 micron.  
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




The group index of the waveguide is a very important parameter, which as we will see, determines one of the most important features of the Mach-Zehnder Interferometer circuit -- the Free Spectral Range.
Find the group index for the following waveguide:



        500 nm width
      

        220 nm height
      

        silicon core
      

        oxide cladding
      

        wavelength = 1550 nm
      

        TM polarization (hint: this is the 2nd mode; the one with the TE polarization fraction (Ex) that is close to 0.)
      


Enter the group index:  (answer checked within +/- 0.03 of the instructor's answer)






Explanation
Make sure you make the following changes in the simulation:
  Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.Increase the number of simulation mesh points, e.g., 200.  Check the simulation mesh, and make sure it lines up with the waveguide edges.Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode. Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
If you are still not getting the same answer (but are "close"), continue on.  There is a unit "Convergence tests", which analyzes the sources of error in the simulations.




 Make sure you make the following changes in the simulation: 
 1) Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.   
 2) Increase the number of simulation mesh points, e.g., 200, or even more.  
 3) Check the simulation mesh, and make sure it lines up with the waveguide edges.  
 4) Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode.  
 5) Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
	  
If you are still not getting the same answer (but are "close"), continue on.  There is a later unit "Convergence tests", which analyzes the sources of error in the simulations.


Could not parse problem





Find a polynomial curve fit for the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide, in the 1500 to 1600 nm range.
    
 Note: when your run the code, the last plot is generated by the instructor's code. It allows you to compare your answer with the instructor's.
If you are using Dropbox, you need to change the link to replace dl=0 with dl=1.
Download the matlab script, Phot1x_fit_wg_compactmodel.m
 Note: This is a graded problem.  Click "CHECK" to verify your answer.



      %%    

disp('****************************************************')
disp('The following output is generated by the instructor:')
	  
% Check fit:
if exist('r2')
  if lt(r2,0.8)
    disp 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.'
  end
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
end


% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

if gt(abs(X(1)-X_lukas(1)),0.01)
  disp ('The X(1) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(2)-X_lukas(2)),0.01)
  disp('The X(2) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(3)-X_lukas(3)),0.01)
  disp('The X(3) parameter is more than 1% different than the instructor answer.')
end

      



% User provides a matrix of neff values vs. wavelength
% Matlab curve fits to an expression.

% example 1
% TM polarization for a 500 x 220 nm waveguide
% data was copy and pasted from Lumerical MODE to this script:
if (1) 
  neff = [ 1.83383800636377 + 8.05890497290360e-10i, 1.81907207440938 + 7.74616649077559e-10i, ...
           1.80449944644501 + 7.43420301068018e-10i, 1.79013738069386 + 7.12371827806454e-10i, ...
           1.77600267415464 + 6.81543437568018e-10i, 1.76211152154899 + 6.51008307756216e-10i, ...
           1.74847937779721 + 6.20839666142533e-10i, 1.73512082686004 + 5.91109842262606e-10i, ...
           1.72204945969007 + 5.61889315346028e-10i, 1.70927776383582 + 5.33245785940170e-10i];
  f = [ 199861638666667, 198473710620370, 197085782574074, 195697854527778, ...
       194309926481481, 192921998435185, 191534070388889,  190146142342593, ...
       188758214296296, 187370286250000];
end

% example 2
% TM polarization for a 500 x 220 nm waveguide
% data was saved as a MATLAB file, and is loaded
% this requires that you either have the file on the internet and use the "websave" command to access it
% (this is necessary if you are using the in-browser edX MATLAB)
% or run this script on your own computer and load the file from your local disk.
if (0)
  % url='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
  url='https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/wg-export-TM.mat'
  a=websave('wg.mat',url); % get data from Dropbox
  load('wg.mat');
end

neff = real(neff)  % take the real part of the effective index.

c=299792458;  % speed of light, m/s
lambdas = c ./ f;  % f is the matrix of frequency points, 
                   % where the effective index is recorded.
lambdas = lambdas * 1e6  % convert to microns.
lambda0 = 1.55;   % replace with desired centre wavelength

figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;

% use Matlab anonymous function for the effective index expression:
neff_eq = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 

% initial guess.
% The X matrix is defined as follows:  n1 = X(1), n2 = X(2), n3 = X(3)
X=[2.4 0 0]; 

plot ( lambdas, neff_eq(X, lambdas), 'r')

% curve fit to find expression for neff.
format long
X = lsqcurvefit (neff_eq, X, lambdas, neff);

disp (['n1 = ' num2str(X(1)) ', n2 = ' num2str(X(2)) ', n3 = ' num2str(X(3))]);

r=corrcoef(neff,neff_eq(X, lambdas));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

lambdas2=linspace(min(lambdas), max(lambdas), 100);

plot ( lambdas2, neff_eq(X, lambdas2), 'k')
xlabel ('Wavelength [nm]');
ylabel ('Effective Index');

legend ('Data','Initial Guess','Curve Fit')

      

If you don't have Dropbox, you can create the two variables to be used by the above code: neff, and lambdas.  Then proceed to curve fit this data, and compare to the instructor result.
	  

%%
% Grader:
%disp('****************************************************')
%disp('The following output is generated by the instructor:')

% Check:
if exist('url')
 url0='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
 assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
end
        
% Check fit:
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

% Check:
assert(lt(abs(X(1)-X_lukas(1)),0.01), 'The X(1) parameter is more than 1% different than the instructor answer.')
assert(lt(abs(X(2)-X_lukas(2)),0.02), 'The X(2) parameter is more than 2% different than the instructor answer.')
assert(lt(abs(X(3)-X_lukas(3)),0.1), 'The X(3) parameter is more than 10% different than the instructor answer.')
		
      



Could not parse problem





The objective of this problem is to create a compact model for the waveguide, in the form of an expression.  Find an expression for the effective index versus wavelength.

  Use (ONLY) the following parameters:
  lambda: units micronsthe other parameters should be numbers
Your expression will be verified with the instructor's answer.
The answer should be in the format such as "2.4 - 1 * (lambda-1.55) -0.1 *(lambda-1.55)^2" 

neff = "2.444509 -1.1273 * (lambda - 1.55) -0.03335 * (lambda-1.55)^2"







Explanation
The answer is in the form of \( n_\text{eff}(\lambda) = 2.4 - 1.1 (\lambda - 1.55) + 0.1 (\lambda-1.55)^2 \)



To check the answer, we evaluate your expression over a range of 1.5 to 1.6 microns.  We then compare to the instructor's answer, and check that the effective index you provide is within +/- 0.02 of the correct answer.  


Could not parse problem




What is the waveguide geometry that gives the smallest mode area, for the TE polarization at 1550, for a silicon thickness of 220 nm, strip waveguide?  Answer is the waveguide width, with units of nanometers (required accuracy with 20 nm).






Explanation
Find the smallest mode area to be for a waveguide of approximately 360 nm in width.



Modify the script to sweep (using a for loop), the waveguide width parameter (width_ridge in the script).  Plot the mode area and confinement factor, versus the waveguide width.  
Or do it manually, iteratively.


Could not parse problem


Assume that 1 mW of light is input into an ideal Y-Branch splitter (Port E_0).  
The port labels in this problem are based on the diagram at 1:00 in the video.
_____________________________________________________________________________
How much optical power comes out of output 1 (Port E_1)? [Answer in mW]



Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.




Could not parse problem


Assume that 1 mW of light is input into ONE of the branches of an ideal Y-Branch combiner (Port E_1).  
The port labels in this problem are based on the diagram at 1:45 in the video.
_____________________________________________________________________________
How much optical power comes out of output 0 (Port E_0)?   [Answer in mW]



Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.




Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions).  You can ignore the radiation losses (loss in dB/cm in MODE Solutions) since they are small.  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is joined to the bent waveguide with no shift.
 
Determine the bend radius required for a TE mode to ensure that the loss is less than 0.1% (which is 0.004 dB) [Answer in microns, accuracy with +/-0.5]:






Explanation
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap.  Or you can use scripts, as provided in the next unit.
(Sorry for the brief explanation.  Post in the discussion below for more info.)



You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap calculations.  Do it iteratively, which only takes a few minutes. 
Or you can use scripts, as provided in the next unit.
The desired total transmission through the bend is 0.999.  Make sure that you are searching for the overlap value of sqrt(0.999).


Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions) and radiation losses (loss in dB/cm in MODE Solutions).  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is joined to the bent waveguide with no shift.
 
Determine the bend radius required for a TM mode to ensure that the loss is less than 1% (which is 0.04 dB insertion loss)  [Answer in microns, accuracy with +/-1]:




Determine the bend radius required for a TM mode to ensure that the loss is less than 0.1%  [Answer in microns, accuracy with +/-3]:






Explanation
For 11 µm, we find:
  Propagation loss, coming from radiation loss:  0.277 dB/cm.  For a 1/4 circle, you can find the dB for the bend by: ?(-2*pi*11e-4/4*0.277); which is 0.000479 dB.  In linear units, this is   ?10^(-2*pi*11e-4/4*0.277 /10);  which is 0.99989.  Mode-mismatch loss, using overlap calculation:  0.99533Multiply the two together:  ?10^(-2*pi*11e-4/4*0.277 /10) *  (0.99533)^2; = 0.9906.

Quite likely your numbers will be slightly different, due to different simulation configuration (mesh, span, etc).   I used a span of 2.8 µm, with a 10 nm mesh.
  
              For 33 µm, we find:
  Propagation loss, coming from radiation loss: ~0 dB/cm. Mode-mismatch loss, using overlap calculation: 0.99951
(Post in the discussion below for more info.)



For the TM mode, you need to increase the thickness of the simulation, namely in the Z direction, so that the boundaries do not interfere with the simulation.  
If you are having trouble finding the TM mode: In the Eigenmode Analysis settings, you can also use search - near n - 1.8, to help the software find the correct TM mode. 
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap and radiation loss calculations.  Doing it manually, iteratively, only takes a few minutes.  
Or you can use scripts, as provided in the next unit.
Don't forget to consider that there are two mode-mismatch losses per bend, so square the overlap value.  And add the radiation loss in dB/cm times the length.


Could not parse problem




Calculate the mode-mismatch and radiation losses for the following bends, for TE polarization, 1550 nm wavelength [Answer in dB]:
Bend radius of 3 µm:




Bend radius of 5 µm:






Explanation
Can do it manually using mode overlap calculations, or using script.



Could not parse problem




Consider an interferometer with ideal lossless components (no waveguide loss, no additional loss in the splitter).
What is the maximum optical output power, if the input power is 1 mW?  [Answer in mW].





Explanation
Constructive interference with no loss in the circuit gives 100% transmission, or 1 mW output.



Could not parse problem




Consider a thermo-optic switch based on a balanced MZI. The switch consists of two Y branches connected with identical waveguides. One of the waveguides is covered with a metal heater, which is attached to two electrical probe pads. 



This Mach Zehnder Interferometer has an optical transfer function 
\[ \cfrac{I_o}{I_i} = \frac{1}{2} \left[ 1+  \cos{ (\beta_1 L_1 - \beta_2  L_2) } \right] \]
where \(I_i\) is the input light intensity, \(I_o\) is the output intensity, \(L_1\) and \(L_2\) are lengths of the two waveguides, and \(\beta_1\) and \(\beta_2\) are the waveguide propagation constants, and are defined as
\[ \beta_{1,2} = \cfrac{2 \pi \left( n + \frac{dn}{dt} \Delta T_{1,2} \right) } {\lambda} \]
where \(\Delta T_{1,2}\) represent the temperature increase above room temperature for each waveguide, and \(\lambda\) is the wavelength, 1550 nm.

Consider a thermal source that is applied to waveguide 1 (e.g., the metal heater covers one waveguide; neglect thermal cross-talk).  Estimate the required temperature change, \(\Delta T_1\), to change the switch from being ON (where there is 100% transmission) to being OFF (where there is 0% transmission). Assume an experimental value for \(\frac{dn}{dt} = 2 \times 10^{-4} / {^\circ}C\), and \(L_1 = L_2 =100 \mu m\).

  
What is the required temperature increase to change the switch from being ON to OFF?  [Answer in \(^\circ\)C].






Explanation
The switch changes from ON to OFF when there is a π phase change in the heated waveguide.  The phase shift due to propagation in waveguide is:
\[ \beta_1 L_1 = \cfrac{2 \pi \left( n + \frac{dn}{dt} \Delta T_{1} \right) } {\lambda} L_1 \]
The change of the phase due to the heater is:
\[ \Delta \beta_1 L_1 = \cfrac{2 \pi \frac{dn}{dt} \Delta T_{1}  } {\lambda} L_1 \]
We need to solve for \(\Delta T_1\) in \(\pi = \Delta \beta_1 L_1\):
\[ \Delta T_{1}  = \cfrac{ \lambda}{2 \frac{dn}{dt} L_1 } \]
\[ \Delta T_{1}  = \cfrac{1.55\times10^{-6}}{2 \cdot 2 \times 10^{-4} \cdot 100\times10^{-6} } = 38.75 ^ {\circ} C \]





Could not parse problem




Assume a waveguide has the following effective index values:
  2.5 at 1.5 µm 2.4 at 1.6 µm 
What is the waveguide group index at 1.55 µm? [answer accuracy +/- 0.001]






Explanation
ng = 2.45 - 1.55 * (-0.1)/0.1.



Could not parse problem




Assume an interferometer with the following properties:
  Wavelength of operation is 1.55 µmWaveguide's group index is 4.2Path length mismatch ∆L is 100 µm
What is the Free Spectral Range, in [answer in nm, accuracy +/- 0.01]?






Explanation
FSR = 1.55e-6^2 / 100e-6 / 4.2 * 1e9
Don't forget to convert from meters to nanometers.



Make sure your answer is correct to +/- 0.01 nm.
The answer is in units of nanometers.


Could not parse problem


You may use this MATLAB window as a calculator to help you answer the questions.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem





  In this unit, we provide you with MATLAB code (download Phot1x_MZI_matlab.m) to simulate the optical transmission spectrum (or transfer function) of the Mach-Zehnder Interferometer.  You can use this code to experiment with the MZI behaviour, gain insight into how the spectrum changes as a function of \(L_2-L_1\), see how loss impacts the extinction ratio, and so on.  Also, be sure to modify the compact waveguide model parameters to match the waveguide you have modelled and are planning on using in your design.
  

You will need to make adjustments to the constants in the model.  Specifically, change the following:
    n1, n2, n3: the compact waveguide model coefficients. lambda0: the centre wavelength used for the waveguide model. lambda_min, lambda_max: the wavelength range over which you want to plot.  lambda_step: the wavelength step for the plot. Keep in mind that the Agilent/Keysight Technologies laser (81600B) has a wavelength resolution of 0.1 pm, however, we perform automated measurements typically with a 10 pm resolution.  alpha: the propagation loss of the waveguide. L1, L2: the lengths of the two waveguides in the interferometer. 
Note that all constants are in units of microns, unless noted.

          


      %%    
      
      



% MATLAB script to plot the MZI transfer function.
% by Lukas Chrostowski
% user must configure several variables below.
        
% specify the wavelength range of interest.
lambda_min = 1.5;  % Units [µm, microns]
lambda_max = 1.6;
lambda_step = 0.01e-3; % wavelength step [microns]
                       % Typical minimum step for a tunable laser is 1-10 pm.
lambda=lambda_min:lambda_step:lambda_max;


% Define the waveguide effective index compact model:
% - as a Taylor expansion around the central wavelength, lambda0
%  use a Matlab anonymous function 
lambda0 = 1.55; n1=2.4; n2=-1; n3=0;  % these are constants from the waveguide model.
neff = @(lambda) ...
		(n1 + n2.*(lambda-lambda0) + n3.*(lambda-lambda0).^2); 
        
% plot the effective index version wavelength, and check if this is as expected:
figure;
plot(lambda, neff(lambda),'LineWidth',3);

% Complex propagation constant for the waveguide
alpha = 1e-3;  % propagation loss [micron^-1]; constant
beta = @(lambda) ...
		(2*pi*neff(lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );


% Define the MZI transfer function
T_MZI = @(L1, L2, lambda) ...
        ( 0.25* abs(exp(-1i*beta(lambda)*L1)+exp(-1i*beta(lambda)*L2)).^2);

% Define the two waveguide lengths in the MZI
L1=100;  % Waveguide 1 length, Units [µm, microns]
L2=200;  % Waveguide 2 length, Units [µm, microns]

% plot the MZI transfer function, and check if this is as expected:
% plot in linear scale:
figure;
plot(lambda, T_MZI(L1, L2, lambda),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission');
axis tight
title ('MZI transfer function');

% plot in log (dB) scale:
figure;
T_MZI_dB = 10*log10(T_MZI(L1, L2, lambda));
plot(lambda, T_MZI_dB,'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI transfer function');
      



        %%
var0=[n1, n2, n3, alpha, L1, L2];
var1=[2.4, -1, 0, 1e-3, 100, 200];
assert(not(isequal(var0,var1)), 'Looks like you just ran the code without changing the parameters: n1, n2, n3, alpha, L1, L2.  These are parameters specific to your waveguide and need to be changed.');
        
      



Could not parse problem




Consider an MZI with a small path length difference, \(\Delta L\). In this case, the output power can be adjusted by varying \(\Delta L\). 



We can obtain an arbitrary splitting ratio.  We start with the Mach Zehnder Interferometer optical transfer function 
\[ \cfrac{I_o}{I_i} = \frac{1}{2} \left[ 1+  \cos{ (\beta \Delta L) } \right] \]
where \(I_i\) is the input light intensity, \(I_o\) is the output intensity, \(\Delta L\) is the path length difference between  the two waveguides, and \(\beta\) is the waveguide propagation constant, and is defined by
\[ \beta = \cfrac{2 \pi  n  } {\lambda} \]
where \(n\) is the waveguide effective index (wavelengthd dependant), and \(\lambda\) is the wavelength, say 1550 nm. 

    Given a desired output, \(\frac{I_o}{I_i}\), e.g., 0.1 for 10%, we can solve for \(\Delta L\).  
Note that there are an infinite number of solutions, however we want to use the shortest path difference possible, which will result in a broadband operation (without an FSR).  Only a very small length difference is required to obtain any percentage between 0% to 100% transmission.  For example, assuming that when the paths are equal, we obtain 100% transmission (in the cross port, 100% in the bottom output; 0% in the top output), then 0% transmission occurs for a path length difference that corresponds to a \(\pi\) phase shift (in the cross port, 0% in the bottom output; 100% in the top output):
\[ \beta L = \pi \]
For a waveguide effective index of 2.4, and a wavelength of 1550 nm, a \(\pi\) shift occurs for approximately 323 nm.
  
What is the required path length difference to obtain a 80% power output in the bottom output (cross port) / 20% power output in the top port (through), at a wavelength of 1550 nm?  Assume the waveguide effective index is 2.4. [Answer in nm].






Explanation

  \[ 0.8 = \frac{1}{2} \left[ 1+  \cos{ (\beta \Delta L) } \right] \]
  \[ 1.6 -1 =   \cos{ (\cfrac{2 \pi \cdot 2.4  } {1550 nm} \Delta L) }  \]
  \[ \Delta L [nm] =     \frac{\cos^{-1}(0.6) 1550} {2 \pi \cdot 2.4} \]
  \[ \Delta L [nm] =    95.3 nm \]




Could not parse problem




Wavelength dependance of the splitting ratio
Simulate the transmission spectrum of the above 80% splitter MZI, using the transfer function in the previous unit.

Observe that the splitting ratio is 80% at 1550 nm, but varies by +/- 2% across the wavelength range.
  

You will need to make adjustments to the parameters in the model.  Specifically, change the following:
    n1, n2, n3: the compact waveguide model coefficients. lambda0: the centre wavelength used for the waveguide model. lambda_min, lambda_max: the wavelength range over which you want to plot.  lambda_step: the wavelength step for the plot.alpha: the propagation loss of the waveguide. L1, L2: the lengths of the two waveguides in the interferometer. 
Note that all constants are in units of microns, unless noted.

          
Scroll down below the graphs to see if your answer is correct.




      %%    
      
      



% MATLAB script to plot the MZI transfer function.
% by Lukas Chrostowski
% user must configure several variables below.
        
% specify the wavelength range of interest.
lambda_min = 1.5;  % Units [µm, microns]
lambda_max = 1.6;
lambda_step = 0.01e-3; % wavelength step [microns]
                       % Typical minimum step for a tunable laser is 1-10 pm.
lambda=lambda_min:lambda_step:lambda_max;


% Define the waveguide effective index compact model:
% - as a Taylor expansion around the central wavelength, lambda0
%  use a Matlab anonymous function 
lambda0 = 1.55; n1=2.4; n2=-1; n3=0;  % these are constants from the waveguide model.
neff = @(lambda) ...
		(n1 + n2.*(lambda-lambda0) + n3.*(lambda-lambda0).^2); 
        
% plot the effective index version wavelength, and check if this is as expected:
figure;
plot(lambda, neff(lambda),'LineWidth',3);

% Complex propagation constant for the waveguide
alpha = 1e-3;  % propagation loss [micron^-1]; constant
beta = @(lambda) ...
		(2*pi*neff(lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );


% Define the MZI transfer function
T_MZI = @(L1, L2, lambda) ...
        ( 0.25* abs(exp(-1i*beta(lambda)*L1)+exp(-1i*beta(lambda)*L2)).^2);

% Define the two waveguide lengths in the MZI
L1=100;  % Waveguide 1 length, Units [µm, microns]
L2=200;  % Waveguide 2 length, Units [µm, microns]

% plot the MZI transfer function, and check if this is as expected:
% plot in linear scale:
figure;
plot(lambda, T_MZI(L1, L2, lambda),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission');
axis tight
title ('MZI transfer function');

% plot in log (dB) scale:
figure;
T_MZI_dB = 10*log10(T_MZI(L1, L2, lambda));
plot(lambda, T_MZI_dB,'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI transfer function');
      



        %%
var0=[n1, n2, n3, alpha, L1, L2];
var1=[2.4, -1, 0, 1e-3, 100, 200];
assert(not(isequal(var0,var1)), 'Looks like you just ran the code without changing the parameters: n1, n2, n3, alpha, L1, L2.  These are parameters specific to your waveguide and need to be changed.');
assert(lt(alpha,3e-4), 'Your alpha value is too high.  Please consider less than 10 dB/cm propagation loss.  Note that if the waveguide loss, alpha, is too high, your splitting ratio will be lower than expected.');
dL_error = abs(abs(L2-L1)-95.3e-3);
assert(lt(dL_error,10e-3), 'Your L2-L1 value needs to be adjusted to obtain a 80% splitter. ');
        
      



Could not parse problem




An optical frequency of 193.1 THz corresponds to what wavelength? [Answer in nm, accuracy +/- 0.01].






Explanation
Wavelength = Speed of light / Frequency.
In INTERCONNECT, you can write in the "Script Prompt": ?c/193.1e12;
and obtain the answer 1.55252e-6



Could not parse problem




Consider an ideal Y-branch. What is the transmission from the input to one of the outputs, in dB? (what is a dB?) [Answer accuracy +/- 0.001].






Explanation
In INTERCONNECT, you can write in the "Script Prompt": ?10*log10(0.5); which equals -3.0103



The insertion loss is a positive number in dB.  The transmission for a passive component is always less than 0 dB (negative number).  
Transmission in dB = 10 x log10 (T), where T is the transmission in the linear scale.  In INTERCONNECT, you can type in the Script Prompt to calculate:  ?10*log10(T);
The ideal Y-Branch has a transmission, T = 0.5.


Could not parse problem




Answer this question by constructing the following circuit in Lumerical INTERCONNECT:
  Two grating couplers   Connect to a network analyzer.
Measure the best-case fibre-to-fibre insertion loss.
  
          Best-case insertion loss of two grating couplers (positive value, in dB, required accuracy +/- 0.1):





  For this question, please use the provided S-Parameter file for the grating coupler: S_TE1550_SubGC_neg31_oxide.txt; the one in the PDK is not exactly the same.

Loss is a positive number.


Could not parse problem




Build a Michelson Interferometer circuit as follows:


One 2x2 splitter (Broadband Directional Coupler): Design kits/ebeam_v1.2/ebeam_bdc_1550

Two strip waveguides, TE 1550 nm, to create the interferometer, and connected to the outputs of the 2x2 splitter: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide lengths: L1 = 215 µm, L2 = 15 µm.
    
A loop-back mirror.  A loop-back mirror consists of one 1x2 splitter (y-branch) with both outputs connected together with a waveguide so the light "reflects" back to the input. It consists of:
    A Y-Branch, TE 1550 nm: Design kits/ebeam_v1.2/ebeam_y_1550.  
    A strip waveguide, TE 1550 nm, connected to the two outputs of the y-branch: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide length is arbitrary, e.g., 10 µm.
    

An Optical Network Analyzer.  Properties: centre frequency = 1550 nm; frequency range = large enough so that you can see multiple peaks; Results view: turn on annotation for "gain" and "free spectral range".
    







What is the free spectral range (FSR) of the peak nearest 1550 nm. [Answer in nm, accuracy +/- 0.1]






Explanation
Here is the INTERCONNECT project for the solution.








Could not parse problem





The free spectral range (FSR) of the Michelson Interferometer is different from the Mach-Zehnder Interferometer.
    Why? 

In this math expression input problem, your text represents a
mathematical expression, and text is converted to a symbolic
expression that appears below the field. You can refer to 

Entering Mathematical and Scientific Expressions in the edX Guide for information about how to enter text into the field.


  Determine the expression for the FSR (in terms of wavelength) of the Michelson Interferometer based on the path length difference, \(\Delta = | L_2-L_1 | \) (write it as "Delta" below), the centre wavelength, \( \lambda \) (write it as "lambda"), and the waveguide group index, \( n_g \) (write it as "n_g"). 





FSR = "lambda^2/(2 * Delta * n_g)"


Verify your formula using the example circuit we simulted above. 
You can review the derivation of the Free Spectral Range for the Mach-Zehnder Interferometer (unit: Photonic Circuits > Interferometers > FSR of imbalanced MZI.
Here is a paper of a fabricated Michselson Interferometer
Watch the video on in the unit: Photonic Circuits > Interferometers > Overview of interferometer types, applications, where the Michselson Interferometer is discussed at time 9:10.


Could not parse problem




Build a Michelson-like Interferometer circuit as follows (I'm sorry, I don't know what this is called):


Two 2x2 splitters (Broadband Directional Coupler): Design kits/ebeam_v1.2/ebeam_bdc_1550

Two strip waveguides, TE 1550 nm, in the interferometer section: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide lengths: L1 = 115 µm, L2 = 15 µm.
    
A strip waveguide, TE 1550 nm, for the loop-back mirror: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide length is arbitrary. (Loop-back mirror consists of one splitter with both outputs connected together with a waveguide so the light "reflects" back to the input.)
    
An Optical Network Analyzer.  Properties: centre frequency = 1550 nm; frequency range = large enough so that you can see multiple peaks; Results view: turn on annotation for "gain" and "free spectral range".
    







What is the free spectral range (FSR) of the peak nearest 1550 nm. [Answer in nm, accuracy +/- 0.1]






Explanation
Here is the INTERCONNECT project for the solution.








Could not parse problem




Design an Adjustable Splitter
In this question, we wish to design a 20-80% splitter, where 20% comes out of opt_2 and 80% comes out of opt_1.  Make sure your design uses the shortest possible \(\Delta L\). Adjust the length of one of the waveguides (the longest one, wgs_2).





What is the \(\Delta L\) for the adjustable splitter configured to be 20-80% at 1550 nm?  [Answer in nm] 






Explanation
Adjust the 2nd waveguide path length.  Increasing it slightly from 20.06 microns will decrease the power in opt_1, thus making it closer to a 50-50 splitter; decreasing the length slightly will bring it closer to a 99-1% splitter. Find the value where you obtain a 80-20 splitter.  This turns out to be 20.091 microns. 
Here is the INTERCONNECT project for the solution: mzi_splitter.icp 



Could not parse problem




In this question, we wish to compare the flatness of the filters (1 stage versus 2 stages).  For a fair comparison, we use the same types of waveguides and the same 50-50 splitters in both designs.  We compare the flatness by determining the 1 dB bandwidth of the single-stage MZI, versus the 2-stage FIR filter.  Note: the 1-dB bandwidth is defined as the bandwidth as measured 1 dB below the peak transmission.  



  What is the ratio of the 2-stage vs. 1-stage bandwidth, where the ratio is defined as \(\frac{BW_{2-stage}}{BW_{1-stage}}\)?







Explanation

We analyze this near 1550 nm.  For the N=2 filter, the peak transmission is -0.17 dB.
At -1.17 dB, the wavelengths are 1543.68 nm and 1547.77 nm, hence the bandwidth is 4.09 nm.


For the single stage filter, the peak tranmission is -0.056 dB, and the wavelengths are 1546.91 nm and 1550.23 nm, hence the bandwidth is 3.32 nm.  


  Thus, the ratio is 4.09 / 3.32 = 1.23  


Download the INTERCONNECT project file: FIR filter.icp



Could not parse problem




For your Mach-Zehnder Inteferometer designs, enter the parameter variations for the path length difference (∆L).  When you press "check", the system will give you some feedback - we are performing a simple sanity-check to make sure that your designs are reasonable.  
Keep in mind that the smallest laser step size is 1 pm, and the typical measurement bandwidth limited by the grating couplers is 50 nm.
 
Enter your design parameters separated by commas, in units of [µm]




def make_a_list(name_string):
    return name_string.split(',')

def count_names(name_list):
    return len(name_list)

def num(s):
    try:
        return float(s)
    except ValueError:
        return 0
      
def how_many_oli(expect, ans):
    names = make_a_list(ans)
    how_many = len(set(names))
    message_hint = ''
    check = True
    for e in names:
        e=e.strip('"')
        e=e.strip("'")
        e=e.strip()
        e=e.lower()
        dL=num(e)
        who_is = e
        if dL &lt; 22:
            if dL == 0:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" (0) micron, you may still have a path length mismatch due to fabrication variations.  \n "
                check = False
            else:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, you will not see oscillations within the measurement span; longer path length mismatch required.  \n"
                check = False
        if dL &gt; 57200:
            message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, we will not be able to resolve the oscillations since they the FSR is too small and the loss differential too high; shorter path length mismatch required.  \n"
            check = False
    if how_many &lt; 1:
        return { 'ok': False, 'msg': 'None at all?'}
    if how_many &lt; 5:
        return { 'ok': check, 'msg': 'Only '+str(how_many)+" variations?  "+message_hint}
    if how_many == 5:
        return { 'ok': check, 'msg': message_hint }
    if how_many &gt; 5:
        return { 'ok': check, 'msg': message_hint }
    return False

  





Explanation
Assuming you want to see oscillations versus wavelength, the minimum path length difference is limited by span.  For 50 nm, 2 oscillations, is FSR = 25 nm.  Assuming ng=4.2, the min dL is ~ 23 µm.

            The maximum path length difference, to be able to resolve oscillations with 10 points per oscillation: 1 point is 1 pm, 10 is 10 pm.  So FSR is 10 pm, hence max ∆L=57 mm.  Assuming 3 dB/cm, this would yield a 17 dB loss difference.  The oscillation fringes would not be visible.  For such a large path-length mismatch, lower loss waveguides would be required (e.g., 3 µm wide multi-mode waveguide).
          



Could not parse problem


Use the Matlab code below to download and plot the measurement data.  The data is for two TE grating couplers, connected with a short waveguide (about 150 microns).  
  

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
% or same file from aws:
url = 'https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/ZiheGao_MZI2_271_Scan1.mat'

PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');
     
      



%%        
      



Could not parse problem


Use the Matlab code below to download, plot, and analyze the measurement data for YBranches for the TM polarization.  The data is for two TM grating couplers, and several YBranches.  The GDS file for the layout used for this experiment is EBeam_LukasChrostowski_TM_YBranches.gds.
  
Note that you can download and run this Matlab file, lukasc_YBranch_TM.m.  If you have the Statistics Toolbox, the program will generate an error estimation.  In the following graph, the shaded region corresponds to the 95% confidence interval.
    

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the insertion loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess insertion loss of about 10 dB.  For example,
% if the DUT is estimated to have an insertion loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the insertion loss, we plot the measured insertion loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the insertion loss for one DUT.

% For the case of the YBranch, the circuit consists of two YBranches facing
% each other. This creates an interferometer.  Assuming the waveguides are
% perfectly matched, the interferometer insertion loss will be only due to
% the excess loss of the YBranch.

% The following layout implements test structures for the YBranch described
% in paper http://dx.doi.org/10.1364/OE.21.001310
% EBeam_LukasChrostowski_TM_YBranches.gds
% https://www.dropbox.com/s/vs0hvrggbn5f9ip/EBeam_LukasChrostowski_TM_YBranches.gds?dl=1

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'YBranch (TM)';
% At what wavelength do you want to find out the insertion loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'lukasc_YBranch3_1262.mat', ...
    'lukasc_YBranch9_1261.mat', ...
    'lukasc_YBranch15_1260.mat', ...
    'lukasc_YBranch21_1263.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 3, 9, 15, 21 ] * 2;
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/louspt78v28x1dw/lukasc_YBranch3_1262.mat', ...
        'https://www.dropbox.com/s/cqyc233aqm8b2rc/lukasc_YBranch9_1261.mat', ...
        'https://www.dropbox.com/s/xrvtv54hmvjpfh4/lukasc_YBranch15_1260.mat', ...
        'https://www.dropbox.com/s/eiypug7qkx1p1ry/lukasc_YBranch21_1263.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength, nm');
ylabel ('Insertion Loss, dB');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the insertion loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the insertion loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Number of YBranches');
ylabel ('Insertion Loss (dB)');
title (['Cut-back method, ' deviceName ' insertion loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/YBranch'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' insertion loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/YBranch'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/YBranch'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' insertion loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/YBranch'])
end



% wavelength dependance of the DUT insertion loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Insertion loss, 95% Confidence Interval', ...
        'Insertion loss, from polyfit', ...
        'Insertion loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Insertion loss, from polyfit', ...
        'Insertion loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' insertion loss, wavelength dependance'] )
ylabel ('Insertion Loss (dB)');
xlabel ('Wavelength, nm');
set(gca,'FontSize',FONTSIZE)
     
      



%%        
      



Could not parse problem


Given the space allocation for this course, what is the largest number of fibre grating couplers that can be connected to a single circuit? [Answer: an integer]



Explanation
The total height of 4 couplers is 127 µm x 3 = 381, plus some extra height for the coupler itself (about 20 µm). This is why the 405 µm height was chosen.




Please take Design For Test into account; namely, we are using a 1D fibre array with the fibres in the vertical direction.
The "pitch" of the grating couplers is defined as the centre-to-centre distance.


Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The fibre grating couplers must be vertically spaced exactly 127 µm apart, and horizontally aligned.  In this layout, the bottom grating coupler is offset hence light will not be efficiently coupled into the bottom fibre. 



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The highlighted waveguide has sharp 90º angles; these should be replaced with smooth 90º bends to provide low optical loss and low back-reflections.  



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
This layout is missing a label for the automated measurements, e.g., "opt_in_TE_1550_device_LukasChrostowski_MZI3".  



Could not parse problem

You can enter your license code here, to help you remember. When you click "Check", it will come back incorrect; don't worry. It's just there to for your convenience.





Explanation



Could not parse problem

Consider an EBL system with a minimum writing grid of 1 nm, and a field size of 1 mm.   
How many bits are required in the Digital to Analog converter (DAC) to achieve the necessary resolution? [answer is an integer]





Explanation
The distance is twice that of the 500 µm example, hence one extra bit, thus 20.



Could not parse problem

Consider a single chip (25 x 25 mm), with four quarters each, with each quarter having a design area of 8.8 mm x 8.8 mm.  
Consider a single participant design size of 605 x 410 µm.  
How many participant designs can fit on a single chip? [required answer accuracy +/- 100]






Explanation
in MATLAB: answer = floor(8800/410)*floor(8800/605)*4 = 1176.
Spread the word about this course, since we have a lot more room for designers.



Our chip is at about 10% capacity.  Spread the word about this course, since we have a lot more room for designers.


Could not parse problem

Consider a single design area of 8.8 mm x 8.8 mm.  
Consider an extremely dense silicon photonic waveguide-based circuit, consisting of 500 nm wide waveguides, on a 3 µm centre-to-centre pitch.  Assume these waveguides are covering the entire design, as a series of parallel lines.  The layout is to be fabricated with a 6 nm shot pitch on the JEOL EBL system at UW, and written with a dose of 2800 uC/cm^2, with a current of 8 nA. 
How long would it take to write this chip? [answer in Hours, required answer accuracy +/- 1.0]






Explanation
in MATLAB:
Dose = 2800/1e4^2 % convert µC/cm^2 to µC/µm^2
A_written=(8800*.5/3)*(8800) % in µm^2
Ibeam = 8000/1e6 % convert pA to µA
t_seconds = Dose * A_written / Ibeam
t_minutes = t_seconds / 60
t_hours = t_minutes / 60
 ANSWER 12.5 hours.  



The gap between waveguides is not 3 µm.
You can use Matlab to calculate using the formula t_seconds = Dose * A_written / Ibeam.  Don't forget to convert the units.
You can use the provided online EBEAM calculator.
The machine can be left running overnight.


Could not parse problem




Consider an MZI that was designed to be balanced, with both path lengths being 100 µm.  Assume a lossless interferometer, such that if it was perfectly manufactured, it would have 100% transmission at 1550 nm.
Consider a chip where due to on-chip manufacturing variations, the effective index of both waveguides increases simultaneously by 1%.
What is the transmission of this MZI? [answer in percentage, an integer without the % symbol. required answer accuracy of +/-1%].






Explanation
no change in the transmission



No math required for this question.  This about it intuitively.
The ideal design has 100% transmission due to constructive interference.  What happens if the same phase shift is added to both arms of the interferometer?


Could not parse problem




Consider an MZI that was designed to be balanced, with both path lengths being 100 µm.  Assume a lossless interferometer, such that if it was perfectly manufactured, it would have 100% transmission at 1550 nm.
Consider a chip where due to on-chip manufacturing variations, the effective index of the two waveguides differs by 0.00775.
What is the transmission of this MZI? [answer in percentage, an integer without the % symbol. required answer accuracy of +/-1%].






Explanation
dneff=0.00775
L=100e-6
dbetaL = 2*3.1415*dneff*L/1550e-9 = 3.1415
Pi phase shift results in desctructive interference, or 0 transmission.



You'll probably need to go back to the interferometer equations (Photonic Circuits | Modelling - MATLAB | MZI Transfer Function).
The ideal design has 100% transmission due to constructive interference.  What happens if there is a relative phase shift between the waveguides?


Could not parse problem




Perform the corner analysis on the 500x220 nm waveguide, for TE, at 1550 nm.  Determine the range of values possible for the group index, ng.



Assume that the wafer thickness varies between 215.3 and 223.1 nm
Assume that the waveguide width varies between 470 and 510 nm


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Explanation
No explanation yet.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the 9 cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength).
  


Could not parse problem

Consider an MZI with a ∆L = 100 µm, with 500x220 nm waveguides, operating in the TE polarization, at 1550 nm.  Using a corner analysis, determine the range of values possible for the Free Spectral Range.
What is the minimum value for the FSR? [answer in units of nm, within an accuracy of 0.04] 




What is the maximum value for the FSR? [answer in units of nm, within an accuracy of 0.04]






Explanation
.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the corner cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength), then using the formula for FSR for the given ng values.
  


Could not parse problem

  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 



      %%    
      
      







        %%
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');


     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data (ZiheGao_MZI2_271_Scan1.mat). 
  
Choose the polynomial order (POLY_ORDER, or the value the polyfit function) to a value such at the polynomial follows the envelope of the MZI + Grating Couplers spectrum. Namely, the resulting polynomial should approximate the grating coupler insertion loss, and the flattened spectrum should look like the ideal MZI spectrum with the peaks at approximately 0 dB.
  



      %%    
      
      



% Enter the order of the polynomial for the curve fitting:
POLY_ORDER = 1;
        
% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, POLY_ORDER);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 
figure;
plot (lambda*1e6, amplitude); hold all;
plot (lambda*1e6, amplitude_baseline, 'LineWidth',4);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with polymial fit)');

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');
     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem




 What value for the polynomial order (POLY_ORDER) is appropriate for correcting the baseline? 


1 You need a higher order polynomial; try increasing POLY_ORDER.
2 Too few.
3 Ok.
4 Ok.
5+ Likely the polynomial has too high an order. Be very careful not to "overfit" the data.



Adjust POLY_ORDER above, and re-run the code.  You should see a polynomial that looks similar to a grating coupler response (as in the first plot at the top).


Could not parse problem




In this section, you can calibrate a measured spectrum using a "loopback" structure.
Objective:



remove the baseline shape of the grating couplers



Method:



curve-fit the spectrum of two grating couplers (or an MZI with ∆L=0) using a low-order polynomial
Restrict to ~10 dB from peak to avoid using data with a large error
Subtract this polynomial from subsequent data



You can download and run the Matlab code on your own computer. 

Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      




% Read data files from experiments
% Enter the Dropbox URLs here.  Make sure the URL has a =1 at the end:
%  Loopback structure:
	url_loopback = 'https://www.dropbox.com/s/w915qfix9kwlwv7/ZiheGao_MZI1_272_Scan1.mat?dl=1';
%  MZI:
	url_mzi = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
% Calibrate the MZI data using the loopback structure
% Plot


PORT=1; % Which Fibre array port is the output connected to?
FONTSIZE=20;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Loopback data:
a=websave('loopback.mat',url_loopback); % get data from Dropbox
load('loopback.mat');
% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda*1e6, amplitude);
title ('Calibration loopback'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)
hold all;

% Fit the data with a polynomial
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 5);
amplitude_LOOPBACK=polyval(p,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, amplitude_LOOPBACK);
% find wavelength range with usable data, in the loopback
loopback_IL = max(amplitude);
new_lambda_i=find(amplitude>loopback_IL-10);
lambda=lambda(new_lambda_i);
lambda_min = min(lambda);
lambda_max = max(lambda);
amplitude=amplitude(new_lambda_i);
% refit the loopback
LOOPBACK=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_LOOPBACK=polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, [amplitude_LOOPBACK],'r-','Linewidth',5);
axis tight;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data:
a=websave('mzi.mat',url_mzi); % get data from Dropbox
load('mzi.mat');
lambda1=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda1*1e6, amplitude);
title ('MZI (raw data)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data - calibrated
%
% data only within the bandwidth of interest.
lambda=lambda_min:min(diff(lambda1)):lambda_max;
amplitude=interp1(lambda1, amplitude, lambda,'linear');
amplitude(find(amplitude==-inf))=-50;
% calibrate data
amplitude_cal=amplitude-polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
figure;
plot (lambda*1e6, amplitude_cal);
title ('MZI (calibrated with loopback)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)


    
      



        %%
	url_mzi0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url_mzi0, url_mzi)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

You will need to make adjustments to the initial parameters for the fitting function.  Specifically, change the following line:
  


   nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
    

 Check your answer when you think you have a good fit.  
  
Please note that this code fits the response using the MZI transfer function. This function includes the path length difference, ∆L. This must match the design, in order to have meaningful results. 



      %%    
      
      




% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
lambda0 = mean(lambda)*1e6;		
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.

% initial function for fitting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];
figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');

% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      

nx_init = [2.4, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
      

        %%
%url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
%assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  
Note that two data file examples are provided. Note that the ∆L path length difference must be correctly set.



      %%    
      
      



% Lukas Chrostowski, curve fitting the MZI using findpeaks, 2015/08/14

% Enter the Dropbox URL here.  Make sure it has a =1 at the end:

% TE
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

% TM:
%url = 'https://www.dropbox.com/s/onjwrarapf6dumv/ADCL_1_1153_Scan1_L2-L1%3D100um.mat?dl=1';
%dL = 100;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
if not(exist('lambda_min'))
	lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
end
if not(exist('lambda_max'))
	lambda_max = max(lambda);   %  if the data on the edges is noisy
end
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find peaks, extract FSR and ng, and neff
% as initial parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% smooth (0.1% moving average filter)
windowSize = floor(1e-3*length(lambda)); b = (1/windowSize)*ones(1,windowSize);
amplitude_smooth=filter(b,1,amplitude);
% FIND PEAKS
[pks,x_values,w,p]=findpeaks(-amplitude_smooth, lambda, 'minPeakProminence',4,'Annotate','extents');

% plot spectrum with peaks
figure;
plot (x_values*1e6, interp1(lambda, amplitude, x_values,'pchip'), 'ro','MarkerSize',10); 
hold all;
plot (lambda*1e6, amplitude_smooth);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with peaks)');

% Calculate and plot ng data points from FSR
lambda_ng = (x_values(1:end-1)+x_values(2:end))/2;
FSR=(x_values(2:end)-x_values(1:end-1));
ng = abs(lambda_ng.^2/1/(dL*1e-6)./FSR);
% find average ng from all reasonable ng values:
indexes = find(gt(ng,3)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
indexes = find(lt(ng,5)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
ng_av = mean(ng);
if eq(length(ng),0)
  disp ('No group index values found.  Terminating script.');
  break
end
disp (['(estimate) Group index: ' num2str(ng_av)])

% plot FSR
figure;
plot (lambda_ng*1e6, FSR*1e9, '-o','LineWidth',1,'MarkerSize',7 );
xlabel ('Wavelength [\mum]')
ylabel ('Free Spectral Range [nm]')
xlim([min(lambda), max(lambda)]*1e6);
title ('Free Spectral Range, from Experimental data');

% plot ng
figure
plot (lambda_ng*1e6, ng, '-o','LineWidth',1,'MarkerSize',7 )
xlabel ('Wavelength [\mum]')
ylabel ('Group Index')
xlim([min(lambda), max(lambda)]*1e6);
title ('Waveguide Group Index, from Experimental data');


% find starting point for curve fitting MZI, using the ng data
% Part 1 - n1
% lambda0 is in microns.
lambda0 = x_values(floor(length(x_values)/2)) * 1e6;
n1_initial=2.4;
modeNumber = n1_initial * dL / lambda0 - 0.5;
n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
% Part 1 - n2 from ng_av
n2 = (n1-ng_av)/lambda0;
% Part 3 - n3 from slope of ng vs. lambda, to get the dispersion
f_line = @(x,xdata)x(2)*xdata+x(1);
[xfit,resnorm]  = lsqcurvefit(f_line,[ng_av 0],lambda_ng*1e6,ng);
r=corrcoef(ng,f_line(xfit, lambda_ng*1e6));
r2_ng=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2_ng)] )
hold all;
plot (lambda_ng*1e6, f_line(xfit, lambda_ng*1e6),'LineWidth',3)
n3 = -xfit(2)/2/lambda0;
Dispersion0 = -(lambda0*1e-6) / 299792458 * 2* (n3*1e12) * 1e12 /1e9 /1e-3;     	
disp (['(estimate from ng slope) Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
if lt(r2_ng,0.01)   % only use the result if the fit is good
  n3 = 0;
end

% Initial conditions for fitting:
nx_init = [n1 n2 n3];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];

	
% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'-','LineWidth',2);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  disp (['Waveguide parameters at wavelength [um]: ' num2str(lambda0)])
  ng0 = xfit(1) - lambda0*xfit(2);
  disp (['Group index: ' num2str(ng0)])

  % Dispersion:
  c=299792458;	
  Dispersion0 = -(lambda0*1e-6) / c * 2* (xfit(3)*1e12);  % [s/m^2]
  % [ps/nm/km]: 
  Dispersion0 = Dispersion0 * 1e12 /1e9 /1e-3;
  disp (['Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
  
  
end
      



        %%
		
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');

      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  
Note that two data file examples are provided. Note that the ∆L path length difference must be correctly set.



      %%    
      
      





% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

%url = 'https://www.dropbox.com/s/zojmleq3gu77dsw/ZiheGao_MZI17_265_Scan1.mat?dl=1';
%dL = 219.366;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find ng from autocorrelation-based frequency estimation of spectrum
% auto-correction
[r,lags]=xcorr(amplitude); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
figure
plot(lags,r);
% estimate the frequency
d=diff(r);
start = find(gt(d,0)); start=start(1);
[peak_m, peak_i]=max(r(start:end));
peak_i=peak_i+start;  % location of the 1st peak in the autocorrelation
hold on;
plot(peak_i,0,'s','MarkerSize',20);
title ('Autocorrelation of spectrum')
xlabel('lag, sample number');

fsr = peak_i * mean(diff(lambda))
ng_av = mean(lambda)^2/(dL*1e-6)/fsr


% find starting point for curve fitting, using the ng value
% lambda0 is in microns.
lambda0 = mean(lambda) * 1e6;
n1=2.4;
%modeNumber = n1_initial * dL / lambda0 - 0.5;
%n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
n2 = (n1-ng_av)/lambda0;
nx_init = [n1 n2 0];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Autocorrelation again, to find the shift between the fit function and experimental data
[r,lags]=xcorr(amplitude, T_MZI(x0, lambda*1e6)); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
[peak_m, peak_i]=max(r);
lambda_offset = peak_i(1) * mean(diff(lambda));
n_shift = lambda_offset*lambda0/fsr/dL;
x0(1)=x0(1)+n_shift;

figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters, with shift)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem






      %%    
      
      







        %%
   
        
      



Could not parse problem

Cut-back method, Spiral waveguide (TM) Loss, at 1550 nm is = 6.6 dB/cm 
Test structure for spiral waveguides, TM polarization

Use the Matlab code below to download, plot, and analyze the measurement data for waveguide propagation loss for the TM polarization.  The data is for two TM grating couplers, and spirals of length 0, 0.5, 1.0, 3.0 cm.  The GDS file for the layout used for this experiment is EBeam_lukasc_WGLoss_TM.gds.
  
Note that you can download and run this Matlab file, lukasc_spiralWG.m.  If you have the Statistics Toolbox, the program will generate an error estimation.  In the following graph, the shaded region corresponds to the 95% confidence interval.




Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the Loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess Loss of about 10 dB.  For example,
% if the DUT is estimated to have an Loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the Loss, we plot the measured Loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the Loss for one DUT.

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'Spiral waveguide (TM)';
% At what wavelength do you want to find out the Loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'LukasC_SpiralWG0kTM_1293.mat', ...
    'LukasC_SpiralWG5kTM_1296.mat', ...
    'LukasC_SpiralWG10kTM_1294.mat', ...
    'LukasC_SpiralWG30kTM_1295.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 0, 0.5, 1.0, 3.0 ];
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/anlo8zmydrji1f8/LukasC_SpiralWG0kTM_1293.mat', ...
        'https://www.dropbox.com/s/yvdfgl8qoq3d0fz/LukasC_SpiralWG5kTM_1296.mat', ...
        'https://www.dropbox.com/s/rossgslht5r5cq7/LukasC_SpiralWG10kTM_1294.mat', ...
        'https://www.dropbox.com/s/vj4uf6u59h9vt60/LukasC_SpiralWG30kTM_1295.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength (nm)');
ylabel ('Optical Power (dBm)');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the Loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the Loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Waveguide length (cm)');
ylabel ('Loss (dB/cm)');
title (['Cut-back method, ' deviceName ' Loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    a=annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    set(a,'FontSize',FONTSIZE);
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/cm'])
end



% wavelength dependance of the DUT Loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Loss, 95% Confidence Interval', ...
        'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' Loss, wavelength dependance'] )
ylabel ('Loss (dB/cm)');
xlabel ('Wavelength (nm)');
set(gca,'FontSize',FONTSIZE)
     
           
      



        %%
   
        
      



Could not parse problem

Cut-back method, Spiral waveguide (TE) Loss, at 1550 nm is = 11 dB/cm 
Test structure for spiral waveguides, TE polarization

Use the Matlab code below to download, plot, and analyze the measurement data for waveguide propagation loss for the TE polarization.  The data is for two TM grating couplers, and spirals of length 0, 0.5, 1.0, 3.0 cm.  The GDS file for the layout used for this experiment is EBeam_lukasc_WGLoss_TE.gds.
  

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the Loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess Loss of about 10 dB.  For example,
% if the DUT is estimated to have an Loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the Loss, we plot the measured Loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the Loss for one DUT.

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'Spiral waveguide (TE)';
% At what wavelength do you want to find out the Loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'LukasC_SpiralWG0kTE_1297.mat', ...
    'LukasC_SpiralWG5kTE_1300.mat', ...
    'LukasC_SpiralWG10kTE_1298.mat', ...
    'LukasC_SpiralWG30kTE_1299.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 0, 0.5, 1.0, 3.0 ];
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/1v5wzon5nexggn6/LukasC_SpiralWG0kTE_1297.mat', ...
        'https://www.dropbox.com/s/7r8svd1ukjae8ox/LukasC_SpiralWG5kTE_1300.mat', ...
        'https://www.dropbox.com/s/kfsv1yeghue0i38/LukasC_SpiralWG10kTE_1298.mat', ...
        'https://www.dropbox.com/s/5o66l3xd7rnxtgq/LukasC_SpiralWG30kTE_1299.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength (nm)');
ylabel ('Optical Power (dBm)');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the Loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the Loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Waveguide length (cm)');
ylabel ('Loss (dB/cm)');
title (['Cut-back method, ' deviceName ' Loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    a=annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    set(a,'FontSize',FONTSIZE);
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/cm'])
end



% wavelength dependance of the DUT Loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Loss, 95% Confidence Interval', ...
        'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' Loss, wavelength dependance'] )
ylabel ('Loss (dB/cm)');
xlabel ('Wavelength (nm)');
set(gca,'FontSize',FONTSIZE)
     
                 
      



        %%
   
        
      



Could not parse problem



Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 


Could not parse problem


  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 




      %%    
      
      







        %%
      



Could not parse problem




Unbalanced MZI Interferometer, TM polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TM_1550_device_LukasChrostowski_MZI_TM_oneside". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.03]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.03]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TM_oneside.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.02]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100; within an accuracy of +/- 2 %]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/lukasc_TETM_simVSexp.zip  




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
Follow the Convergence Tests section, in Waveguide Modelling - Lumerical MODE
The TM layout used a bend radius of 10 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of lambda_min=1.54e-6; lambda_max=1.56e-6.
     


Could not parse problem


  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 




      %%    
      
      







        %%
      



Could not parse problem




Unbalanced MZI Interferometer, TE polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TE_1550_device_LukasChrostowski_MZI_TE_oneside2". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.02]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.02]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.02]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.02]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TE_oneside2.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.04]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100 percent; within an accuracy of +/- 2 (%)]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/lukasc_TETM_simVSexp.zip 




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
The TE layout used a bend radius of 5 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of          lambda_min=1.543e-6; lambda_max=1.557e-6.
     


Could not parse problem


  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 




      %%    
      
      







        %%
      



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
Query done.
Processed: 9.2 MB

Retrieving results...
Got 8114 rows.

Total time taken 6.67 s.
Finished at 2017-06-30 20:39:02.
Saved to ./../data/Phot1x_2T2015/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 14.23 s. Waiting...
  Elapsed 24.62 s. Waiting...
  Elapsed 35.09 s. Waiting...
Query done.
Processed: 517.7 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 43.6 s.
Got 363 rows.

Total time taken 43.61 s.
Finished at 2017-06-30 20:39:47.
Saved to ./../data/Phot1x_2T2015/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 15.02 s. Waiting...
  Elapsed 25.16 s. Waiting...
  Elapsed 35.54 s. Waiting...
Query done.
Processed: 470.4 MB

Retrieving results...
  Got page: 1; 4% done. Elapsed 48.78 s.
  Got page: 2; 8% done. Elapsed 52.86 s.
  Got page: 3; 12% done. Elapsed 58.44 s.
  Got page: 4; 16% done. Elapsed 63.63 s.
  Got page: 5; 20% done. Elapsed 69.76 s.
  Got page: 6; 24% done. Elapsed 75.86 s.
  Got page: 7; 28% done. Elapsed 81.67 s.
  Got page: 8; 32% done. Elapsed 86.44 s.
  Got page: 9; 36% done. Elapsed 92.03 s.
  Got page: 10; 40% done. Elapsed 98.19 s.
  Got page: 11; 44% done. Elapsed 103.09 s.
  Got page: 12; 48% done. Elapsed 109.68 s.
  Got page: 13; 52% done. Elapsed 116.08 s.
  Got page: 14; 56% done. Elapsed 120.35 s.
  Got page: 15; 60% done. Elapsed 124.8 s.
  Got page: 16; 64% done. Elapsed 128.86 s.
  Got page: 17; 69% done. Elapsed 133.94 s.
  Got page: 18; 73% done. Elapsed 138.8 s.
  Got page: 19; 77% done. Elapsed 143.69 s.
  Got page: 20; 81% done. Elapsed 148.85 s.
  Got page: 21; 85% done. Elapsed 155.33 s.
  Got page: 22; 89% done. Elapsed 160.21 s.
  Got page: 23; 93% done. Elapsed 165.03 s.
  Got page: 24; 97% done. Elapsed 170.62 s.
  Got page: 25; 100% done. Elapsed 175.21 s.
Got 579033 rows.

Total time taken 197.72 s.
Finished at 2017-06-30 20:43:06.
Saved to ./../data/Phot1x_2T2015/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 8.0 KB

Retrieving results...
Got 118 rows.

Total time taken 0.78 s.
Finished at 2017-06-30 20:43:20.
Saved to ./../data/Phot1x_2T2015/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 72.1 KB

Retrieving results...
Got 155 rows.

Total time taken 1.26 s.
Finished at 2017-06-30 20:43:23.
Saved to ./../data/Phot1x_2T2015/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 856.7 KB

Retrieving results...
Got 2303 rows.

Total time taken 1.91 s.
Finished at 2017-06-30 20:43:26.
Saved to ./../data/Phot1x_2T2015/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.2 MB

Retrieving results...
Got 753 rows.

Total time taken 1.04 s.
Finished at 2017-06-30 20:43:29.
Saved to ./../data/Phot1x_2T2015/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.9 MB

Retrieving results...
Got 36599 rows.

Total time taken 6.41 s.
Finished at 2017-06-30 20:43:36.
Saved to ./../data/Phot1x_2T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 65.9 KB

Retrieving results...
Got 642 rows.

Total time taken 0.95 s.
Finished at 2017-06-30 20:43:39.
Saved to ./../data/Phot1x_2T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 118.1 MB

Retrieving results...
Got 14342 rows.

Total time taken 3.78 s.
Finished at 2017-06-30 20:43:43.
Saved to ./../data/Phot1x_2T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 211.2 KB

Retrieving results...
Got 642 rows.

Total time taken 0.95 s.
Finished at 2017-06-30 20:43:45.
Saved to ./../data/Phot1x_2T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 5.8 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 10.48 s.
Got 76 rows.

Total time taken 10.49 s.
Finished at 2017-06-30 20:43:57.
Saved to ./../data/Phot1x_2T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.66 s. Waiting...
Query done.
Processed: 5.0 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 15.51 s.
Got 20386 rows.

Total time taken 15.92 s.
Finished at 2017-06-30 20:44:14.
Saved to ./../data/Phot1x_2T2015/page_dirt.csv
Could not parse problem


Click "run" to execute the code.  



      %%    
      
      



a=1
b=2
c=a+b
        
% Practice figures:        
x=1:0.1:10;
figure; plot (x, sin(x)); title ('The First figure');
figure; plot (x, exp(x)); title ('The Second figure');
        
      



%%     
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem




Consider a Si/SiO2 waveguide, and assume that the light is travelling as follows: 90% in silicon, and 10% in silicon dioxide.  Assume the mode profile does not change in the following questions:
Q1: If the wavelength increases by 10 nm, by how much will the effective index change?




Q2: If the temperature increases by 10 C, by how much will the effective index change?




Q3: Let's find out if we can ignore the temperature dependance of SiO2 in our models.  Repeat the above Q2 calculation, this time assuming a constant SiO2 material model.  How much error would be introduced in the change in effective index versus temperature, if a constant SiO2 material model was used? (answer in %) 
 \( \% error = \frac{\text{Correct}-\text{Incorrect}}{\text{Correct}} \cdot 100 \)






Explanation
For a 10 nm change in wavelength: 10 nm * ( 0.9 * -7.6e-5 /nm + 0.1 * -1.2e-5 /nm ) = -6.96e-4
For a 10 C change in temperature: 10 K * ( 0.9 * 1.87e-4 /K + 0.1 * 8.5e-6 /K ) = 1.6915e-3
For a 10 C change in temperature, but only considering dn_Si / dT, 10 nm * ( 0.9 * 1.87e-4 /K ) = 1.683e-4.  Hence, the error is: 
(1.6915-1.683) / (1.6915) = 0.00502, or 0.5%



For the effective index, in Q1-3, approximate this as a weighted average of the refractive index values in each medium. 
For Q3: Modify your equation in Q2 to assume that there is no temperature dependence in the SiO2.  Note that 10% of the light is still in the SiO2, and 90% is in silicon. 
For Q3, the answer is a number.  Don't include the % symbol in the answer. 


Could not parse problem


You can use this MATLAB window to perform the calculations necessary for the problems.
  

      Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.


  



      %%    
      
      



delta_T = 10;
Thermal_coefficient = 0.01;  % replace with correct value
delta_n = Thermal_coefficient * delta_T
        
      



        %%
   
        
      



Could not parse problem




In this exercise, we wish to understand why the wafers we are using have a thickness of 220 nm. 
 You can use the analytic method with the script provided below (in MATLAB) to answer this question.  You can also download the script (wg_1D_analytic.m). 
Question – What is the maximum Si thickness before the slab waveguide supports more than one TE mode? 
Enter the thickness, in [nm, accuracy +/-5 nm]:






Explanation




Use the Matlab code below.  You can do this problem by trial and error, with your own iterations.  
Change the thickness of the waveguide -- the default is 0.22e-6 m.  You will see that nTE = xxxx: namely it supports a single mode.  Try increasing it, say to 0.5e-6.  You will see that nTE = xxxx, xxxx, xxx: namely it supports multiple (3) modes.  Find the value where the 2nd mode just disappears.  
You could also make a script with a "for" loop, and plot the number of modes versus the thickness.  The number of modes would be found by the command length(nTE).  


Could not parse problem


Use the following Matlab code to answer the question on slab waveguides.
  
To change the thickness, change the number 0.22e-6 in the following line: 



[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
  



Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_analytic.m - Analytic solution of a slab waveguide
% by Lumerical Solutions, http://www.lumerical.com/mode_online_help/slab_wg.m
% modified by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3
% finds the TE and TM effective indices of a 3-layer slab waveguide

% usage:
%  - get effective indices for supported modes:
%  [nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
%  - optional, for plotting: TEparam,TMparam: h, q, p parameters of the mode.


function main
	[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
      



        %%
   
        
      



Could not parse problem




 We know that some of the light is travelling outside the waveguide.  This is an important concept to understand as it has several implications: 
  It leads to the concept of waveguide dispersion, and has a huge impact on the group index, \( n_g \) The field outside the waveguide can be used to make evanescent field sensors, e.g., bio applications.  (Note - replace SiO2 with air, water, etc, for biosensors) 
  Hence, we wish to study how far the fields extend above the waveguides.  We consider the two polarizations (TE, TM) guided by the 220 nm slab waveguide. 
          Question - For the TE polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point (of the value at the interface):




Question - For the TM polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point:






Explanation
TE Polarization:

Measure the field at the interface.
Find the 1/e point.  If the field is 0.66 at the interface, take 0.66 / e = 0.66 / 2.71 = 0.243.  Find the x value for this point, which is approximately 200 nm.
Measure the distance from the interface: 200-110 = 90 nm.

TM Polarization:

The MATLAB code needs to be motified to plot TM_E (the E-field for the TM polarization) instead of TE_E (the E-field for the TM polarization)
Measure the field at the interface.
find the 1/e point.  if the field is 0.77 at the interface, take 0.77 / e = 0.28.  Find the x value for this point, which is approximately 280 nm.
measure the distance from the interface: 280-110 = 170 nm.




Could not parse problem

You can run the MATLAB code provided in the web browser below.  Or, you can download the code and run it directly on your computer (wg_1D_mode_profile_main.m)
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_mode_profile.m - Calculate the 1D mode profile of a slab waveguide
% by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3.2
% - function returns mode profiles for TE and TM modes (E, H components)
% usage, e.g.:
%  [x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444, 100, 4)
%  plot (x, TE_E); 
%  plot (x, TM_E); 



function main
	thickness=0.22e-6;  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	[x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile ...
		(1.55e-6, thickness, 1.444, 3.47, 1.444, 100, 3);
	g=rectangle('Position',[-thickness*1e9/2,0,thickness*1e9,1],'FaceColor',[.8 .8 .8 0.2]); hold all;
	plot (x*1e9, TE_E/max(max(TE_E)), 'LineWidth',3);
	xlabel('Position [nm]');
	ylabel('Field Amplitude');
	ax=gca;
	set(ax, 'FontSize',15);
	ax.XTick = [floor(min(x)*1e9/100)*100:200:floor(max(x)*1e9/100)*100];
	axis tight;
	grid on; box on;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
	x1=linspace( -M*t, -t/2, pts); x2=linspace( -t/2, t/2, pts); 
	x3=linspace( t/2, M*t, pts); x=[x1 x2 x3];
	nx=[n1*ones(pts,1); n2*ones(pts,1); n3*ones(pts,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);     
      



        %%
   
        
      



Could not parse problem

Simulation results for the strip waveguide, TE polarization, show that the effective index decreases with increasing wavelength.
What is the main reason that the waveguide's effective index decrease with wavelength?





Explanation
Both Material and Waveguide dispersion contribute.  However, material dispersion accounts for a small portion of the total dispersion; recall that the group index of silicon is ~3.6, which is ~0.1 higher than the refractive index of silicon (n_Si).  In contrast, the group index for the waveguide is ~4.2, which is ~0.7 higher than n_Si.  If one was to simulate the waveguide without material dispersion (setting n_Si = 3.47, a constant), one would find that the group index is ~0.6 higher than the n_Si.  Thus, the waveguide dispersion is the dominant effect.
To get an intuitive understanding, simulate the mode for different wavelengths.  You will see that the mode is more spread out for longer wavelengths.  
Intuitively, more light is travelling through the lower index cladding for longer wavelengths.  The effective index can be thought of as a weighted average of the material indices, based on the mode profile.  Hence, less light in the silicon core for longer wavelengths leads to a lower effective index.



Could not parse problem

Question - 1 attempt only:
Simulation results for the strip waveguide show that the effective index increases with increasing geometry (width or thickness).
What is the main reason that the waveguide's effective index increasing with width?





Explanation
The answer is similar to model dispersion described above.  
To get an intuitive understanding, simulate the mode for different geometries.  You will see that the mode is more spread out for smaller waveguides with tails extending into the cladding.  In contrast, larger waveguides have more light inside the core.  
Hence, for larger geometries, more light in the silicon core, and this leads to a higher effective index.



Could not parse problem




Using the Effective Index Method, find the fundamental TE mode effective index at 1500 nm.
n_eff: Effective index of the waveguide:






Explanation
Change the wavelength in the code...  The first parameter is wavelength, in: wg_EIM_profile (1.50e-6, ...
Run the matlab code.
See the effective index displayed.



Could not parse problem


Use the Matlab code below (Effective Index Method, field profile) to view the field profile for a 500 x 220 nm waveguide.
  
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_EIM_profile.m - Effective Index Method - mode profile
% Lukas Chrostowski, 2012
% usage, e.g.:
%  wg_EIM_profile (1.55e-6, 0.22e-6, 0.5e-6, 90e-9, 3.47, 1, 1.44, 100, 2)

function main
	[neff_TEwg]=wg_EIM_profile (1.60e-6, 0.22e-6, 0.5e-6, 0, 3.47, 1.44, 1.44, 100, 2)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [neff_TEwg]=wg_EIM_profile (lambda, t, w, t_slab, n_core, n_clad, n_oxide, pts, M)

	% find TE (TM) modes of slab waveguide (waveguide core and slab portions):
	[nTE,nTM]=wg_1D_analytic (lambda, t, n_oxide, n_core, n_clad);
	if gt(t_slab,0)
		[nTE_slab,nTM_slab]=wg_1D_analytic (lambda, t_slab, n_oxide, n_core, n_clad);
	else
		nTE_slab=n_clad; nTM_slab=n_clad;
	end
	[xslab,TE_Eslab,TE_Hslab,TM_Eslab,TM_Hslab]=wg_1D_mode_profile (lambda, t, n_oxide, n_core, n_clad, pts, M);

	figure%(1);  clf; subplot (2,2,2); 
    Fontsize=15;
	plot(TE_Eslab/max(max(TE_Eslab)),xslab*1e9,'LineWidth',4);hold all;
	ylabel('Height [nm]','FontSize',Fontsize); 
	xlabel({' ','E-field (TE)'},'FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize,'XTick',[]);
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);
	Ax1 = gca; Ax2 = axes('Position',get(Ax1,'Position'));
	get(Ax1,'Position');
    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
	plot (nx, xslab*1e9,  'LineWidth',0.5,'LineStyle','--','parent',Ax2); 
	a2=axis; axis ([a2(1), a2(2), a(3), a(4)]);
	set(Ax2,'Color','none','XAxisLocation','top', 'YTick',[],'TickDir','in'); 
	set(gca,'YAxisLocation','right'); box off;
	xlabel('Material Index','FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize); 
%    print -dpdf eim1.pdf

	% TE-like modes of the etched waveguide (for fundamental slab mode)
	%   solve for the "TM" modes:
	[nTE,nTM]=wg_1D_analytic (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1));
	neff_TEwg=nTM;
	[xwg,TE_E_TEwg,TE_H_TEwg,TM_E_TEwg,TM_H_TEwg]=wg_1D_mode_profile (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1), pts, M);

    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
    figure%(1); subplot (2,2,3);
    % Plot the data on with a left and right axes. Return the axes and line
    % objects.
    [ax, h1, h2] = plotyy(xwg*1e9, TM_E_TEwg(:,1)/max(max(TM_E_TEwg)), xwg*1e9, nx);
    % Set the Xlabel and yLabel of each axes
    xlabel('Position [nm]','FontSize',Fontsize);
    ylabel(ax(1),'E-field (TM, TE-like mode)','FontSize',Fontsize);
    ylabel(ax(2), 'Slab Effective Index','FontSize',Fontsize);
    % Change the color of the right axes and the line style of line plot
    % associated with that axes.
    ax(2).YColor = 'b';
    h2.LineStyle = '--';
    h2.LineWidth = 0.5;
    h2.Color = 'b';
    % Set the Line width of the two line plots of the left axes.
    h1(1).LineWidth = 4;
    % Remove the left Tick labels.
    ax(1).YTick = [];
    % Set the YLim property so the plots line up.
    ax(2).YLim = [1.4, 2.6];
    ax(2).YTick = 1.4:0.2:2.6;
    
    % Plot the product of the two fields
	figure%(1); subplot (2,2,1);
	Exy=TM_E_TEwg(:,1)*(TE_Eslab(1,:));
	contourf(xwg*1e9,xslab*1e9,abs(Exy')/max(max(Exy))')
    % colormap('jet')
    axis equal
	xlabel ('X (nm)','FontSize',Fontsize); 
	ylabel ('Y (nm)','FontSize',Fontsize); 
	set (gca, 'FontSize',Fontsize); 
	A=axis; axis([A(1)+0.4, A(2)-0.4, A(3)+.2, A(4)-0.2]);
	title('Effective Index Method');
	% Draw the waveguide:
	rectangle ('Position',[-w/2,-t/2,w,t]*1e9, 'LineWidth',1, 'EdgeColor','white')
	if gt(t_slab,0)
		rectangle ('Position',[-M*w,-t/2,(M-0.5)*w, t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
		rectangle ('Position',[w/2,-t/2,(M-0.5),t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
    end

    
function draw_WG_vertical(M)
	pP=get(gca,'Position');pPw=pP(3); 
	pPc=pP(3)/2+pP(1); pP2=pPw/4/M;
	annotation ('line',[pPc-pP2,pPc-pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	annotation ('line',[pPc+pP2,pPc+pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	axis tight; a=axis; axis ([a(1), a(2), a(3)*1.1, a(4)*1.1]);

function draw_WG_horiz(M)
	pP=get(gca,'Position');pPw=pP(4); 
	pPc=pP(4)/2+pP(2); pP2=pPw/4/M;
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc-pP2,pPc-pP2],'LineStyle','--');
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc+pP2,pPc+pP2],'LineStyle','--');
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
    x1=linspace( -M*t, -t/2, pts); 
    x2=linspace( -t/2, t/2, pts); x2 = x2(2:end);
    x3=linspace( t/2, M*t, pts);  x3 = x3(2:end);
    x=[x1 x2 x3];
    nx=[n1*ones(pts,1); n2*ones(pts-1,1); n3*ones(pts-1,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
			     
      



        %%
   
        
      



Could not parse problem

Part 1

Using this tool, compute the mode profile and calculate the effective index of the fundamental TE mode for a 450x220 nm waveguide at 1550 nm.
    
Note:  This is a graded code box.  When ready, press "CHECK". After your code executes, additional code on the server will check your answer.  
  



      %%    
      global neff
      



% This example computes the field components and the effective index of a
% silicon-on-insulator strip waveguide.
% slightly modified version, from: http://www.photonics.umd.edu/software/wgmodes/
function [neff]=main

	global neff w  % Used by the auto-graded to check your answer.

	n1 = 1.44;          % SiO2 lower cladding
	n2 = 3.47;          % Silicon core
	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 2.5;           % grid size (x)
	dy = dx;            % grid size (y)

	lambda = 1550;      % wavelength (nm)
	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

	fprintf (1,'post-processing... '); t = cputime;

	[Hz,Ex,Ey,Ez] = postprocess (lambda, neff, Hx, Hy, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf (1,'graphing... '); t = cputime;

	hn = abs(interp2(y,x,Hy,h1+h2/2,0));
	en = abs(interp2(yc,xc,Ex,h1+h2/2,min(dx)/2));

	% Plot |E| profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,sqrt(abs([-Ex(end:-1:1,:);Ex]).^2+abs([-Ey(end:-1:1,:);Ey]).^2+abs([-Ez(end:-1:1,:);Ez]).^2)/en);
	title('|E|');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% could normalize the |E| plot to show energy...
	%size (eps)

	% figure;
	% imagemode(x,y,Hx/hn);
	% title('Hx');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hy/hn);
	% title('Hy');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hz/hn);
	% title('Hz');
	% for v = edges, line(v{:}); end

	% Plot Ex profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,[-Ex(end:-1:1,:);Ex]/en);
	hold on;
	contourmode([-xc(end:-1:1);xc],yc,[-Ex(end:-1:1,:);Ex]/en,(0:-5:-60));
	title('Ex');
	v = xlim();
	line(v,[h1,h1], 'Color', 'k');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% figure;
	% imagemode(x,y,Ey/en);
	% title('Ey');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Ez/en);
	% title('Ez');
	% for v = edges, line(v{:}); end
	
	% figure;
	% imagemode(x,y,sqrt(abs(Ez).^2+abs(Ey).^2+abs(Ex).^2)/en);
	% title('|E|');
	% for v = edges, line(v{:}); end

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

end

function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end

      

	  % Change the width of the waveguide to 450 nm, via the following variable on line 22:
      w = 450;
	  

        %%
      global neff w
	  ansVar=2.34749;
	  var=neff;
	  assert(all(lt(abs(w-450), 2e-3)), 'Please find the effective index for a waveguide with w=450.')
	  assert(all(lt(abs(ansVar-var), 2e-3)), 'Incorrect answer.  Please double-check that you are solving for the effective index for a waveguide with width of w=450.  Also check that your simulations have converged and are accurate.  The tolerance on this checker is 2e-3.')
		
      



Could not parse problem

Part 2

Calculate and plot the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide.
    
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      global neff
      



function main

	% Example wavelength sweep parameters with refractive indices:
	global lambdas % for the auto-grader
	lambdas = [1500, 1525, 1550, 1575, 1600]; 
	n1s = [1.444, 1.444, 1.444, 1.444, 1.444];  % Silicon dioxide index of refraction
	n2s = [3.47998, 3.47768, 3.4755, 3.47344, 3.47147]; % Silicon index of refraction

	% Perform effective index calculations
	global neffs % for the auto-grader
	neffs=[]; % initialize empty matrix to store effective index values.
	for i=1:length(lambdas)
		neffs(end+1) = wgmodes_neff(lambdas(i), n1s(i), n2s(i));
	end

	% plot effective index versus wavelength
	figure
	plot (lambdas, neffs)

	% calculate group index versus wavelength ...

end

function [neff]=wgmodes_neff(lambda, n1, n2)
	% inputs:
		% lambda - wavelength, in nm
		% n1 - SiO2 lower cladding
		% n2 - Silicon core

	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 5;           % grid size (x)
	dy = dx;            % grid size (y)

	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

end

% require the functions "wgmodes", "waveguidemesh", "stretchmesh", etc.


function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end


      

Copy and paste the WGMODE codes from the previous unit at the bottom of the above code block.  

Change the material index of refraction values.
	  

		%%
      



Could not parse problem

Optical waveguides suffer from loss from a variety of sources.  
What is the dominant optical loss mechanism?





Explanation
All of these mechanisms can contribute to optical loss in waveguides.
Absorption due to nearby metal is possible if there is metal in the process, and if it is close enough (e.g., less than 1 µm away)
Silicon material absorption is negligeable
Silicon dioxide material absorption becomes significant for wavelengths longer than ~3.0 µm
Surface-state absorption is possible, if the waveguides are not passivated, and is a contributing factor.
Side-wall roughness scattering is the dominant mechanism.
Top-of-waveguide roughness scattering is present, however, this interface is created during the wafer manufacturing process.  Smoothing steps are taken to ensure an exceptionally smooth surface.



Could not parse problem




Perform numerical calculations for the following waveguide:



500 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm


TE polarization



Enter the effective index:






Explanation
To arrive at the correct answer, make sure you have done the following:
    Change the wavelength to 1550 nm.Follow the steps in the preceeding tutorial.
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




Perform numerical calculations for the following waveguide:


600 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm



TM polarization



Enter the effective index:






Explanation
To arrive at the correct answer, make sure you have done the following:
    Look at the 2nd mode, which should be TM polarized. The effective index is smaller than the TE mode.Change the wavelength to 1550 nm.Change the width of the waveguide to 600 nm.Increase the simulation region.  Check that the fields have decayed to 1e-9 (in energy).  This is achieved for an FDE simulation width of 3 micron, and height of 3.5 micron.  
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




The group index of the waveguide is a very important parameter, which as we will see, determines one of the most important features of the Mach-Zehnder Interferometer circuit -- the Free Spectral Range.
Find the group index for the following waveguide:



        500 nm width
      

        220 nm height
      

        silicon core
      

        oxide cladding
      

        wavelength = 1550 nm
      

        TM polarization (hint: this is the 2nd mode; the one with the TE polarization fraction (Ex) that is close to 0.)
      


Enter the group index:  (answer checked within +/- 0.03 of the instructor's answer)






Explanation
Make sure you make the following changes in the simulation:
  Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.Increase the number of simulation mesh points, e.g., 200.  Check the simulation mesh, and make sure it lines up with the waveguide edges.Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode. Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
If you are still not getting the same answer (but are "close"), continue on.  There is a unit "Convergence tests", which analyzes the sources of error in the simulations.




 Make sure you make the following changes in the simulation: 
 1) Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.   
 2) Increase the number of simulation mesh points, e.g., 200, or even more.  
 3) Check the simulation mesh, and make sure it lines up with the waveguide edges.  
 4) Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode.  
 5) Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
	  
If you are still not getting the same answer (but are "close"), continue on.  There is a later unit "Convergence tests", which analyzes the sources of error in the simulations.


Could not parse problem


Find a polynomial curve fit for the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide, in the 1500 to 1600 nm range.
    
 Note: when your run the code, the last plot is generated by the instructor's code. It allows you to compare your answer with the instructor's.
 Note: This is a graded problem.  Click "CHECK" to verify your answer.



      %%    

disp('****************************************************')
disp('The following output is generated by the instructor:')
	  
% Check fit:
if exist('r2')
  if lt(r2,0.8)
    disp 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.'
  end
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
end


% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

if gt(abs(X(1)-X_lukas(1)),0.01)
  disp ('The X(1) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(2)-X_lukas(2)),0.01)
  disp('The X(2) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(3)-X_lukas(3)),0.01)
  disp('The X(3) parameter is more than 1% different than the instructor answer.')
end

      



% User provides a matrix of neff values vs. wavelength
% Matlab curve fits to an expression.

url='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
a=websave('wg.mat',url); % get data from Dropbox
load('wg.mat');

neff = real(neff)  % take the real part of the effective index.

c=299792458;  % speed of light, m/s
lambdas = c ./ f;  % f is the matrix of frequency points, 
                   % where the effective index is recorded.
lambdas = lambdas * 1e6  % convert to microns.
lambda0 = 1.55;   % replace with desired centre wavelength

figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;

% use Matlab anonymous function for the effective index expression:
neff_eq = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 

% initial guess.
X=[2.4 0 0]; 

plot ( lambdas, neff_eq(X, lambdas), 'r')

% curve fit to find expression for neff.
format long
X = lsqcurvefit (neff_eq, X, lambdas, neff)

r=corrcoef(neff,neff_eq(X, lambdas));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

lambdas2=linspace(min(lambdas), max(lambdas), 100);

plot ( lambdas2, neff_eq(X, lambdas2), 'k')
xlabel ('Wavelength [nm]');
ylabel ('Effective Index');

legend ('Data','Initial Guess','Curve Fit')


      

If you don't have Dropbox, you can create the two variables to be used by the above code: neff, and lambdas.  Then proceed to curve fit this data, and compare to the instructor result.
	  

%%
% Grader:
%disp('****************************************************')
%disp('The following output is generated by the instructor:')

% Check:
if exist('url')
 url0='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
 assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
end
        
% Check fit:
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

% Check:
assert(lt(abs(X(1)-X_lukas(1)),0.01), 'The X(1) parameter is more than 1% different than the instructor answer.')
assert(lt(abs(X(2)-X_lukas(2)),0.02), 'The X(2) parameter is more than 2% different than the instructor answer.')
assert(lt(abs(X(3)-X_lukas(3)),0.1), 'The X(3) parameter is more than 10% different than the instructor answer.')
		
      



Could not parse problem





The objective of this problem is to create a compact model for the waveguide, in the form of an expression.  Find an expression for the effective index versus wavelength.

  Use (ONLY) the following parameters:
  lambda: units micronsthe other parameters should be numbers
Your expression will be verified with the instructor's answer.
The answer should be in the format such as "2.4 - 1 * (lambda-1.55) -0.1 *(lambda-1.55)^2" 

neff = "2.444509 -1.1273 * (lambda - 1.55) -0.03335 * (lambda-1.55)^2"







Explanation
The answer is in the form of \( n_\text{eff}(\lambda) = 2.4 - 1.1 (\lambda - 1.55) + 0.1 (\lambda-1.55)^2 \)



To check the answer, we evaluate your expression over a range of 1.5 to 1.6 microns.  We then compare to the instructor's answer, and check that the effective index you provide is within +/- 0.02 of the correct answer.  


Could not parse problem




What is the waveguide geometry that gives the smallest mode area, for the TE polarization at 1550, for a silicon thickness of 220 nm, strip waveguide?  Answer is the waveguide width, with units of nanometers (required accuracy with 20 nm).






Explanation
Find the smallest mode area to be for a waveguide of approximately 360 nm in width.



Modify the script to sweep (using a for loop), the waveguide width parameter (width_ridge in the script).  Plot the mode area and confinement factor, versus the waveguide width.  
Or do it manually, iteratively.


Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions).  You can ignore the radiation losses (loss in dB/cm in MODE Solutions) since they are small.  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is joined to the bent waveguide with no shift.
 
Determine the bend radius required for a TE mode to ensure that the loss is less than 0.1% (which is 0.004 dB) [Answer in microns, accuracy with +/-0.5]:






Explanation
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap.  Or you can use scripts, as provided in the next unit.
(Sorry for the brief explanation.  Post in the discussion below for more info.)



You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap calculations.  Do it iteratively, which only takes a few minutes. 
Or you can use scripts, as provided in the next unit.
The desired total transmission through the bend is 0.999.  Make sure that you are searching for the overlap value of sqrt(0.999).


Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions) and radiation losses (loss in dB/cm in MODE Solutions).  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is jointed to the bent waveguide with no shift.
 
Determine the bend radius required for a TM mode to ensure that the loss is less than 1% (which is 0.04 dB insertion loss)  [Answer in microns, accuracy with +/-1]:




Determine the bend radius required for a TM mode to ensure that the loss is less than 0.1%  [Answer in microns, accuracy with +/-3]:






Explanation
For 11 µm, we find:
  Propagation loss, coming from radiation loss:  0.277 dB/cm.  For a 1/4 circle, you can find the dB for the bend by: ?(-2*pi*11e-4/4*0.277); which is 0.000479 dB.  In linear units, this is   ?10^(-2*pi*11e-4/4*0.277 /10);  which is 0.99989.  Mode-mismatch loss, using overlap calculation:  0.99533Multiply the two together:  ?10^(-2*pi*11e-4/4*0.277 /10) *  (0.99533)^2; = 0.9906.

Quite likely your numbers will be slightly different, due to different simulation configuration (mesh, span, etc).   I used a span of 2.8 µm, with a 10 nm mesh.
  
              For 33 µm, we find:
  Propagation loss, coming from radiation loss: ~0 dB/cm. Mode-mismatch loss, using overlap calculation: 0.99951
(Post in the discussion below for more info.)



For the TM mode, you need to increase the thickness of the simulation, namely in the Z direction, so that the boundaries do not interfere with the simulation.  
If you are having trouble finding the TM mode: In the Eigenmode Analysis settings, you can also use search - near n - 1.8, to help the software find the correct TM mode. 
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap and radiation loss calculations.  Doing it manually, iteratively, only takes a few minutes.  
Or you can use scripts, as provided in the next unit.
Don't forget to consider that there are two mode-mismatch losses per bend, so square the overlap value.  And add the radiation loss in dB/cm times the length.


Could not parse problem

Calculate the mode-mismatch and radiation losses for the following bends, for TE polarization, 1550 nm wavelength [Answer in dB]:
Bend radius of 3 µm:




Bend radius of 5 µm:






Explanation
Can do it manually using mode overlap calculations, or using script.



Could not parse problem

Assume that 1 mW of light is input into an ideal Y-Branch splitter (Port E_0).  
The port labels in this problem are based on the diagram at 1:00 in the video.
_____________________________________________________________________________
How much optical power comes out of output 1 (Port E_1)? [Answer in mW]





Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.



Could not parse problem

Assume that 1 mW of light is input into ONE of the branches of an ideal Y-Branch combiner (Port E_1).  
The port labels in this problem are based on the diagram at 1:45 in the video.
_____________________________________________________________________________
How much optical power comes out of output 0 (Port E_0)?   [Answer in mW]





Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.



Could not parse problem




Assume a waveguide has the following effective index values:
  2.5 at 1.5 microns 2.4 at 1.6 microns 
What is the waveguide group index at 1.55 microns?






Explanation
ng = 2.45 - 1.55 * (-0.1)/0.1.



Could not parse problem




Assume an interferometer with the following properties:
  Wavelength of operation is 1.55 µmWaveguide's group index is 4.2Path length mismatch ∆L is 100 µm
What is the Free Spectral Range, in [nm]?






Explanation
FSR = 1.55e-6^2 / 100e-6 / 4.2 * 1e9
Don't forget to convert from meters to nanometers.



Make sure your answer is correct to +/- 0.01 nm.
The answer is in units of nanometers.


Could not parse problem


You may use this MATLAB window as a calculator to help you answer the questions.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem





Use the Matlab code below to plot the transfer function for the Mach-Zehnder Interferometer.
    

You will need to make adjustments to the constants in the model.  Specifically, change the following:
    n1, n2, n3: the compact waveguide model coefficients. lambda0: the centre wavelength used for the waveguide model. lambda_min, lambda_max: the wavelength range over which you want to plot.  lambda_step: the wavelength step for the plot. Keep in mind that the Agilent/Keysight Technologies laser (81600B) has a wavelength resolution of 0.1 pm, however, we perform automated measurements typically with a 10 pm resolution.  alpha: the propagation loss of the waveguide. L1, L2: the lengths of the two waveguides in the interferometer. 
Note that all constants are in units of microns, unless noted.

          


      %%    
      
      



% the wavelength range of interest.
lambda_min = 1.5;  % Units [µm, microns]
lambda_max = 1.6;
lambda_step = 0.01e-3; % wavelength step [microns]
                       % Typical minimum step for a tunable laser is 1-10 pm.
lambda=lambda_min:lambda_step:lambda_max;

% Define the MZI transfer function
%  use Matlab anonymous functions

% Effective index:
% - as a Taylor expansion around the central wavelength, lambda0
lambda0 = 1.55; n1=2.4; n2=-1; n3=0;  % these are constants from the waveguide model.
neff = @(lambda) ...
		(n1 + n2.*(lambda-lambda0) + n3.*(lambda-lambda0).^2); 
% plot, and check if this is as expected:
figure;
plot(lambda, neff(lambda),'LineWidth',3);

% Complex propagation constant
alpha = 1e-3;  % propagation loss [micron^-1]; constant
beta = @(lambda) ...
		(2*pi*neff(lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );


% MZI transfer function
T_MZI = @(L1, L2, lambda) ...
        ( 0.25* abs(exp(-1i*beta(lambda)*L1)+exp(-1i*beta(lambda)*L2)).^2);

% plot, and check if this is as expected:
L1=100;
L2=200;  % Units [µm, microns], variable
figure;
plot(lambda, T_MZI(L1, L2, lambda),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission');
axis tight
title ('MZI transfer function');

figure;
T_MZI_dB = 10*log10(T_MZI(L1, L2, lambda));
plot(lambda, T_MZI_dB,'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI transfer function');
      



        %%
var0=[n1, n2, n3, alpha, L1, L2];
var1=[2.4, -1, 0, 1e-3, 100, 200];
assert(not(isequal(var0,var1)), 'Looks like you just ran the code without changing the parameters: n1, n2, n3, alpha, L1, L2.  These are parameters specific to your waveguide and need to be changed.');
        
      



Could not parse problem




Answer this question by constructing the following circuit in Lumerical INTERCONNECT:
  Two grating couplers   Connect to a network analyzer.
Measure the best-case fibre-to-fibre insertion loss.
  
          Best-case insertion loss of two grating couplers (positive value, in dB, required accuracy +/- 0.1):





Could not parse problem




For your Mach-Zehnder Inteferometer designs, enter the parameter variations for the path length difference (∆L).  When you press "check", the system will give you some feedback - we are performing a simple sanity-check to make sure that your designs are reasonable.  
Keep in mind that the smallest laser step size is 1 pm, and the typical measurement bandwidth limited by the grating couplers is 50 nm.
 
Enter your design parameters separated by commas, in units of [µm]




def make_a_list(name_string):
    return name_string.split(',')

def count_names(name_list):
    return len(name_list)

def num(s):
    try:
        return float(s)
    except ValueError:
        return 0
      
def how_many_oli(expect, ans):
    names = make_a_list(ans)
    how_many = len(set(names))
    message_hint = ''
    check = True
    for e in names:
        e=e.strip('"')
        e=e.strip("'")
        e=e.strip()
        e=e.lower()
        dL=num(e)
        who_is = e
        if dL &lt; 22:
            if dL == 0:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" (0) micron, you may still have a path length mismatch due to fabrication variations.  \n "
                check = False
            else:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, you will not see oscillations within the measurement span; longer path length mismatch required.  \n"
                check = False
        if dL &gt; 57200:
            message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, we will not be able to resolve the oscillations since they the FSR is too small and the loss differential too high; shorter path length mismatch required.  \n"
            check = False
    if how_many &lt; 1:
        return { 'ok': False, 'msg': 'None at all?'}
    if how_many &lt; 5:
        return { 'ok': check, 'msg': 'Only '+str(how_many)+" variations?  "+message_hint}
    if how_many == 5:
        return { 'ok': check, 'msg': message_hint }
    if how_many &gt; 5:
        return { 'ok': check, 'msg': message_hint }
    return False

  





Explanation
Assuming you want to see oscillations versus wavelength, the minimum path length difference is limited by span.  For 50 nm, 2 oscillations, is FSR = 25 nm.  Assuming ng=4.2, the min dL is ~ 23 µm.

            The maximum path length difference, to be able to resolve oscillations with 10 points per oscillation: 1 point is 1 pm, 10 is 10 pm.  So FSR is 10 pm, hence max ∆L=57 mm.  Assuming 3 dB/cm, this would yield a 17 dB loss difference.  The oscillation fringes would not be visible.  For such a large path-length mismatch, lower loss waveguides would be required (e.g., 3 µm wide multi-mode waveguide).
          



Could not parse problem


Use the Matlab code below to download and plot the measurement data.  The data is for two TE grating couplers, connected with a short waveguide (about 150 microns).  
  

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');
     
      







Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The fibre grating couplers must be vertically spaced exactly 127 µm apart, and horizontally aligned.  In this layout, the bottom grating coupler is offset hence light will not be efficiently coupled into the bottom fibre. 



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The highlighted waveguide has sharp 90º angles; these should be replaced with smooth 90º bends to provide low optical loss and low back-reflections.  



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
This layout is missing a label for the automated measurements, e.g., "opt_in_TE_1550_device_LukasChrostowski_MZI3".  



Could not parse problem

Consider an EBL system with a minimum writing grid of 1 nm, and a field size of 1 mm.   
How many bits are required in the Digital to Analog converter (DAC) to achieve the necessary resolution? [answer is an integer]





Explanation
The distance is twice that of the 500 µm example, hence one extra bit, thus 20.



Could not parse problem

Consider a single chip, with four quarters each with a design area of 8.8 mm x 8.8 mm.  
Consider a single participant design size of 605 x 410 µm.  
How many participant designs can fit on a single chip? [required answer accuracy +/- 100]






Explanation
in MATLAB: answer = floor(8800/410)*floor(8800/605)*4 = 1176.
Spread the word about this course, since we have a lot more room for designers.



Our chip is at about 10% capacity.  Spread the word about this course, since we have a lot more room for designers.


Could not parse problem

Consider a single chip, with a design area of 8.8 mm x 8.8 mm.  
Consider an extremely dense silicon photonic waveguide-based circuit, consisting of 500 nm wide waveguides, on a 3 µm centre-to-centre pitch.  Assume these waveguides are covering the entire chip.  The layout is to be fabricated with a 6 nm shot pitch on the JEOL EBL system at UW, and written with a dose of 2800 uC/cm^2. 
How long would it take to write this chip? [answer in Hours, required answer accuracy +/- 1.0]






Explanation
in MATLAB:
Dose = 2800/1e4^2 % convert µC/cm^2 to µC/µm^2
A_written=(8800*.5/3)*(8800) % in µm^2
Ibeam = 8000/1e6 % convert pA to µA
t_seconds = Dose * A_written / Ibeam
t_minutes = t_seconds / 60
t_hours = t_minutes / 60
 ANSWER 12.5 hours.  



You can use Matlab to calculate using the formula t_seconds = Dose * A_written / Ibeam.  Don't forget to convert the units.
You can use the provided online EBEAM calculator.
The machine can be left running overnight.


Could not parse problem

Consider an MZI that was designed to be balanced, with both path lengths being 100 µm.  Assume a lossless interferometer, such that if it was perfectly manufactured, it would have 100% transmission at 1550 nm.
Consider a chip where due to on-chip manufacturing variations, the effective index of the two waveguides differs by 0.00775.
What is the transmission of this MZI? [answer in percentage, an integer without the % symbol. required answer accuracy of +/-1%].






Explanation
dneff=0.00775
L=100e-6
dbetaL = 2*3.1415*dneff*L/1550e-9 = 3.1415
Pi phase shift results in desctructive interference, or 0 transmission.



You'll probably need to go back to the interferometer equations (Photonic Circuits | Modelling - MATLAB | MZI Transfer Function).
The ideal design has 100% transmission due to constructive interference.  What happens if there is a relative phase shift between the waveguides?


Could not parse problem

Perform the corner analysis on the 500x220 nm waveguide, for TE, at 1550 nm.  Determine the range of values possible for the group index, ng.



Assume that the wafer thickness varies between 215.3 and 223.1 nm
Assume that the waveguide width varies between 470 and 510 nm


What is the minimum value for the group index? [answer within an accuracy of +/- 0.02]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.02]






Explanation
No explanation yet.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the 9 cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength).
  


Could not parse problem

Consider an MZI with a ∆L = 100 µm, with 500x220 nm waveguides, operating in the TE polarization, at 1550 nm.  Using a corner analysis, determine the range of values possible for the Free Spectral Range.
What is the minimum value for the FSR? [answer in units of nm, within an accuracy of 0.03] 




What is the maximum value for the FSR?






Explanation
.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the 9 cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength), then using the formula for FSR for the given ng values.
  


Could not parse problem

  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 



      %%    
      
      







        %%
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');


     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 
figure;
plot (lambda*1e6, amplitude); hold all;
plot (lambda*1e6, amplitude_baseline, 'LineWidth',4);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with polymial fit)');

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');
     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem




In this section, you can calibrate a measured spectrum using a "loopback" structure.
Objective:



remove the baseline shape of the grating couplers



Method:



curve-fit the spectrum of two grating couplers (or an MZI with ∆L=0) using a low-order polynomial
Restrict to ~10 dB from peak to avoid using data with a large error
Subtract this polynomial from subsequent data



You can download and run the Matlab code on your own computer. 

Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      




% Read data files from experiments
% Enter the Dropbox URLs here.  Make sure the URL has a =1 at the end:
%  Loopback structure:
	url_loopback = 'https://www.dropbox.com/s/w915qfix9kwlwv7/ZiheGao_MZI1_272_Scan1.mat?dl=1';
%  MZI:
	url_mzi = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
% Calibrate the MZI data using the loopback structure
% Plot


PORT=1; % Which Fibre array port is the output connected to?
FONTSIZE=20;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Loopback data:
a=websave('loopback.mat',url_loopback); % get data from Dropbox
load('loopback.mat');
% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda*1e6, amplitude);
title ('Calibration loopback'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)
hold all;

% Fit the data with a polynomial
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 5);
amplitude_LOOPBACK=polyval(p,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, amplitude_LOOPBACK);
% find wavelength range with usable data, in the loopback
loopback_IL = max(amplitude);
new_lambda_i=find(amplitude>loopback_IL-10);
lambda=lambda(new_lambda_i);
lambda_min = min(lambda);
lambda_max = max(lambda);
amplitude=amplitude(new_lambda_i);
% refit the loopback
LOOPBACK=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_LOOPBACK=polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, [amplitude_LOOPBACK],'r-','Linewidth',5);
axis tight;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data:
a=websave('mzi.mat',url_mzi); % get data from Dropbox
load('mzi.mat');
lambda1=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda1*1e6, amplitude);
title ('MZI (raw data)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data - calibrated
%
% data only within the bandwidth of interest.
lambda=lambda_min:min(diff(lambda1)):lambda_max;
amplitude=interp1(lambda1, amplitude, lambda,'linear');
amplitude(find(amplitude==-inf))=-50;
% calibrate data
amplitude_cal=amplitude-polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
figure;
plot (lambda*1e6, amplitude_cal);
title ('MZI (calibrated with loopback)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)


    
      



        %%
	url_mzi0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url_mzi0, url_mzi)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

You will need to make adjustments to the initial parameters for the fitting function.  Specifically, change the following line:
  

   nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
  

 Check your answer when you think you have a good fit.  
  



      %%    
      
      




% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
lambda0 = mean(lambda)*1e6;		
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.

% initial function for fitting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];
figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');

% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      

nx_init = [2.4, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
      

        %%
%url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
%assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  



      %%    
      
      



% Lukas Chrostowski, curve fitting the MZI using findpeaks, 2015/08/14

% Enter the Dropbox URL here.  Make sure it has a =1 at the end:

% TE
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

% TM:
%url = 'https://www.dropbox.com/s/onjwrarapf6dumv/ADCL_1_1153_Scan1_L2-L1%3D100um.mat?dl=1';
%dL = 100;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
if not(exist('lambda_min'))
	lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
end
if not(exist('lambda_max'))
	lambda_max = max(lambda);   %  if the data on the edges is noisy
end
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find peaks, extract FSR and ng, and neff
% as initial parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% smooth (0.1% moving average filter)
windowSize = floor(1e-3*length(lambda)); b = (1/windowSize)*ones(1,windowSize);
amplitude_smooth=filter(b,1,amplitude);
% FIND PEAKS
[pks,x_values,w,p]=findpeaks(-amplitude_smooth, lambda, 'minPeakProminence',4,'Annotate','extents');

% plot spectrum with peaks
figure;
plot (x_values*1e6, interp1(lambda, amplitude, x_values,'pchip'), 'ro','MarkerSize',10); 
hold all;
plot (lambda*1e6, amplitude_smooth);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with peaks)');

% Calculate and plot ng data points from FSR
lambda_ng = (x_values(1:end-1)+x_values(2:end))/2;
FSR=(x_values(2:end)-x_values(1:end-1));
ng = abs(lambda_ng.^2/1/(dL*1e-6)./FSR);
% find average ng from all reasonable ng values:
indexes = find(gt(ng,3)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
indexes = find(lt(ng,5)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
ng_av = mean(ng);
if eq(length(ng),0)
  disp ('No group index values found.  Terminating script.');
  break
end
disp (['(estimate) Group index: ' num2str(ng_av)])

% plot FSR
figure;
plot (lambda_ng*1e6, FSR*1e9, '-o','LineWidth',1,'MarkerSize',7 );
xlabel ('Wavelength [\mum]')
ylabel ('Free Spectral Range [nm]')
xlim([min(lambda), max(lambda)]*1e6);
title ('Free Spectral Range, from Experimental data');

% plot ng
figure
plot (lambda_ng*1e6, ng, '-o','LineWidth',1,'MarkerSize',7 )
xlabel ('Wavelength [\mum]')
ylabel ('Group Index')
xlim([min(lambda), max(lambda)]*1e6);
title ('Waveguide Group Index, from Experimental data');


% find starting point for curve fitting MZI, using the ng data
% Part 1 - n1
% lambda0 is in microns.
lambda0 = x_values(floor(length(x_values)/2)) * 1e6;
n1_initial=2.4;
modeNumber = n1_initial * dL / lambda0 - 0.5;
n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
% Part 1 - n2 from ng_av
n2 = (n1-ng_av)/lambda0;
% Part 3 - n3 from slope of ng vs. lambda, to get the dispersion
f_line = @(x,xdata)x(2)*xdata+x(1);
[xfit,resnorm]  = lsqcurvefit(f_line,[ng_av 0],lambda_ng*1e6,ng);
r=corrcoef(ng,f_line(xfit, lambda_ng*1e6));
r2_ng=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2_ng)] )
hold all;
plot (lambda_ng*1e6, f_line(xfit, lambda_ng*1e6),'LineWidth',3)
n3 = -xfit(2)/2/lambda0;
Dispersion0 = -(lambda0*1e-6) / 299792458 * 2* (n3*1e12) * 1e12 /1e9 /1e-3;     	
disp (['(estimate from ng slope) Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
if lt(r2_ng,0.01)   % only use the result if the fit is good
  n3 = 0;
end

% Initial conditions for fitting:
nx_init = [n1 n2 n3];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];

	
% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'-','LineWidth',2);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  disp (['Waveguide parameters at wavelength [um]: ' num2str(lambda0)])
  ng0 = xfit(1) - lambda0*xfit(2);
  disp (['Group index: ' num2str(ng0)])

  % Dispersion:
  c=299792458;	
  Dispersion0 = -(lambda0*1e-6) / c * 2* (xfit(3)*1e12);  % [s/m^2]
  % [ps/nm/km]: 
  Dispersion0 = Dispersion0 * 1e12 /1e9 /1e-3;
  disp (['Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
  
  
end
      



        %%
		
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');

      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  



      %%    
      
      





% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

%url = 'https://www.dropbox.com/s/zojmleq3gu77dsw/ZiheGao_MZI17_265_Scan1.mat?dl=1';
%dL = 219.366;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find ng from autocorrelation-based frequency estimation of spectrum
% auto-correction
[r,lags]=xcorr(amplitude); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
figure
plot(lags,r);
% estimate the frequency
d=diff(r);
start = find(gt(d,0)); start=start(1);
[peak_m, peak_i]=max(r(start:end));
peak_i=peak_i+start;  % location of the 1st peak in the autocorrelation
hold on;
plot(peak_i,0,'s','MarkerSize',20);
title ('Autocorrelation of spectrum')
xlabel('lag, sample number');

fsr = peak_i * mean(diff(lambda))
ng_av = mean(lambda)^2/(dL*1e-6)/fsr


% find starting point for curve fitting, using the ng value
% lambda0 is in microns.
lambda0 = mean(lambda) * 1e6;
n1=2.4;
%modeNumber = n1_initial * dL / lambda0 - 0.5;
%n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
n2 = (n1-ng_av)/lambda0;
nx_init = [n1 n2 0];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Autocorrelation again, to find the shift between the fit function and experimental data
[r,lags]=xcorr(amplitude, T_MZI(x0, lambda*1e6)); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
[peak_m, peak_i]=max(r);
lambda_offset = peak_i(1) * mean(diff(lambda));
n_shift = lambda_offset*lambda0/fsr/dL;
x0(1)=x0(1)+n_shift;

figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters, with shift)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem






      %%    
      
      







        %%
   
        
      



Could not parse problem


    This is a blank Matlab window. You can use it to analyze your own data.  

  



      %%    
      
      







        %%
   
        
      



Could not parse problem



Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 


Could not parse problem

Unbalanced MZI Interferometer, TM polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TM_1550_device_LukasChrostowski_MZI_TM_oneside". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.03]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.03]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TM_oneside.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.02]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100; within an accuracy of +/- 2 %]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://upload.siepic.ubc.ca/uploads/lukasc_TETM_simVSexp_2015_08_17_23_26_59.zip  




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
Follow the Convergence Tests section, in Waveguide Modelling - Lumerical MODE
The TM layout used a bend radius of 10 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of lambda_min=1.54e-6; lambda_max=1.56e-6.
     


Could not parse problem

Unbalanced MZI Interferometer, TE polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TE_1550_device_LukasChrostowski_MZI_TE_oneside2". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.02]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.02]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.02]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.02]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TE_oneside2.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.04]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100 percent; within an accuracy of +/- 2 (%)]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://upload.siepic.ubc.ca/uploads/lukasc_TETM_simVSexp_2015_08_17_23_26_59.zip 




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
The TE layout used a bend radius of 5 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of          lambda_min=1.543e-6; lambda_max=1.557e-6.
     


Could not parse problem

  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 



      %%    
      
      







        %%
      



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
Query done.
Processed: 5.9 MB

Retrieving results...
Got 5803 rows.

Total time taken 6.06 s.
Finished at 2017-06-30 20:46:39.
Saved to ./../data/Phot1x_3T2015/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 13.02 s. Waiting...
Query done.
Processed: 356.9 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 15.82 s.
Got 265 rows.

Total time taken 15.83 s.
Finished at 2017-06-30 20:46:57.
Saved to ./../data/Phot1x_3T2015/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 13.31 s. Waiting...
  Elapsed 23.72 s. Waiting...
Query done.
Processed: 318.5 MB

Retrieving results...
  Got page: 1; 5% done. Elapsed 34.18 s.
  Got page: 2; 9% done. Elapsed 38.08 s.
  Got page: 3; 14% done. Elapsed 43.8 s.
  Got page: 4; 19% done. Elapsed 48.28 s.
  Got page: 5; 23% done. Elapsed 54.29 s.
  Got page: 6; 28% done. Elapsed 59.69 s.
  Got page: 7; 32% done. Elapsed 64.49 s.
  Got page: 8; 37% done. Elapsed 70.17 s.
  Got page: 9; 42% done. Elapsed 79.54 s.
  Got page: 10; 46% done. Elapsed 85.56 s.
  Got page: 11; 51% done. Elapsed 91.24 s.
  Got page: 12; 56% done. Elapsed 95.94 s.
  Got page: 13; 60% done. Elapsed 101.41 s.
  Got page: 14; 65% done. Elapsed 106.44 s.
  Got page: 15; 70% done. Elapsed 111.94 s.
  Got page: 16; 74% done. Elapsed 116.4 s.
  Got page: 17; 79% done. Elapsed 121.79 s.
  Got page: 18; 83% done. Elapsed 126.25 s.
  Got page: 19; 88% done. Elapsed 131.09 s.
  Got page: 20; 93% done. Elapsed 136.12 s.
  Got page: 21; 97% done. Elapsed 143.42 s.
  Got page: 22; 100% done. Elapsed 147.47 s.
Got 503369 rows.

Total time taken 167.42 s.
Finished at 2017-06-30 20:49:46.
Saved to ./../data/Phot1x_3T2015/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 8.5 KB

Retrieving results...
Got 126 rows.

Total time taken 0.88 s.
Finished at 2017-06-30 20:49:56.
Saved to ./../data/Phot1x_3T2015/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 20.1 KB

Retrieving results...
Got 121 rows.

Total time taken 1.6 s.
Finished at 2017-06-30 20:49:59.
Saved to ./../data/Phot1x_3T2015/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 597.3 KB

Retrieving results...
Got 1496 rows.

Total time taken 1.83 s.
Finished at 2017-06-30 20:50:02.
Saved to ./../data/Phot1x_3T2015/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 703.7 KB

Retrieving results...
Got 359 rows.

Total time taken 1.01 s.
Finished at 2017-06-30 20:50:04.
Saved to ./../data/Phot1x_3T2015/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.3 MB

Retrieving results...
Got 22263 rows.

Total time taken 3.8 s.
Finished at 2017-06-30 20:50:09.
Saved to ./../data/Phot1x_3T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 70.8 KB

Retrieving results...
Got 689 rows.

Total time taken 0.89 s.
Finished at 2017-06-30 20:50:12.
Saved to ./../data/Phot1x_3T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 83.2 MB

Retrieving results...
Got 10322 rows.

Total time taken 3.92 s.
Finished at 2017-06-30 20:50:17.
Saved to ./../data/Phot1x_3T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 226.4 KB

Retrieving results...
Got 689 rows.

Total time taken 0.93 s.
Finished at 2017-06-30 20:50:20.
Saved to ./../data/Phot1x_3T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 4.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 7.8 s.
Got 62 rows.

Total time taken 7.8 s.
Finished at 2017-06-30 20:50:29.
Saved to ./../data/Phot1x_3T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 4.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 14.75 s.
Got 19650 rows.

Total time taken 15.16 s.
Finished at 2017-06-30 20:50:45.
Saved to ./../data/Phot1x_3T2015/page_dirt.csv
Could not parse problem


Click "run" to execute the code.  



      %%    
      
      



a=1
b=2
c=a+b
        
% Practice figures:        
x=1:0.1:10;
figure; plot (x, sin(x)); title ('The First figure');
figure; plot (x, exp(x)); title ('The Second figure');
        
      



%%     
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem




Consider a Si/SiO2 waveguide, and assume that the light is travelling as follows: 90% in silicon, and 10% in silicon dioxide.  Assume the mode profile does not change in the following questions:
Q1: If the wavelength increases by 10 nm, by how much will the effective index change?




Q2: If the temperature increases by 10 C, by how much will the effective index change?




Q3: Let's find out if we can ignore the temperature dependance of SiO2 in our models.  Repeat the above Q2 calculation, this time assuming a constant SiO2 material model.  How much error would be introduced in the change in effective index versus temperature, if a constant SiO2 material model was used? (answer in %) 
 \( \% error = \frac{\text{Correct}-\text{Incorrect}}{\text{Correct}} \cdot 100 \)






Explanation
For a 10 nm change in wavelength: 10 nm * ( 0.9 * -7.6e-5 /nm + 0.1 * -1.2e-5 /nm ) = -6.96e-4
For a 10 C change in temperature: 10 K * ( 0.9 * 1.87e-4 /K + 0.1 * 8.5e-6 /K ) = 1.6915e-3
For a 10 C change in temperature, but only considering dn_Si / dT, 10 nm * ( 0.9 * 1.87e-4 /K ) = 1.683e-4.  Hence, the error is: 
(1.6915-1.683) / (1.6915) = 0.00502, or 0.5%



For the effective index, in Q1-3, approximate this as a weighted average of the refractive index values in each medium. 
For Q3: Modify your equation in Q2 to assume that there is no temperature dependence in the SiO2.  Note that 10% of the light is still in the SiO2, and 90% is in silicon. 
For Q3, the answer is a number.  Don't include the % symbol in the answer. 


Could not parse problem


You can use this MATLAB window to perform the calculations necessary for the problems.
  

      Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.


  



      %%    
      
      


        
format long;  % display many significant digits; optional

delta_T = 10;
Thermal_coefficient = 0.01;  % replace with correct value
delta_n = Thermal_coefficient * delta_T
        
      



        %%
   
        
      



Could not parse problem




In this exercise, we wish to understand why the wafers we are using have a thickness of 220 nm. 
 You can use the analytic method with the script provided below (in MATLAB) to answer this question.  You can also download the script (wg_1D_analytic.m). 
Question – What is the maximum Si thickness before the slab waveguide supports more than one TE mode? 
Enter the thickness, in [nm, accuracy +/-5 nm]:






Explanation




Use the Matlab code below.  You can do this problem by trial and error, with your own iterations.  
Change the thickness of the waveguide -- the default is 0.22e-6 m.  You will see that nTE = xxxx: namely it supports a single mode.  Try increasing it, say to 0.5e-6.  You will see that nTE = xxxx, xxxx, xxx: namely it supports multiple (3) modes.  Find the value where the 2nd mode just disappears.  
You could also make a script with a "for" loop, and plot the number of modes versus the thickness.  The number of modes would be found by the command length(nTE).  


Could not parse problem


Use the following Matlab code to answer the question on slab waveguides.
  
To change the thickness, change the number 0.22e-6 in the following line: 



[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
  



Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_analytic.m - Analytic solution of a slab waveguide
% by Lumerical Solutions, http://www.lumerical.com/mode_online_help/slab_wg.m
% modified by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3
% finds the TE and TM effective indices of a 3-layer slab waveguide

% usage:
%  - get effective indices for supported modes:
%  [nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
%  - optional, for plotting: TEparam,TMparam: h, q, p parameters of the mode.


function main
	[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
      



        %%
   
        
      



Could not parse problem




 We know that some of the light is travelling outside the waveguide.  This is an important concept to understand as it has several implications: 
  It leads to the concept of waveguide dispersion, and has a huge impact on the group index, \( n_g \) The field outside the waveguide can be used to make evanescent field sensors, e.g., bio applications.  (Note - replace SiO2 with air, water, etc, for biosensors) 
  Hence, we wish to study how far the fields extend above the waveguides.  We consider the two polarizations (TE, TM) guided by the 220 nm slab waveguide. 
          Question - For the TE polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point (of the value at the interface):




Question - For the TM polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point:






Explanation
TE Polarization:

Measure the field at the interface.
Find the 1/e point.  If the field is 0.66 at the interface, take 0.66 / e = 0.66 / 2.71 = 0.243.  Find the x value for this point, which is approximately 200 nm.
Measure the distance from the interface: 200-110 = 90 nm.

TM Polarization:

The MATLAB code needs to be motified to plot TM_E (the E-field for the TM polarization) instead of TE_E (the E-field for the TM polarization)
Measure the field at the interface.
find the 1/e point.  if the field is 0.77 at the interface, take 0.77 / e = 0.28.  Find the x value for this point, which is approximately 280 nm.
measure the distance from the interface: 280-110 = 170 nm.




Could not parse problem

You can run the MATLAB code provided in the web browser below.  Or, you can download the code and run it directly on your computer (wg_1D_mode_profile_main.m)
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_mode_profile.m - Calculate the 1D mode profile of a slab waveguide
% by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3.2
% - function returns mode profiles for TE and TM modes (E, H components)
% usage, e.g.:
%  [x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444, 100, 4)
%  plot (x, TE_E); 
%  plot (x, TM_E); 



function main
	thickness=0.22e-6;  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	[x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile ...
		(1.55e-6, thickness, 1.444, 3.47, 1.444, 100, 3);
	g=rectangle('Position',[-thickness*1e9/2,0,thickness*1e9,1],'FaceColor',[.8 .8 .8 0.2]); hold all;
	plot (x*1e9, TE_E/max(max(TE_E)), 'LineWidth',3);
	xlabel('Position [nm]');
	ylabel('Field Amplitude');
	ax=gca;
	set(ax, 'FontSize',15);
	ax.XTick = [floor(min(x)*1e9/100)*100:200:floor(max(x)*1e9/100)*100];
	axis tight;
	grid on; box on;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
	x1=linspace( -M*t, -t/2, pts); x2=linspace( -t/2, t/2, pts); 
	x3=linspace( t/2, M*t, pts); x=[x1 x2 x3];
	nx=[n1*ones(pts,1); n2*ones(pts,1); n3*ones(pts,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);     
      



        %%
   
        
      



Could not parse problem

Simulation results for the strip waveguide, TE polarization, show that the effective index decreases with increasing wavelength.
What is the main reason that the waveguide's effective index decrease with wavelength?





Explanation
Both Material and Waveguide dispersion contribute.  However, material dispersion accounts for a small portion of the total dispersion; recall that the group index of silicon is ~3.6, which is ~0.1 higher than the refractive index of silicon (n_Si).  In contrast, the group index for the waveguide is ~4.2, which is ~0.7 higher than n_Si.  If one was to simulate the waveguide without material dispersion (setting n_Si = 3.47, a constant), one would find that the group index is ~0.6 higher than the n_Si.  Thus, the waveguide dispersion is the dominant effect.
To get an intuitive understanding, simulate the mode for different wavelengths.  You will see that the mode is more spread out for longer wavelengths.  
Intuitively, more light is travelling through the lower index cladding for longer wavelengths.  The effective index can be thought of as a weighted average of the material indices, based on the mode profile.  Hence, less light in the silicon core for longer wavelengths leads to a lower effective index.



Could not parse problem

Question - 1 attempt only:
Simulation results for the strip waveguide show that the effective index increases with increasing geometry (width or thickness).
What is the main reason that the waveguide's effective index increasing with width?





Explanation
The answer is similar to model dispersion described above.  
To get an intuitive understanding, simulate the mode for different geometries.  You will see that the mode is more spread out for smaller waveguides with tails extending into the cladding.  In contrast, larger waveguides have more light inside the core.  
Hence, for larger geometries, more light in the silicon core, and this leads to a higher effective index.



Could not parse problem




Using the Effective Index Method, find the fundamental TE mode effective index at 1500 nm.
n_eff: Effective index of the waveguide:






Explanation
Change the wavelength in the code...  The first parameter is wavelength, in: wg_EIM_profile (1.50e-6, ...
Run the matlab code.
See the effective index displayed.



Could not parse problem


Use the Matlab code below (Effective Index Method, field profile) to view the field profile for a 500 x 220 nm waveguide.
  
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_EIM_profile.m - Effective Index Method - mode profile
% Lukas Chrostowski, 2012
% usage, e.g.:
%  wg_EIM_profile (1.55e-6, 0.22e-6, 0.5e-6, 90e-9, 3.47, 1, 1.44, 100, 2)

function main
	[neff_TEwg]=wg_EIM_profile (1.60e-6, 0.22e-6, 0.5e-6, 0, 3.47, 1.44, 1.44, 100, 2)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [neff_TEwg]=wg_EIM_profile (lambda, t, w, t_slab, n_core, n_clad, n_oxide, pts, M)

	% find TE (TM) modes of slab waveguide (waveguide core and slab portions):
	[nTE,nTM]=wg_1D_analytic (lambda, t, n_oxide, n_core, n_clad);
	if gt(t_slab,0)
		[nTE_slab,nTM_slab]=wg_1D_analytic (lambda, t_slab, n_oxide, n_core, n_clad);
	else
		nTE_slab=n_clad; nTM_slab=n_clad;
	end
	[xslab,TE_Eslab,TE_Hslab,TM_Eslab,TM_Hslab]=wg_1D_mode_profile (lambda, t, n_oxide, n_core, n_clad, pts, M);

	figure%(1);  clf; subplot (2,2,2); 
    Fontsize=15;
	plot(TE_Eslab/max(max(TE_Eslab)),xslab*1e9,'LineWidth',4);hold all;
	ylabel('Height [nm]','FontSize',Fontsize); 
	xlabel({' ','E-field (TE)'},'FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize,'XTick',[]);
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);
	Ax1 = gca; Ax2 = axes('Position',get(Ax1,'Position'));
	get(Ax1,'Position');
    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
	plot (nx, xslab*1e9,  'LineWidth',0.5,'LineStyle','--','parent',Ax2); 
	a2=axis; axis ([a2(1), a2(2), a(3), a(4)]);
	set(Ax2,'Color','none','XAxisLocation','top', 'YTick',[],'TickDir','in'); 
	set(gca,'YAxisLocation','right'); box off;
	xlabel('Material Index','FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize); 
%    print -dpdf eim1.pdf

	% TE-like modes of the etched waveguide (for fundamental slab mode)
	%   solve for the "TM" modes:
	[nTE,nTM]=wg_1D_analytic (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1));
	neff_TEwg=nTM;
	[xwg,TE_E_TEwg,TE_H_TEwg,TM_E_TEwg,TM_H_TEwg]=wg_1D_mode_profile (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1), pts, M);

    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
    figure%(1); subplot (2,2,3);
    % Plot the data on with a left and right axes. Return the axes and line
    % objects.
    [ax, h1, h2] = plotyy(xwg*1e9, TM_E_TEwg(:,1)/max(max(TM_E_TEwg)), xwg*1e9, nx);
    % Set the Xlabel and yLabel of each axes
    xlabel('Position [nm]','FontSize',Fontsize);
    ylabel(ax(1),'E-field (TM, TE-like mode)','FontSize',Fontsize);
    ylabel(ax(2), 'Slab Effective Index','FontSize',Fontsize);
    % Change the color of the right axes and the line style of line plot
    % associated with that axes.
    ax(2).YColor = 'b';
    h2.LineStyle = '--';
    h2.LineWidth = 0.5;
    h2.Color = 'b';
    % Set the Line width of the two line plots of the left axes.
    h1(1).LineWidth = 4;
    % Remove the left Tick labels.
    ax(1).YTick = [];
    % Set the YLim property so the plots line up.
    ax(2).YLim = [1.4, 2.6];
    ax(2).YTick = 1.4:0.2:2.6;
    
    % Plot the product of the two fields
	figure%(1); subplot (2,2,1);
	Exy=TM_E_TEwg(:,1)*(TE_Eslab(1,:));
	contourf(xwg*1e9,xslab*1e9,abs(Exy')/max(max(Exy))')
    % colormap('jet')
    axis equal
	xlabel ('X (nm)','FontSize',Fontsize); 
	ylabel ('Y (nm)','FontSize',Fontsize); 
	set (gca, 'FontSize',Fontsize); 
	A=axis; axis([A(1)+0.4, A(2)-0.4, A(3)+.2, A(4)-0.2]);
	title('Effective Index Method');
	% Draw the waveguide:
	rectangle ('Position',[-w/2,-t/2,w,t]*1e9, 'LineWidth',1, 'EdgeColor','white')
	if gt(t_slab,0)
		rectangle ('Position',[-M*w,-t/2,(M-0.5)*w, t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
		rectangle ('Position',[w/2,-t/2,(M-0.5),t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
    end

    
function draw_WG_vertical(M)
	pP=get(gca,'Position');pPw=pP(3); 
	pPc=pP(3)/2+pP(1); pP2=pPw/4/M;
	annotation ('line',[pPc-pP2,pPc-pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	annotation ('line',[pPc+pP2,pPc+pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	axis tight; a=axis; axis ([a(1), a(2), a(3)*1.1, a(4)*1.1]);

function draw_WG_horiz(M)
	pP=get(gca,'Position');pPw=pP(4); 
	pPc=pP(4)/2+pP(2); pP2=pPw/4/M;
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc-pP2,pPc-pP2],'LineStyle','--');
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc+pP2,pPc+pP2],'LineStyle','--');
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
    x1=linspace( -M*t, -t/2, pts); 
    x2=linspace( -t/2, t/2, pts); x2 = x2(2:end);
    x3=linspace( t/2, M*t, pts);  x3 = x3(2:end);
    x=[x1 x2 x3];
    nx=[n1*ones(pts,1); n2*ones(pts-1,1); n3*ones(pts-1,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
			     
      



        %%
   
        
      



Could not parse problem

Part 1

Using this tool, compute the mode profile and calculate the effective index of the fundamental TE mode for a 450x220 nm waveguide at 1550 nm.
    
Note:  This is a graded code box.  When ready, press "CHECK". After your code executes, additional code on the server will check your answer.  
  



      %%    
      global neff
      



% This example computes the field components and the effective index of a
% silicon-on-insulator strip waveguide.
% slightly modified version, from: http://www.photonics.umd.edu/software/wgmodes/
function [neff]=main

	global neff w  % Used by the auto-graded to check your answer.

	n1 = 1.44;          % SiO2 lower cladding
	n2 = 3.47;          % Silicon core
	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 2.5;           % grid size (x)
	dy = dx;            % grid size (y)

	lambda = 1550;      % wavelength (nm)
	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

	fprintf (1,'post-processing... '); t = cputime;

	[Hz,Ex,Ey,Ez] = postprocess (lambda, neff, Hx, Hy, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf (1,'graphing... '); t = cputime;

	hn = abs(interp2(y,x,Hy,h1+h2/2,0));
	en = abs(interp2(yc,xc,Ex,h1+h2/2,min(dx)/2));

	% Plot |E| profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,sqrt(abs([-Ex(end:-1:1,:);Ex]).^2+abs([-Ey(end:-1:1,:);Ey]).^2+abs([-Ez(end:-1:1,:);Ez]).^2)/en);
	title('|E|');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% could normalize the |E| plot to show energy...
	%size (eps)

	% figure;
	% imagemode(x,y,Hx/hn);
	% title('Hx');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hy/hn);
	% title('Hy');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hz/hn);
	% title('Hz');
	% for v = edges, line(v{:}); end

	% Plot Ex profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,[-Ex(end:-1:1,:);Ex]/en);
	hold on;
	contourmode([-xc(end:-1:1);xc],yc,[-Ex(end:-1:1,:);Ex]/en,(0:-5:-60));
	title('Ex');
	v = xlim();
	line(v,[h1,h1], 'Color', 'k');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% figure;
	% imagemode(x,y,Ey/en);
	% title('Ey');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Ez/en);
	% title('Ez');
	% for v = edges, line(v{:}); end
	
	% figure;
	% imagemode(x,y,sqrt(abs(Ez).^2+abs(Ey).^2+abs(Ex).^2)/en);
	% title('|E|');
	% for v = edges, line(v{:}); end

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

end

function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end

      

	  % Change the width of the waveguide to 450 nm, via the following variable on line 22:
      w = 450;
	  

        %%
      global neff w
	  ansVar=2.34749;
	  var=neff;
	  assert(all(lt(abs(w-450), 2e-3)), 'Please find the effective index for a waveguide with w=450.')
	  assert(all(lt(abs(ansVar-var), 2e-3)), 'Incorrect answer.  Please double-check that you are solving for the effective index for a waveguide with width of w=450.  Also check that your simulations have converged and are accurate.  The tolerance on this checker is 2e-3.')
		
      



Could not parse problem

Part 2

Calculate and plot the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide.
    
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      global neff
      



function main

	% Example wavelength sweep parameters with refractive indices:
	global lambdas % for the auto-grader
	lambdas = [1500, 1525, 1550, 1575, 1600]; 
	n1s = [1.444, 1.444, 1.444, 1.444, 1.444];  % Silicon dioxide index of refraction
	n2s = [3.47998, 3.47768, 3.4755, 3.47344, 3.47147]; % Silicon index of refraction

	% Perform effective index calculations
	global neffs % for the auto-grader
	neffs=[]; % initialize empty matrix to store effective index values.
	for i=1:length(lambdas)
		neffs(end+1) = wgmodes_neff(lambdas(i), n1s(i), n2s(i));
	end

	% plot effective index versus wavelength
	figure
	plot (lambdas, neffs)

	% calculate group index versus wavelength ...

end

function [neff]=wgmodes_neff(lambda, n1, n2)
	% inputs:
		% lambda - wavelength, in nm
		% n1 - SiO2 lower cladding
		% n2 - Silicon core

	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 5;           % grid size (x)
	dy = dx;            % grid size (y)

	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

end

% require the functions "wgmodes", "waveguidemesh", "stretchmesh", etc.


function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end


      

Copy and paste the WGMODE codes from the previous unit at the bottom of the above code block.  

Change the material index of refraction values.
	  

		%%
      



Could not parse problem

Optical waveguides suffer from loss from a variety of sources.  
What is the dominant optical loss mechanism?





Explanation
All of these mechanisms can contribute to optical loss in waveguides.
Absorption due to nearby metal is possible if there is metal in the process, and if it is close enough (e.g., less than 1 µm away)
Silicon material absorption is negligeable
Silicon dioxide material absorption becomes significant for wavelengths longer than ~3.0 µm
Surface-state absorption is possible, if the waveguides are not passivated, and is a contributing factor.
Side-wall roughness scattering is the dominant mechanism.
Top-of-waveguide roughness scattering is present, however, this interface is created during the wafer manufacturing process.  Smoothing steps are taken to ensure an exceptionally smooth surface.



Could not parse problem




Perform numerical calculations for the following waveguide:



500 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm


TE polarization



Enter the effective index:






Explanation
To arrive at the correct answer, make sure you have done the following:
    Change the wavelength to 1550 nm.Follow the steps in the preceeding tutorial.
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




Perform numerical calculations for the following waveguide:


600 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm



TM polarization



Enter the effective index:






Explanation
To arrive at the correct answer, make sure you have done the following:
    Look at the 2nd mode, which should be TM polarized. The effective index is smaller than the TE mode.Change the wavelength to 1550 nm.Change the width of the waveguide to 600 nm.Increase the simulation region.  Check that the fields have decayed to 1e-9 (in energy).  This is achieved for an FDE simulation width of 3 micron, and height of 3.5 micron.  
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




The group index of the waveguide is a very important parameter, which as we will see, determines one of the most important features of the Mach-Zehnder Interferometer circuit -- the Free Spectral Range.
Find the group index for the following waveguide:



        500 nm width
      

        220 nm height
      

        silicon core
      

        oxide cladding
      

        wavelength = 1550 nm
      

        TM polarization (hint: this is the 2nd mode; the one with the TE polarization fraction (Ex) that is close to 0.)
      


Enter the group index:  (answer checked within +/- 0.03 of the instructor's answer)






Explanation
Make sure you make the following changes in the simulation:
  Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.Increase the number of simulation mesh points, e.g., 200.  Check the simulation mesh, and make sure it lines up with the waveguide edges.Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode. Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
If you are still not getting the same answer (but are "close"), continue on.  There is a unit "Convergence tests", which analyzes the sources of error in the simulations.




 Make sure you make the following changes in the simulation: 
 1) Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.   
 2) Increase the number of simulation mesh points, e.g., 200, or even more.  
 3) Check the simulation mesh, and make sure it lines up with the waveguide edges.  
 4) Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode.  
 5) Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
	  
If you are still not getting the same answer (but are "close"), continue on.  There is a later unit "Convergence tests", which analyzes the sources of error in the simulations.


Could not parse problem


Find a polynomial curve fit for the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide, in the 1500 to 1600 nm range.
    
 Note: when your run the code, the last plot is generated by the instructor's code. It allows you to compare your answer with the instructor's.
 Note: This is a graded problem.  Click "CHECK" to verify your answer.



      %%    

disp('****************************************************')
disp('The following output is generated by the instructor:')
	  
% Check fit:
if exist('r2')
  if lt(r2,0.8)
    disp 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.'
  end
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
end


% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

if gt(abs(X(1)-X_lukas(1)),0.01)
  disp ('The X(1) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(2)-X_lukas(2)),0.01)
  disp('The X(2) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(3)-X_lukas(3)),0.01)
  disp('The X(3) parameter is more than 1% different than the instructor answer.')
end

      



% User provides a matrix of neff values vs. wavelength
% Matlab curve fits to an expression.

url='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
a=websave('wg.mat',url); % get data from Dropbox
load('wg.mat');

neff = real(neff)  % take the real part of the effective index.

c=299792458;  % speed of light, m/s
lambdas = c ./ f;  % f is the matrix of frequency points, 
                   % where the effective index is recorded.
lambdas = lambdas * 1e6  % convert to microns.
lambda0 = 1.55;   % replace with desired centre wavelength

figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;

% use Matlab anonymous function for the effective index expression:
neff_eq = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 

% initial guess.
X=[2.4 0 0]; 

plot ( lambdas, neff_eq(X, lambdas), 'r')

% curve fit to find expression for neff.
format long
X = lsqcurvefit (neff_eq, X, lambdas, neff)

r=corrcoef(neff,neff_eq(X, lambdas));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

lambdas2=linspace(min(lambdas), max(lambdas), 100);

plot ( lambdas2, neff_eq(X, lambdas2), 'k')
xlabel ('Wavelength [nm]');
ylabel ('Effective Index');

legend ('Data','Initial Guess','Curve Fit')


      

If you don't have Dropbox, you can create the two variables to be used by the above code: neff, and lambdas.  Then proceed to curve fit this data, and compare to the instructor result.
	  

%%
% Grader:
%disp('****************************************************')
%disp('The following output is generated by the instructor:')

% Check:
if exist('url')
 url0='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
 assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
end
        
% Check fit:
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

% Check:
assert(lt(abs(X(1)-X_lukas(1)),0.01), 'The X(1) parameter is more than 1% different than the instructor answer.')
assert(lt(abs(X(2)-X_lukas(2)),0.02), 'The X(2) parameter is more than 2% different than the instructor answer.')
assert(lt(abs(X(3)-X_lukas(3)),0.1), 'The X(3) parameter is more than 10% different than the instructor answer.')
		
      



Could not parse problem





The objective of this problem is to create a compact model for the waveguide, in the form of an expression.  Find an expression for the effective index versus wavelength.

  Use (ONLY) the following parameters:
  lambda: units micronsthe other parameters should be numbers
Your expression will be verified with the instructor's answer.
The answer should be in the format such as "2.4 - 1 * (lambda-1.55) -0.1 *(lambda-1.55)^2" 

neff = "2.444509 -1.1273 * (lambda - 1.55) -0.03335 * (lambda-1.55)^2"







Explanation
The answer is in the form of \( n_\text{eff}(\lambda) = 2.4 - 1.1 (\lambda - 1.55) + 0.1 (\lambda-1.55)^2 \)



To check the answer, we evaluate your expression over a range of 1.5 to 1.6 microns.  We then compare to the instructor's answer, and check that the effective index you provide is within +/- 0.02 of the correct answer.  


Could not parse problem




What is the waveguide geometry that gives the smallest mode area, for the TE polarization at 1550, for a silicon thickness of 220 nm, strip waveguide?  Answer is the waveguide width, with units of nanometers (required accuracy with 20 nm).






Explanation
Find the smallest mode area to be for a waveguide of approximately 360 nm in width.



Modify the script to sweep (using a for loop), the waveguide width parameter (width_ridge in the script).  Plot the mode area and confinement factor, versus the waveguide width.  
Or do it manually, iteratively.


Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions).  You can ignore the radiation losses (loss in dB/cm in MODE Solutions) since they are small.  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is joined to the bent waveguide with no shift.
 
Determine the bend radius required for a TE mode to ensure that the loss is less than 0.1% (which is 0.004 dB) [Answer in microns, accuracy with +/-0.5]:






Explanation
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap.  Or you can use scripts, as provided in the next unit.
(Sorry for the brief explanation.  Post in the discussion below for more info.)



You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap calculations.  Do it iteratively, which only takes a few minutes. 
Or you can use scripts, as provided in the next unit.
The desired total transmission through the bend is 0.999.  Make sure that you are searching for the overlap value of sqrt(0.999).


Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions) and radiation losses (loss in dB/cm in MODE Solutions).  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is jointed to the bent waveguide with no shift.
 
Determine the bend radius required for a TM mode to ensure that the loss is less than 1% (which is 0.04 dB insertion loss)  [Answer in microns, accuracy with +/-1]:




Determine the bend radius required for a TM mode to ensure that the loss is less than 0.1%  [Answer in microns, accuracy with +/-3]:






Explanation
For 11 µm, we find:
  Propagation loss, coming from radiation loss:  0.277 dB/cm.  For a 1/4 circle, you can find the dB for the bend by: ?(-2*pi*11e-4/4*0.277); which is 0.000479 dB.  In linear units, this is   ?10^(-2*pi*11e-4/4*0.277 /10);  which is 0.99989.  Mode-mismatch loss, using overlap calculation:  0.99533Multiply the two together:  ?10^(-2*pi*11e-4/4*0.277 /10) *  (0.99533)^2; = 0.9906.

Quite likely your numbers will be slightly different, due to different simulation configuration (mesh, span, etc).   I used a span of 2.8 µm, with a 10 nm mesh.
  
              For 33 µm, we find:
  Propagation loss, coming from radiation loss: ~0 dB/cm. Mode-mismatch loss, using overlap calculation: 0.99951
(Post in the discussion below for more info.)



For the TM mode, you need to increase the thickness of the simulation, namely in the Z direction, so that the boundaries do not interfere with the simulation.  
If you are having trouble finding the TM mode: In the Eigenmode Analysis settings, you can also use search - near n - 1.8, to help the software find the correct TM mode. 
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap and radiation loss calculations.  Doing it manually, iteratively, only takes a few minutes.  
Or you can use scripts, as provided in the next unit.
Don't forget to consider that there are two mode-mismatch losses per bend, so square the overlap value.  And add the radiation loss in dB/cm times the length.


Could not parse problem

Calculate the mode-mismatch and radiation losses for the following bends, for TE polarization, 1550 nm wavelength [Answer in dB]:
Bend radius of 3 µm:




Bend radius of 5 µm:






Explanation
Can do it manually using mode overlap calculations, or using script.



Could not parse problem

Assume that 1 mW of light is input into an ideal Y-Branch splitter (Port E_0).  
The port labels in this problem are based on the diagram at 1:00 in the video.
_____________________________________________________________________________
How much optical power comes out of output 1 (Port E_1)? [Answer in mW]





Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.



Could not parse problem

Assume that 1 mW of light is input into ONE of the branches of an ideal Y-Branch combiner (Port E_1).  
The port labels in this problem are based on the diagram at 1:45 in the video.
_____________________________________________________________________________
How much optical power comes out of output 0 (Port E_0)?   [Answer in mW]





Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.



Could not parse problem




Assume a waveguide has the following effective index values:
  2.5 at 1.5 microns 2.4 at 1.6 microns 
What is the waveguide group index at 1.55 microns?






Explanation
ng = 2.45 - 1.55 * (-0.1)/0.1.



Could not parse problem




Assume an interferometer with the following properties:
  Wavelength of operation is 1.55 µmWaveguide's group index is 4.2Path length mismatch ∆L is 100 µm
What is the Free Spectral Range, in [nm]?






Explanation
FSR = 1.55e-6^2 / 100e-6 / 4.2 * 1e9
Don't forget to convert from meters to nanometers.



Make sure your answer is correct to +/- 0.01 nm.
The answer is in units of nanometers.


Could not parse problem


You may use this MATLAB window as a calculator to help you answer the questions.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem





  In this unit, we provide you with MATLAB code to simulate the optical transmission spectrum (or transfer function) of the Mach-Zehnder Interferometer.  You can use this code to experiment with the MZI behaviour, gain insight into how the spectrum changes as a function of L2-L1, see how loss impacts the extinction ratio, and so on.  Also, be sure to modify the compact waveguide model parameters to match the waveguide you have modelled and are planning on using in your design.
  

You will need to make adjustments to the constants in the model.  Specifically, change the following:
    n1, n2, n3: the compact waveguide model coefficients. lambda0: the centre wavelength used for the waveguide model. lambda_min, lambda_max: the wavelength range over which you want to plot.  lambda_step: the wavelength step for the plot. Keep in mind that the Agilent/Keysight Technologies laser (81600B) has a wavelength resolution of 0.1 pm, however, we perform automated measurements typically with a 10 pm resolution.  alpha: the propagation loss of the waveguide. L1, L2: the lengths of the two waveguides in the interferometer. 
Note that all constants are in units of microns, unless noted.

          


      %%    
      
      



% the wavelength range of interest.
lambda_min = 1.5;  % Units [µm, microns]
lambda_max = 1.6;
lambda_step = 0.01e-3; % wavelength step [microns]
                       % Typical minimum step for a tunable laser is 1-10 pm.
lambda=lambda_min:lambda_step:lambda_max;

% Define the MZI transfer function
%  use Matlab anonymous functions

% Effective index:
% - as a Taylor expansion around the central wavelength, lambda0
lambda0 = 1.55; n1=2.4; n2=-1; n3=0;  % these are constants from the waveguide model.
neff = @(lambda) ...
		(n1 + n2.*(lambda-lambda0) + n3.*(lambda-lambda0).^2); 
% plot, and check if this is as expected:
figure;
plot(lambda, neff(lambda),'LineWidth',3);

% Complex propagation constant
alpha = 1e-3;  % propagation loss [micron^-1]; constant
beta = @(lambda) ...
		(2*pi*neff(lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );


% MZI transfer function
T_MZI = @(L1, L2, lambda) ...
        ( 0.25* abs(exp(-1i*beta(lambda)*L1)+exp(-1i*beta(lambda)*L2)).^2);

% plot, and check if this is as expected:
L1=100;
L2=200;  % Units [µm, microns], variable
figure;
plot(lambda, T_MZI(L1, L2, lambda),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission');
axis tight
title ('MZI transfer function');

figure;
T_MZI_dB = 10*log10(T_MZI(L1, L2, lambda));
plot(lambda, T_MZI_dB,'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI transfer function');
      



        %%
var0=[n1, n2, n3, alpha, L1, L2];
var1=[2.4, -1, 0, 1e-3, 100, 200];
assert(not(isequal(var0,var1)), 'Looks like you just ran the code without changing the parameters: n1, n2, n3, alpha, L1, L2.  These are parameters specific to your waveguide and need to be changed.');
        
      



Could not parse problem




Answer this question by constructing the following circuit in Lumerical INTERCONNECT:
  Two grating couplers   Connect to a network analyzer.
Measure the best-case fibre-to-fibre insertion loss.
  
          Best-case insertion loss of two grating couplers (positive value, in dB, required accuracy +/- 0.1):





Could not parse problem




For your Mach-Zehnder Inteferometer designs, enter the parameter variations for the path length difference (∆L).  When you press "check", the system will give you some feedback - we are performing a simple sanity-check to make sure that your designs are reasonable.  
Keep in mind that the smallest laser step size is 1 pm, and the typical measurement bandwidth limited by the grating couplers is 50 nm.
 
Enter your design parameters separated by commas, in units of [µm]




def make_a_list(name_string):
    return name_string.split(',')

def count_names(name_list):
    return len(name_list)

def num(s):
    try:
        return float(s)
    except ValueError:
        return 0
      
def how_many_oli(expect, ans):
    names = make_a_list(ans)
    how_many = len(set(names))
    message_hint = ''
    check = True
    for e in names:
        e=e.strip('"')
        e=e.strip("'")
        e=e.strip()
        e=e.lower()
        dL=num(e)
        who_is = e
        if dL &lt; 22:
            if dL == 0:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" (0) micron, you may still have a path length mismatch due to fabrication variations.  \n "
                check = False
            else:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, you will not see oscillations within the measurement span; longer path length mismatch required.  \n"
                check = False
        if dL &gt; 57200:
            message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, we will not be able to resolve the oscillations since they the FSR is too small and the loss differential too high; shorter path length mismatch required.  \n"
            check = False
    if how_many &lt; 1:
        return { 'ok': False, 'msg': 'None at all?'}
    if how_many &lt; 5:
        return { 'ok': check, 'msg': 'Only '+str(how_many)+" variations?  "+message_hint}
    if how_many == 5:
        return { 'ok': check, 'msg': message_hint }
    if how_many &gt; 5:
        return { 'ok': check, 'msg': message_hint }
    return False

  





Explanation
Assuming you want to see oscillations versus wavelength, the minimum path length difference is limited by span.  For 50 nm, 2 oscillations, is FSR = 25 nm.  Assuming ng=4.2, the min dL is ~ 23 µm.

            The maximum path length difference, to be able to resolve oscillations with 10 points per oscillation: 1 point is 1 pm, 10 is 10 pm.  So FSR is 10 pm, hence max ∆L=57 mm.  Assuming 3 dB/cm, this would yield a 17 dB loss difference.  The oscillation fringes would not be visible.  For such a large path-length mismatch, lower loss waveguides would be required (e.g., 3 µm wide multi-mode waveguide).
          



Could not parse problem


Use the Matlab code below to download and plot the measurement data.  The data is for two TE grating couplers, connected with a short waveguide (about 150 microns).  
  

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');
     
      



%%        
      



Could not parse problem


Use the Matlab code below to download, plot, and analyze the measurement data for YBranches for the TM polarization.  The data is for two TM grating couplers, and several YBranches.  The GDS file for the layout used for this experiment is EBeam_LukasChrostowski_TM_YBranches.gds.
  
Note that you can download and run this Matlab file, lukasc_YBranch_TM.m.  If you have the Statistics Toolbox, the program will generate an error estimation.  In the following graph, the shaded region corresponds to the 95% confidence interval.
    

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the insertion loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess insertion loss of about 10 dB.  For example,
% if the DUT is estimated to have an insertion loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the insertion loss, we plot the measured insertion loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the insertion loss for one DUT.

% For the case of the YBranch, the circuit consists of two YBranches facing
% each other. This creates an interferometer.  Assuming the waveguides are
% perfectly matched, the interferometer insertion loss will be only due to
% the excess loss of the YBranch.

% The following layout implements test structures for the YBranch described
% in paper http://dx.doi.org/10.1364/OE.21.001310
% EBeam_LukasChrostowski_TM_YBranches.gds
% https://www.dropbox.com/s/vs0hvrggbn5f9ip/EBeam_LukasChrostowski_TM_YBranches.gds?dl=1

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'YBranch (TM)';
% At what wavelength do you want to find out the insertion loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'lukasc_YBranch3_1262.mat', ...
    'lukasc_YBranch9_1261.mat', ...
    'lukasc_YBranch15_1260.mat', ...
    'lukasc_YBranch21_1263.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 3, 9, 15, 21 ] * 2;
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/louspt78v28x1dw/lukasc_YBranch3_1262.mat', ...
        'https://www.dropbox.com/s/cqyc233aqm8b2rc/lukasc_YBranch9_1261.mat', ...
        'https://www.dropbox.com/s/xrvtv54hmvjpfh4/lukasc_YBranch15_1260.mat', ...
        'https://www.dropbox.com/s/eiypug7qkx1p1ry/lukasc_YBranch21_1263.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength, nm');
ylabel ('Insertion Loss, dB');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the insertion loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the insertion loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Number of YBranches');
ylabel ('Insertion Loss (dB)');
title (['Cut-back method, ' deviceName ' insertion loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/YBranch'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' insertion loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/YBranch'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/YBranch'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' insertion loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/YBranch'])
end



% wavelength dependance of the DUT insertion loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Insertion loss, 95% Confidence Interval', ...
        'Insertion loss, from polyfit', ...
        'Insertion loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Insertion loss, from polyfit', ...
        'Insertion loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' insertion loss, wavelength dependance'] )
ylabel ('Insertion Loss (dB)');
xlabel ('Wavelength, nm');
set(gca,'FontSize',FONTSIZE)
     
      



%%        
      



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The fibre grating couplers must be vertically spaced exactly 127 µm apart, and horizontally aligned.  In this layout, the bottom grating coupler is offset hence light will not be efficiently coupled into the bottom fibre. 



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The highlighted waveguide has sharp 90º angles; these should be replaced with smooth 90º bends to provide low optical loss and low back-reflections.  



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
This layout is missing a label for the automated measurements, e.g., "opt_in_TE_1550_device_LukasChrostowski_MZI3".  



Could not parse problem

Consider an EBL system with a minimum writing grid of 1 nm, and a field size of 1 mm.   
How many bits are required in the Digital to Analog converter (DAC) to achieve the necessary resolution? [answer is an integer]





Explanation
The distance is twice that of the 500 µm example, hence one extra bit, thus 20.



Could not parse problem

Consider a single chip, with four quarters each with a design area of 8.8 mm x 8.8 mm.  
Consider a single participant design size of 605 x 410 µm.  
How many participant designs can fit on a single chip? [required answer accuracy +/- 100]






Explanation
in MATLAB: answer = floor(8800/410)*floor(8800/605)*4 = 1176.
Spread the word about this course, since we have a lot more room for designers.



Our chip is at about 10% capacity.  Spread the word about this course, since we have a lot more room for designers.


Could not parse problem

Consider a single design area of 8.8 mm x 8.8 mm.  
Consider an extremely dense silicon photonic waveguide-based circuit, consisting of 500 nm wide waveguides, on a 3 µm centre-to-centre pitch.  Assume these waveguides are covering the entire design.  The layout is to be fabricated with a 6 nm shot pitch on the JEOL EBL system at UW, and written with a dose of 2800 uC/cm^2. 
How long would it take to write this chip? [answer in Hours, required answer accuracy +/- 1.0]






Explanation
in MATLAB:
Dose = 2800/1e4^2 % convert µC/cm^2 to µC/µm^2
A_written=(8800*.5/3)*(8800) % in µm^2
Ibeam = 8000/1e6 % convert pA to µA
t_seconds = Dose * A_written / Ibeam
t_minutes = t_seconds / 60
t_hours = t_minutes / 60
 ANSWER 12.5 hours.  



You can use Matlab to calculate using the formula t_seconds = Dose * A_written / Ibeam.  Don't forget to convert the units.
You can use the provided online EBEAM calculator.
The machine can be left running overnight.


Could not parse problem

Consider an MZI that was designed to be balanced, with both path lengths being 100 µm.  Assume a lossless interferometer, such that if it was perfectly manufactured, it would have 100% transmission at 1550 nm.
Consider a chip where due to on-chip manufacturing variations, the effective index of the two waveguides differs by 0.00775.
What is the transmission of this MZI? [answer in percentage, an integer without the % symbol. required answer accuracy of +/-1%].






Explanation
dneff=0.00775
L=100e-6
dbetaL = 2*3.1415*dneff*L/1550e-9 = 3.1415
Pi phase shift results in desctructive interference, or 0 transmission.



You'll probably need to go back to the interferometer equations (Photonic Circuits | Modelling - MATLAB | MZI Transfer Function).
The ideal design has 100% transmission due to constructive interference.  What happens if there is a relative phase shift between the waveguides?


Could not parse problem

Perform the corner analysis on the 500x220 nm waveguide, for TE, at 1550 nm.  Determine the range of values possible for the group index, ng.



Assume that the wafer thickness varies between 215.3 and 223.1 nm
Assume that the waveguide width varies between 470 and 510 nm


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Explanation
No explanation yet.




I found it easiest to answer these questions by performing calculations in MODE for the group index, only considering the 4 corner cases. 
  

 I used MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength if the data wasn't available).
  

      Or you can get ng directly in MODE by performing a 1-point frequency sweep at 1550.  Then look under FDE - data - frequencysweep, and find the results view variable "vg". Save this to as a variable "send to script", and calculate ng = c / vg.
  


Could not parse problem

Consider an MZI with a ∆L = 100 µm, with 500x220 nm waveguides, operating in the TE polarization, at 1550 nm.  Using a corner analysis, determine the range of values possible for the Free Spectral Range.
What is the minimum value for the FSR? [answer in units of nm, within an accuracy of 0.03] 




What is the maximum value for the FSR?






Explanation
.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the 9 cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength), then using the formula for FSR for the given ng values.
  


Could not parse problem

  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 



      %%    
      
      







        %%
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');


     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 
figure;
plot (lambda*1e6, amplitude); hold all;
plot (lambda*1e6, amplitude_baseline, 'LineWidth',4);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with polymial fit)');

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');
     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem




In this section, you can calibrate a measured spectrum using a "loopback" structure.
Objective:



remove the baseline shape of the grating couplers



Method:



curve-fit the spectrum of two grating couplers (or an MZI with ∆L=0) using a low-order polynomial
Restrict to ~10 dB from peak to avoid using data with a large error
Subtract this polynomial from subsequent data



You can download and run the Matlab code on your own computer. 

Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      




% Read data files from experiments
% Enter the Dropbox URLs here.  Make sure the URL has a =1 at the end:
%  Loopback structure:
	url_loopback = 'https://www.dropbox.com/s/w915qfix9kwlwv7/ZiheGao_MZI1_272_Scan1.mat?dl=1';
%  MZI:
	url_mzi = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
% Calibrate the MZI data using the loopback structure
% Plot


PORT=1; % Which Fibre array port is the output connected to?
FONTSIZE=20;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Loopback data:
a=websave('loopback.mat',url_loopback); % get data from Dropbox
load('loopback.mat');
% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda*1e6, amplitude);
title ('Calibration loopback'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)
hold all;

% Fit the data with a polynomial
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 5);
amplitude_LOOPBACK=polyval(p,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, amplitude_LOOPBACK);
% find wavelength range with usable data, in the loopback
loopback_IL = max(amplitude);
new_lambda_i=find(amplitude>loopback_IL-10);
lambda=lambda(new_lambda_i);
lambda_min = min(lambda);
lambda_max = max(lambda);
amplitude=amplitude(new_lambda_i);
% refit the loopback
LOOPBACK=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_LOOPBACK=polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, [amplitude_LOOPBACK],'r-','Linewidth',5);
axis tight;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data:
a=websave('mzi.mat',url_mzi); % get data from Dropbox
load('mzi.mat');
lambda1=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda1*1e6, amplitude);
title ('MZI (raw data)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data - calibrated
%
% data only within the bandwidth of interest.
lambda=lambda_min:min(diff(lambda1)):lambda_max;
amplitude=interp1(lambda1, amplitude, lambda,'linear');
amplitude(find(amplitude==-inf))=-50;
% calibrate data
amplitude_cal=amplitude-polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
figure;
plot (lambda*1e6, amplitude_cal);
title ('MZI (calibrated with loopback)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)


    
      



        %%
	url_mzi0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url_mzi0, url_mzi)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

You will need to make adjustments to the initial parameters for the fitting function.  Specifically, change the following line:
  

   nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
  

 Check your answer when you think you have a good fit.  
  



      %%    
      
      




% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
lambda0 = mean(lambda)*1e6;		
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.

% initial function for fitting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];
figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');

% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      

nx_init = [2.4, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
      

        %%
%url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
%assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  



      %%    
      
      



% Lukas Chrostowski, curve fitting the MZI using findpeaks, 2015/08/14

% Enter the Dropbox URL here.  Make sure it has a =1 at the end:

% TE
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

% TM:
%url = 'https://www.dropbox.com/s/onjwrarapf6dumv/ADCL_1_1153_Scan1_L2-L1%3D100um.mat?dl=1';
%dL = 100;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
if not(exist('lambda_min'))
	lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
end
if not(exist('lambda_max'))
	lambda_max = max(lambda);   %  if the data on the edges is noisy
end
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find peaks, extract FSR and ng, and neff
% as initial parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% smooth (0.1% moving average filter)
windowSize = floor(1e-3*length(lambda)); b = (1/windowSize)*ones(1,windowSize);
amplitude_smooth=filter(b,1,amplitude);
% FIND PEAKS
[pks,x_values,w,p]=findpeaks(-amplitude_smooth, lambda, 'minPeakProminence',4,'Annotate','extents');

% plot spectrum with peaks
figure;
plot (x_values*1e6, interp1(lambda, amplitude, x_values,'pchip'), 'ro','MarkerSize',10); 
hold all;
plot (lambda*1e6, amplitude_smooth);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with peaks)');

% Calculate and plot ng data points from FSR
lambda_ng = (x_values(1:end-1)+x_values(2:end))/2;
FSR=(x_values(2:end)-x_values(1:end-1));
ng = abs(lambda_ng.^2/1/(dL*1e-6)./FSR);
% find average ng from all reasonable ng values:
indexes = find(gt(ng,3)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
indexes = find(lt(ng,5)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
ng_av = mean(ng);
if eq(length(ng),0)
  disp ('No group index values found.  Terminating script.');
  return
end
disp (['(estimate) Group index: ' num2str(ng_av)])

% plot FSR
figure;
plot (lambda_ng*1e6, FSR*1e9, '-o','LineWidth',1,'MarkerSize',7 );
xlabel ('Wavelength [\mum]')
ylabel ('Free Spectral Range [nm]')
xlim([min(lambda), max(lambda)]*1e6);
title ('Free Spectral Range, from Experimental data');

% plot ng
figure
plot (lambda_ng*1e6, ng, '-o','LineWidth',1,'MarkerSize',7 )
xlabel ('Wavelength [\mum]')
ylabel ('Group Index')
xlim([min(lambda), max(lambda)]*1e6);
title ('Waveguide Group Index, from Experimental data');


% find starting point for curve fitting MZI, using the ng data
% Part 1 - n1
% lambda0 is in microns.
lambda0 = x_values(floor(length(x_values)/2)) * 1e6;
n1_initial=2.4;
modeNumber = n1_initial * dL / lambda0 - 0.5;
n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
% Part 1 - n2 from ng_av
n2 = (n1-ng_av)/lambda0;
% Part 3 - n3 from slope of ng vs. lambda, to get the dispersion
f_line = @(x,xdata)x(2)*xdata+x(1);
[xfit,resnorm]  = lsqcurvefit(f_line,[ng_av 0],lambda_ng*1e6,ng);
r=corrcoef(ng,f_line(xfit, lambda_ng*1e6));
r2_ng=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2_ng)] )
hold all;
plot (lambda_ng*1e6, f_line(xfit, lambda_ng*1e6),'LineWidth',3)
n3 = -xfit(2)/2/lambda0;
Dispersion0 = -(lambda0*1e-6) / 299792458 * 2* (n3*1e12) * 1e12 /1e9 /1e-3;     	
disp (['(estimate from ng slope) Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
if lt(r2_ng,0.01)   % only use the result if the fit is good
  n3 = 0;
end

% Initial conditions for fitting:
nx_init = [n1 n2 n3];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];

	
% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'-','LineWidth',2);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  disp (['Waveguide parameters at wavelength [um]: ' num2str(lambda0)])
  ng0 = xfit(1) - lambda0*xfit(2);
  disp (['Group index: ' num2str(ng0)])

  % Dispersion:
  c=299792458;	
  Dispersion0 = -(lambda0*1e-6) / c * 2* (xfit(3)*1e12);  % [s/m^2]
  % [ps/nm/km]: 
  Dispersion0 = Dispersion0 * 1e12 /1e9 /1e-3;
  disp (['Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
  
  
end
      



        %%
		
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');

      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  



      %%    
      
      





% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

%url = 'https://www.dropbox.com/s/zojmleq3gu77dsw/ZiheGao_MZI17_265_Scan1.mat?dl=1';
%dL = 219.366;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find ng from autocorrelation-based frequency estimation of spectrum
% auto-correction
[r,lags]=xcorr(amplitude); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
figure
plot(lags,r);
% estimate the frequency
d=diff(r);
start = find(gt(d,0)); start=start(1);
[peak_m, peak_i]=max(r(start:end));
peak_i=peak_i+start;  % location of the 1st peak in the autocorrelation
hold on;
plot(peak_i,0,'s','MarkerSize',20);
title ('Autocorrelation of spectrum')
xlabel('lag, sample number');

fsr = peak_i * mean(diff(lambda))
ng_av = mean(lambda)^2/(dL*1e-6)/fsr


% find starting point for curve fitting, using the ng value
% lambda0 is in microns.
lambda0 = mean(lambda) * 1e6;
n1=2.4;
%modeNumber = n1_initial * dL / lambda0 - 0.5;
%n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
n2 = (n1-ng_av)/lambda0;
nx_init = [n1 n2 0];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Autocorrelation again, to find the shift between the fit function and experimental data
[r,lags]=xcorr(amplitude, T_MZI(x0, lambda*1e6)); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
[peak_m, peak_i]=max(r);
lambda_offset = peak_i(1) * mean(diff(lambda));
n_shift = lambda_offset*lambda0/fsr/dL;
x0(1)=x0(1)+n_shift;

figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters, with shift)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem






      %%    
      
      







        %%
   
        
      



Could not parse problem


    This is a blank Matlab window. You can use it to analyze your own data.  

  



      %%    
      
      







        %%
   
        
      



Could not parse problem



Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 


Could not parse problem

Unbalanced MZI Interferometer, TM polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TM_1550_device_LukasChrostowski_MZI_TM_oneside". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.03]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.03]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TM_oneside.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.02]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100; within an accuracy of +/- 2 %]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://upload.siepic.ubc.ca/uploads/lukasc_TETM_simVSexp_2015_08_17_23_26_59.zip  




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
Follow the Convergence Tests section, in Waveguide Modelling - Lumerical MODE
The TM layout used a bend radius of 10 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of lambda_min=1.54e-6; lambda_max=1.56e-6.
     


Could not parse problem

Unbalanced MZI Interferometer, TE polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TE_1550_device_LukasChrostowski_MZI_TE_oneside2". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.02]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.02]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.02]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.02]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TE_oneside2.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.04]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100 percent; within an accuracy of +/- 2 (%)]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://upload.siepic.ubc.ca/uploads/lukasc_TETM_simVSexp_2015_08_17_23_26_59.zip 




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
The TE layout used a bend radius of 5 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of          lambda_min=1.543e-6; lambda_max=1.557e-6.
     


Could not parse problem


  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 




      %%    
      
      







        %%
      



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
Query done.
Processed: 5.8 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 7.63 s.
Got 7098 rows.

Total time taken 7.79 s.
Finished at 2017-06-30 20:52:51.
Saved to ./../data/Phot1x_3T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
Query done.
Processed: 259.2 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 7.95 s.
Got 190 rows.

Total time taken 7.95 s.
Finished at 2017-06-30 20:53:01.
Saved to ./../data/Phot1x_3T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 11.83 s. Waiting...
Query done.
Processed: 243.4 MB

Retrieving results...
  Got page: 1; 10% done. Elapsed 17.83 s.
  Got page: 2; 20% done. Elapsed 22.72 s.
  Got page: 3; 31% done. Elapsed 28.2 s.
  Got page: 4; 41% done. Elapsed 33.72 s.
  Got page: 5; 51% done. Elapsed 39.08 s.
  Got page: 6; 61% done. Elapsed 43.19 s.
  Got page: 7; 71% done. Elapsed 48.46 s.
  Got page: 8; 82% done. Elapsed 53.22 s.
  Got page: 9; 92% done. Elapsed 57.34 s.
  Got page: 10; 100% done. Elapsed 61.74 s.
Got 228934 rows.

Total time taken 70.41 s.
Finished at 2017-06-30 20:54:12.
Saved to ./../data/Phot1x_3T2016/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 10.6 KB

Retrieving results...
Got 157 rows.

Total time taken 1.0 s.
Finished at 2017-06-30 20:54:18.
Saved to ./../data/Phot1x_3T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 21.2 KB

Retrieving results...
Got 132 rows.

Total time taken 0.98 s.
Finished at 2017-06-30 20:54:20.
Saved to ./../data/Phot1x_3T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 384.8 KB

Retrieving results...
Got 957 rows.

Total time taken 1.57 s.
Finished at 2017-06-30 20:54:23.
Saved to ./../data/Phot1x_3T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 305.8 KB

Retrieving results...
Got 70 rows.

Total time taken 0.98 s.
Finished at 2017-06-30 20:54:25.
Saved to ./../data/Phot1x_3T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 944.0 KB

Retrieving results...
Got 7532 rows.

Total time taken 1.99 s.
Finished at 2017-06-30 20:54:29.
Saved to ./../data/Phot1x_3T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 86.9 KB

Retrieving results...
Got 829 rows.

Total time taken 0.86 s.
Finished at 2017-06-30 20:54:31.
Saved to ./../data/Phot1x_3T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 88.9 MB

Retrieving results...
Got 12055 rows.

Total time taken 4.9 s.
Finished at 2017-06-30 20:54:37.
Saved to ./../data/Phot1x_3T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 275.2 KB

Retrieving results...
Got 829 rows.

Total time taken 1.09 s.
Finished at 2017-06-30 20:54:39.
Saved to ./../data/Phot1x_3T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 268.8 MB

Retrieving results...
Got 2012 rows.

Total time taken 5.63 s.
Finished at 2017-06-30 20:54:46.
Saved to ./../data/Phot1x_3T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 62.4 MB

Retrieving results...
  Got page: 1; 18% done. Elapsed 18.08 s.
  Got page: 2; 36% done. Elapsed 23.24 s.
  Got page: 3; 54% done. Elapsed 29.05 s.
  Got page: 4; 72% done. Elapsed 35.27 s.
  Got page: 5; 90% done. Elapsed 41.34 s.
  Got page: 6; 100% done. Elapsed 44.48 s.
Got 273090 rows.

Total time taken 50.35 s.
Finished at 2017-06-30 20:55:38.
Saved to ./../data/Phot1x_3T2016/page_dirt.csv
Could not parse problem


Click "run" to execute the code.  



      %%    
      
      



a=1
b=2
c=a+b
        
% Practice figures:        
x=1:0.1:10;
figure; plot (x, sin(x)); title ('The First figure');
figure; plot (x, exp(x)); title ('The Second figure');
        
      



%%     
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem


This is a ungraded code box for you to practice writing code. Note that you will get a green check as long as there are no syntax errors in your code.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem




The thickness of the silicon layer in the SOI wafer is a very important parameter when designing silicon photonic components.  
What is the most common silicon thickness used by the silicon photonic foundries? [units: nm]





Explanation
220 nm. We will discuss and simulate the reason behind this choice next.



Could not parse problem




Consider a silicon photonic chip operating over a wide range of temperatures (e.g., in a data centre), and operating over a wide range of wavelengths (e.g., using wavelength division multiplexing, WDM). The waveguide consists of a Si core, and SiO2 cladding; assume that the light is travelling 100% in silicon (we will later see this is not the case). 
If the wavelength changes by 100 nm, by what percentage (absolute value) will the index change? [Answer 0-100, Units: %, Accuracy +/- 0.1]




If the temperature changes by 100 C, by what percentage will the index change? [Answer 0-100, Units: %, Accuracy +/- 0.1]






Explanation
For a 100 nm change in wavelength: abs ( 100 nm * (-7.6e-5 /nm)  / 3.47 * 100 ) = 0.21 %
For a 100 C change in temperature, but only considering dn_Si / dT: abs ( 100 nm * ( 1.87e-4 /K )  / 3.47 * 100 ) = 0.54 %.   



Use the parameters provided on slide #12. 


Could not parse problem




 Which of the following is the largest in a dielectric waveguide?





Explanation
 A pulse of light, and information, travels at the group velocity, which is slower than the speed of light in the material (phase velocity).



Could not parse problem


You can use this MATLAB window to perform the calculations necessary for the problems.
  

      Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.


  



      %%    
      
      


        
format long;  % display many significant digits; optional

delta_T = 10;
Thermal_coefficient = 0.01;  % replace with correct value
delta_n = Thermal_coefficient * delta_T
        
      



        %%
   
        
      



Could not parse problem




Consider a Si/SiO2 waveguide, and assume that the light is travelling as follows: 90% in silicon, and 10% in silicon dioxide.  Assume the mode profile does not change in the following questions:
Q1: If the wavelength increases by 10 nm, by how much will the effective index change?




Q2: If the temperature increases by 10 C, by how much will the effective index change?




Q3: Let's find out if we can ignore the temperature dependance of SiO2 in our models.  Repeat the above Q2 calculation, this time assuming a constant SiO2 material model.  How much error would be introduced in the change in effective index versus temperature, if a constant SiO2 material model was used? (answer in %) 
 \( \% error = \frac{\text{Correct}-\text{Incorrect}}{\text{Correct}} \cdot 100 \)






Explanation
For a 10 nm change in wavelength: 10 nm * ( 0.9 * -7.6e-5 /nm + 0.1 * -1.2e-5 /nm ) = -6.96e-4
For a 10 C change in temperature: 10 K * ( 0.9 * 1.87e-4 /K + 0.1 * 8.5e-6 /K ) = 1.6915e-3
For a 10 C change in temperature, but only considering dn_Si / dT, 10 nm * ( 0.9 * 1.87e-4 /K ) = 1.683e-4.  Hence, the error is: 
(1.6915-1.683) / (1.6915) = 0.00502, or 0.5%



For the effective index, in Q1-3, approximate this as a weighted average of the refractive index values in each medium. 
For Q3: Modify your equation in Q2 to assume that there is no temperature dependence in the SiO2.  Note that 10% of the light is still in the SiO2, and 90% is in silicon. 
For Q3, the answer is a number.  Don't include the % symbol in the answer. 


Could not parse problem




Consider a silicon photonic slab waveguide consisting of a thin layer of silicon (with index 3.47), with thickness t, surrounded by an infinite amount of silicon dioxide (with index of 1.44).
Consider the fundamental mode (TE0).  For a thickness t=220 nm, the effective index is 2.8. 
What value does the effective index approach as t gets close to 0 nm (very thin slab waveguide)? [Ans +/- 0.1]




What value does the effective index approach as t approaches infinity (very thick slab waveguide)? [Ans +/- 0.1]






Explanation
In a very thin slab waveguide, the light is mostly in the silicon dioxide, hence the index approaches 1.44.
In a very thick slab waveguide, the light is mostly in the silicon, hence the index approaches 3.47.



Could not parse problem




In this exercise, we wish to understand why the wafers we are using have a thickness of 220 nm. 
 You can use the analytic method with the script provided below (in MATLAB) to answer this question (Note: you do need to understand the details of this script, just use it as a tool).  
  
You can download the script (wg_1D_slab.m). 
What is the maximum Si thickness before the slab waveguide supports more than one TE mode? Enter the thickness [Units: nm, accuracy +/-5 nm]:






Explanation




Use the Matlab code below.  You can do this problem by trial and error, with your own iterations.  
Change the thickness of the waveguide -- the default is 0.22e-6 m.  You will see that nTE = xxxx: namely it supports a single mode.  Try increasing it, say to 0.5e-6.  You will see that nTE = xxxx, xxxx, xxx: namely it supports multiple (3) modes.  Find the value where the 2nd mode just disappears.  
You could also make a script with a "for" loop, and plot the number of modes versus the thickness.  The number of modes would be found by the command length(nTE).  


Could not parse problem





Use the following Matlab code to answer the question on slab waveguides.
  
To change the thickness, change the number 220e-9 in the following line: 



thickness=220e-9;     %%% thickness of the silicon layer, [units: m]
  



The default is to plot the E-field for the TE polarization. You may also view the field profile for the TM polarization.
  

Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% MATLAB Script to solve for the modes of the slab waveguide,
% calculate the effective indices
% plot the E-field profile for all the modes
% the user provides:
%  - thickness of the silicon layer
%  - desired polarization to plot

function main
	thickness=220e-9;     %%% thickness of the silicon layer, [units: m]
	polarization = 'TM';  %%% polarization, 'TE' or 'TM'

	[x, TE_E, TE_H, TM_E, TM_H, nTE, nTM] = wg_1D_mode_profile ...
		(1.55e-6, thickness, 1.444, 3.47, 1.444, 100, 3);

	figure;
	g=rectangle('Position',[-thickness*1e9/2,-1,thickness*1e9,2],'FaceColor',[.8 .8 .8 0.2]); hold all;
	if polarization=='TE'       
		plot (x*1e9, TE_E/max(max(TE_E)), 'LineWidth',3);
		title('TE polarized mode(s)');
	else
		plot (x*1e9, TM_E/max(max(TM_E)), 'LineWidth',3);
		title('TM polarized mode(s)');
	end
	xlabel('Position - perpendicular to wafer [nm]');
	ylabel('E-Field Amplitude');
	ax=gca;
	set(ax, 'FontSize',15);
%	ax.XTick = [floor(min(x)*1e9/100)*100:200:floor(max(x)*1e9/100)*100];
	axis tight;
	grid on; box on;

	disp(['Effective index value(s) of the TE mode(s):  ' sprintf('%g  ',nTE)])
	disp(['Effective index value(s) of the TM mode(s):  ' sprintf('%g  ',nTM)])


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
% wg_1D_mode_profile.m - Calculate the 1D mode profile of a slab waveguide
% by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3.2
% - function returns mode profiles for TE and TM modes (E, H components)
% usage, e.g.:
%  [x, TE_E, TE_H, TM_E, TM_H, nTE, nTM] = wg_1D_mode_profile (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444, 100, 4)
%  plot (x, TE_E); 
%  plot (x, TM_E); 
function [x, TE_E, TE_H, TM_E, TM_H, nTE, nTM]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
	x1=linspace( -M*t, -t/2, pts); x2=linspace( -t/2, t/2, pts); 
	x3=linspace( t/2, M*t, pts); x=[x1 x2 x3];
	nx=[n1*ones(pts,1); n2*ones(pts,1); n3*ones(pts,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% wg_1D_analytic.m - Analytic solution of a slab waveguide
% by Lumerical Solutions, http://www.lumerical.com/mode_online_help/slab_wg.m
% modified by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3
% finds the TE and TM effective indices of a 3-layer slab waveguide

% usage:
%  - get effective indices for supported modes:
%  [nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
%  - optional, for plotting: TEparam,TMparam: h, q, p parameters of the mode.

function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);     
      
      



        %%
   
        
      



Could not parse problem


Use the following Matlab code to answer the question on slab waveguides.
  
To change the thickness, change the number 0.22e-6 in the following line: 



[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
  



Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_analytic.m - Analytic solution of a slab waveguide
% by Lumerical Solutions, http://www.lumerical.com/mode_online_help/slab_wg.m
% modified by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3
% finds the TE and TM effective indices of a 3-layer slab waveguide

% usage:
%  - get effective indices for supported modes:
%  [nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)
%  - optional, for plotting: TEparam,TMparam: h, q, p parameters of the mode.


function main
	[nTE, nTM] = wg_1D_analytic (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
      



        %%
   
        
      



Could not parse problem




 We know that some of the light is travelling outside the waveguide.  This is an important concept to understand as it has several implications: 
  It leads to the concept of waveguide dispersion, and has a huge impact on the group index, \( n_g \) The field outside the waveguide can be used to make evanescent field sensors, e.g., bio applications.  (Note - replace SiO2 with air, water, etc, for biosensors) 
  Hence, we wish to study how far the fields extend above the waveguides.  We consider the two polarizations (TE, TM) guided by the 220 nm slab waveguide. 
          Question - For the TE polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point (of the value at the interface):




Question - For the TM polarization, how far does the E-field profile extend above the Si waveguide?
Enter the distance [nm, accuracy +/- 20] away from the Si-SiO2 interface where the field has decayed to the 1/e point:






Explanation
TE Polarization:

Measure the field at the interface.
Find the 1/e point.  If the field is 0.66 at the interface, take 0.66 / e = 0.66 / 2.71 = 0.243.  Find the x value for this point, which is approximately 200 nm.
Measure the distance from the interface: 200-110 = 90 nm.

TM Polarization:

The MATLAB code needs to be motified to plot TM_E (the E-field for the TM polarization) instead of TE_E (the E-field for the TM polarization)
Measure the field at the interface.
find the 1/e point.  if the field is 0.77 at the interface, take 0.77 / e = 0.28.  Find the x value for this point, which is approximately 280 nm.
measure the distance from the interface: 280-110 = 170 nm.




Could not parse problem

You can run the MATLAB code provided in the web browser below.  Or, you can download the code and run it directly on your computer (wg_1D_mode_profile_main.m)
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_1D_mode_profile.m - Calculate the 1D mode profile of a slab waveguide
% by Lukas Chrostowski, 2012
% See Yariv Photonics book, Chapter 3.2
% - function returns mode profiles for TE and TM modes (E, H components)
% usage, e.g.:
%  [x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile (1.55e-6, 0.22e-6, 1.444, 3.47, 1.444, 100, 4)
%  plot (x, TE_E); 
%  plot (x, TM_E); 



function main
	thickness=0.22e-6;  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	[x, TE_E, TE_H, TM_E, TM_H] = wg_1D_mode_profile ...
		(1.55e-6, thickness, 1.444, 3.47, 1.444, 100, 3);
	g=rectangle('Position',[-thickness*1e9/2,0,thickness*1e9,1],'FaceColor',[.8 .8 .8 0.2]); hold all;
	plot (x*1e9, TE_E/max(max(TE_E)), 'LineWidth',3);
	xlabel('Position [nm]');
	ylabel('Field Amplitude');
	ax=gca;
	set(ax, 'FontSize',15);
	ax.XTick = [floor(min(x)*1e9/100)*100:200:floor(max(x)*1e9/100)*100];
	axis tight;
	grid on; box on;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
	x1=linspace( -M*t, -t/2, pts); x2=linspace( -t/2, t/2, pts); 
	x3=linspace( t/2, M*t, pts); x=[x1 x2 x3];
	nx=[n1*ones(pts,1); n2*ones(pts,1); n3*ones(pts,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);     
      



        %%
   
        
      



Could not parse problem




Simulation results for the strip waveguide, fundamental TE polarization, show that the effective index decreases with increasing wavelength.
What is the main reason that the waveguide's effective index decreases for a longer wavelength?





Explanation
Both Material and Waveguide dispersion contribute.  However, material dispersion accounts for a small portion of the total dispersion; recall that the group index of silicon is ~3.6, which is ~0.1 higher than the refractive index of silicon (n_Si).  In contrast, the group index for the waveguide is ~4.2, which is ~0.7 higher than n_Si.  If one was to simulate the waveguide without material dispersion (setting n_Si = 3.47, a constant), one would find that the group index is ~0.6 higher than the n_Si.  Thus, the waveguide dispersion is the dominant effect.
To get an intuitive understanding, simulate the mode for different wavelengths.  You will see that the mode is more spread out for longer wavelengths.  
Intuitively, more light is travelling through the lower index cladding for longer wavelengths.  The effective index can be thought of as a weighted average of the material indices, based on the mode profile.  Hence, less light in the silicon core for longer wavelengths leads to a lower effective index.



Could not parse problem




Simulation results for the strip waveguide show that the effective index increases with increasing geometry (width or thickness).
What is the main reason that the waveguide's effective index increases with width?





Explanation
The answer is similar to waveguide dispersion described above.  
To get an intuitive understanding, simulate the mode for different geometries.  You will see that the mode is more spread out for smaller waveguides with tails extending into the cladding.  In contrast, larger waveguides have more light inside the core.  
Hence, for larger geometries, more light in the silicon core, and this leads to a higher effective index.



Could not parse problem




Optical waveguides suffer from loss from a variety of sources.  
What is the dominant optical loss mechanism in a 500 nm wide strip waveguide, for a quasi-TE mode at 1550 nm?





Explanation
All of these mechanisms can contribute to optical loss in waveguides.
Absorption due to nearby metal is possible if there is metal in the process, and if it is close enough (e.g., less than 1 µm away)
Silicon material absorption is negligeable
Silicon dioxide material absorption becomes significant for wavelengths longer than ~3.0 µm
Surface-state absorption is possible, if the waveguides are not passivated, and is a contributing factor.
Side-wall roughness scattering is the dominant mechanism.
Top-of-waveguide roughness scattering is present, however, this interface is created during the wafer manufacturing process.  Smoothing steps are taken to ensure an exceptionally smooth surface.



Could not parse problem




Using the Effective Index Method, find the fundamental TE mode effective index at 1500 nm.
n_eff: Effective index of the waveguide:






Explanation
Change the wavelength in the code...  The first parameter is wavelength, in: wg_EIM_profile (1.50e-6, ...
Run the matlab code.
See the effective index displayed.



Could not parse problem


Use the Matlab code below (Effective Index Method, field profile) to view the field profile for a 500 x 220 nm waveguide.
  
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  



      %%    
      
      



% wg_EIM_profile.m - Effective Index Method - mode profile
% Lukas Chrostowski, 2012
% usage, e.g.:
%  wg_EIM_profile (1.55e-6, 0.22e-6, 0.5e-6, 90e-9, 3.47, 1, 1.44, 100, 2)

function main
	[neff_TEwg]=wg_EIM_profile (1.60e-6, 0.22e-6, 0.5e-6, 0, 3.47, 1.44, 1.44, 100, 2)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [neff_TEwg]=wg_EIM_profile (lambda, t, w, t_slab, n_core, n_clad, n_oxide, pts, M)

	% find TE (TM) modes of slab waveguide (waveguide core and slab portions):
	[nTE,nTM]=wg_1D_analytic (lambda, t, n_oxide, n_core, n_clad);
	if gt(t_slab,0)
		[nTE_slab,nTM_slab]=wg_1D_analytic (lambda, t_slab, n_oxide, n_core, n_clad);
	else
		nTE_slab=n_clad; nTM_slab=n_clad;
	end
	[xslab,TE_Eslab,TE_Hslab,TM_Eslab,TM_Hslab]=wg_1D_mode_profile (lambda, t, n_oxide, n_core, n_clad, pts, M);

	figure%(1);  clf; subplot (2,2,2); 
    Fontsize=15;
	plot(TE_Eslab/max(max(TE_Eslab)),xslab*1e9,'LineWidth',4);hold all;
	ylabel('Height [nm]','FontSize',Fontsize); 
	xlabel({' ','E-field (TE)'},'FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize,'XTick',[]);
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);
	Ax1 = gca; Ax2 = axes('Position',get(Ax1,'Position'));
	get(Ax1,'Position');
    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
	plot (nx, xslab*1e9,  'LineWidth',0.5,'LineStyle','--','parent',Ax2); 
	a2=axis; axis ([a2(1), a2(2), a(3), a(4)]);
	set(Ax2,'Color','none','XAxisLocation','top', 'YTick',[],'TickDir','in'); 
	set(gca,'YAxisLocation','right'); box off;
	xlabel('Material Index','FontSize',Fontsize); 
	set(gca,'FontSize',Fontsize); 
%    print -dpdf eim1.pdf

	% TE-like modes of the etched waveguide (for fundamental slab mode)
	%   solve for the "TM" modes:
	[nTE,nTM]=wg_1D_analytic (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1));
	neff_TEwg=nTM;
	[xwg,TE_E_TEwg,TE_H_TEwg,TM_E_TEwg,TM_H_TEwg]=wg_1D_mode_profile (lambda, w, nTE_slab(1), nTE(1), nTE_slab(1), pts, M);

    nx=[nTE_slab(1)*ones(pts,1); nTE(1)*ones(pts-1,1); nTE_slab(1)*ones(pts-1,1)]';
    figure%(1); subplot (2,2,3);
    % Plot the data on with a left and right axes. Return the axes and line
    % objects.
    [ax, h1, h2] = plotyy(xwg*1e9, TM_E_TEwg(:,1)/max(max(TM_E_TEwg)), xwg*1e9, nx);
    % Set the Xlabel and yLabel of each axes
    xlabel('Position [nm]','FontSize',Fontsize);
    ylabel(ax(1),'E-field (TM, TE-like mode)','FontSize',Fontsize);
    ylabel(ax(2), 'Slab Effective Index','FontSize',Fontsize);
    % Change the color of the right axes and the line style of line plot
    % associated with that axes.
    ax(2).YColor = 'b';
    h2.LineStyle = '--';
    h2.LineWidth = 0.5;
    h2.Color = 'b';
    % Set the Line width of the two line plots of the left axes.
    h1(1).LineWidth = 4;
    % Remove the left Tick labels.
    ax(1).YTick = [];
    % Set the YLim property so the plots line up.
    ax(2).YLim = [1.4, 2.6];
    ax(2).YTick = 1.4:0.2:2.6;
    
    % Plot the product of the two fields
	figure%(1); subplot (2,2,1);
	Exy=TM_E_TEwg(:,1)*(TE_Eslab(1,:));
	contourf(xwg*1e9,xslab*1e9,abs(Exy')/max(max(Exy))')
    % colormap('jet')
    axis equal
	xlabel ('X (nm)','FontSize',Fontsize); 
	ylabel ('Y (nm)','FontSize',Fontsize); 
	set (gca, 'FontSize',Fontsize); 
	A=axis; axis([A(1)+0.4, A(2)-0.4, A(3)+.2, A(4)-0.2]);
	title('Effective Index Method');
	% Draw the waveguide:
	rectangle ('Position',[-w/2,-t/2,w,t]*1e9, 'LineWidth',1, 'EdgeColor','white')
	if gt(t_slab,0)
		rectangle ('Position',[-M*w,-t/2,(M-0.5)*w, t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
		rectangle ('Position',[w/2,-t/2,(M-0.5),t_slab]*1e9, 'LineWidth',1, 'EdgeColor','white')
    end

    
function draw_WG_vertical(M)
	pP=get(gca,'Position');pPw=pP(3); 
	pPc=pP(3)/2+pP(1); pP2=pPw/4/M;
	annotation ('line',[pPc-pP2,pPc-pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	annotation ('line',[pPc+pP2,pPc+pP2], [pP(2),pP(4)+pP(2)],'LineStyle','--');
	axis tight; a=axis; axis ([a(1), a(2), a(3)*1.1, a(4)*1.1]);

function draw_WG_horiz(M)
	pP=get(gca,'Position');pPw=pP(4); 
	pPc=pP(4)/2+pP(2); pP2=pPw/4/M;
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc-pP2,pPc-pP2],'LineStyle','--');
	annotation ('line',[pP(1),pP(3)+pP(1)], [pPc+pP2,pPc+pP2],'LineStyle','--');
	axis tight; a=axis; axis ([a(1)*1.1, a(2)*1.1, a(3), a(4)]);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

function [x, TE_E, TE_H, TM_E, TM_H]= wg_1D_mode_profile (lambda, t, n1, n2, n3, pts, M)
	[nTE,nTM,TEparam,TMparam]= wg_1D_analytic(lambda,t,n1,n2,n3);
    x1=linspace( -M*t, -t/2, pts); 
    x2=linspace( -t/2, t/2, pts); x2 = x2(2:end);
    x3=linspace( t/2, M*t, pts);  x3 = x3(2:end);
    x=[x1 x2 x3];
    nx=[n1*ones(pts,1); n2*ones(pts-1,1); n3*ones(pts-1,1)]';
	mu0=4*pi*1e-7; epsilon0=8.85e-12; eta=sqrt(mu0/epsilon0); c=3e8; % constants
	for i=1:length(nTE)
		h=TEparam(i,2);q=TEparam(i,3); p=TEparam(i,4);
		beta = 2*pi*nTE(i)/lambda;
		C=2*h*sqrt ( 2*pi*c/lambda*mu0 / (beta * (t+1/q+1/p)*(h^2+q^2) ) ); % normalize to 1W
		% n1, n2, n3 regions
		TE_E(i,:)=C*[exp(q*(x1+t/2)), (cos(h*(x2+t/2))+q/h*sin(h*(x2+t/2))), (cos(h*t)+q/h*sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TE_H=TE_E'.*(nx'*ones(1,length(nTE)))/eta;

	for i=1:length(nTM)
		h=TMparam(i,2); q=TMparam(i,3);
		p=TMparam(i,4); qb=n2^2/n1^2*q;pb=n2^2/n3^2*p;
		beta = 2*pi*nTM(i)/lambda;
		temp=(qb^2+h^2)/qb^2 * (t/n2^2 + (q^2+h^2)/(qb^2+h^2)/n1^2/q + ( p^2+h^2)/(p^2+h^2)/n3^2/p) ;
		C=2*sqrt ( 2*pi*c/lambda*epsilon0 / (beta * temp )); % normalize to 1W
		TM_H(i,:)=C*[h/qb*exp(q*(x1+t/2)), (h/qb*cos(h*(x2+t/2))+sin(h*(x2+t/2))), (h/qb*cos(h*t)+sin(h*t)).*exp(-p*(x3-t/2))];
	end
	TM_E=TM_H'./(nx'*ones(1,length(nTM)))*eta;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
function [nTE,nTM,TEparam,TMparam]=wg_1D_analytic (lambda, t, n1, n2, n3)
	k0 = 2*pi/lambda;
	b0 = linspace( max([n1 n3])*k0, n2*k0, 1000);   %k0*n3 less than b less than k0*n2
	b0 = b0(1:end-1);
	te0=TE_eq(b0,k0,n1,n2,n3,t);
	tm0=TM_eq(b0,k0,n1,n2,n3,t);

	%TE
	intervals=ge(te0,0)-lt(te0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTE(i)=fzero(@(x) TE_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TEparam(i,1),TEparam(i,2),TEparam(i,3),TEparam(i,4)]= TE_eq(nTE(i)*k0,k0,n1,n2,n3,t);
	end
	nTE=nTE(end:-1:1);
	TEparam=TEparam(end:-1:1,:);

	%TM
	intervals=ge(tm0,0)-lt(tm0,0);
	izeros=find(lt(diff(intervals),0));
	X0=[b0(izeros); b0(izeros+1)]';
	[nzeros,scrap]=size(X0);
	for i=1:nzeros
		nTM(i)=fzero(@(x) TM_eq(x,k0,n1,n2,n3,t),X0(i,:))/k0;
		[TMparam(i,1),TMparam(i,2),TMparam(i,3),TMparam(i,4)]= TM_eq(nTM(i)*k0,k0,n1,n2,n3,t);
	end
	if gt(nzeros,0)
		nTM=nTM(end:-1:1);
		TMparam=TMparam(end:-1:1,:);
	else
		nTM=[];
	end

function [te0,h0,q0,p0]=TE_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	% the objective is to find zeroes of te0 and tm0
	te0 = tan( h0*t ) - (p0+q0)./h0./(1-p0.*q0./h0.^2);

function [tm0,h0,q0,p0]=TM_eq(b0,k0,n1,n2,n3,t)
	h0 = sqrt( (n2*k0)^2 - b0.^2 );
	q0 = sqrt( b0.^2 - (n1*k0)^2 );
	p0 = sqrt( b0.^2 - (n3*k0)^2 );
	pbar0 = (n2/n3)^2*p0;
	qbar0 = (n2/n1)^2*q0;
	tm0 = tan( h0*t ) - h0.*(pbar0+qbar0)./(h0.^2-pbar0.*qbar0);
			     
      



        %%
   
        
      



Could not parse problem




Part 1

Using this tool, compute the mode profile and calculate the effective index of the fundamental TE mode for a 450x220 nm waveguide at 1550 nm.
    
Note:  This is a graded code box.  When ready, press "CHECK". After your code executes, additional code on the server will check your answer.  
  
Download script:  Phot1x_wg_2D_matlab.m



      %%    
      global neff
      



% This example computes the field components and the effective index of a
% silicon-on-insulator strip waveguide.
% slightly modified version, from: http://www.photonics.umd.edu/software/wgmodes/
function [neff]=main

	global neff w  % Used by the auto-graded to check your answer.

	n1 = 1.44;          % SiO2 lower cladding
	n2 = 3.47;          % Silicon core
	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 2.5;           % grid size (x)
	dy = dx;            % grid size (y)

	lambda = 1550;      % wavelength (nm)
	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

	fprintf (1,'post-processing... '); t = cputime;

	[Hz,Ex,Ey,Ez] = postprocess (lambda, neff, Hx, Hy, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf (1,'graphing... '); t = cputime;

	hn = abs(interp2(y,x,Hy,h1+h2/2,0));
	en = abs(interp2(yc,xc,Ex,h1+h2/2,min(dx)/2));

	% Plot |E| profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,sqrt(abs([-Ex(end:-1:1,:);Ex]).^2+abs([-Ey(end:-1:1,:);Ey]).^2+abs([-Ez(end:-1:1,:);Ez]).^2)/en);
	title('|E|');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% could normalize the |E| plot to show energy...
	%size (eps)

	% figure;
	% imagemode(x,y,Hx/hn);
	% title('Hx');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hy/hn);
	% title('Hy');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Hz/hn);
	% title('Hz');
	% for v = edges, line(v{:}); end

	% Plot Ex profile
	figure;
	colormap(jet);
	imagemode([-x(end:-1:2);x],y,[-Ex(end:-1:1,:);Ex]/en);
	hold on;
	contourmode([-xc(end:-1:1);xc],yc,[-Ex(end:-1:1,:);Ex]/en,(0:-5:-60));
	title('Ex');
	v = xlim();
	line(v,[h1,h1], 'Color', 'k');
	line([-w/2,w/2,w/2,-w/2,-w/2],[h1+h2,h1+h2,h1,h1,h1+h2], 'Color', 'k');

	% figure;
	% imagemode(x,y,Ey/en);
	% title('Ey');
	% for v = edges, line(v{:}); end

	% figure;
	% imagemode(x,y,Ez/en);
	% title('Ez');
	% for v = edges, line(v{:}); end
	
	% figure;
	% imagemode(x,y,sqrt(abs(Ez).^2+abs(Ey).^2+abs(Ex).^2)/en);
	% title('|E|');
	% for v = edges, line(v{:}); end

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

end

function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end

      

	  % Change the width of the waveguide to 450 nm, via the following variable on line 22:
      w = 450;
	  

        %%
      global neff w
	  ansVar=2.34749;
	  var=neff;
	  assert(all(lt(abs(w-450), 2e-3)), 'Please find the effective index for a waveguide with w=450.')
	  assert(all(lt(abs(ansVar-var), 2e-3)), 'Incorrect answer.  Please double-check that you are solving for the effective index for a waveguide with width of w=450.  Also check that your simulations have converged and are accurate.  The tolerance on this checker is 2e-3.')
		
      



Could not parse problem




Part 2

Calculate and plot the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide.
    
Note:  This is a ungraded code box. You will get a "Correct" when you press "CHECK" as long as there are no syntax errors in your code.
  
Download script:  Phot1x_wg_2D_sweep_matlab.m



      %%    
      global neff
      



function main

	% Example wavelength sweep parameters with refractive indices:
	global lambdas % for the auto-grader
	lambdas = [1500, 1525, 1550, 1575, 1600]; 
	n1s = [1.444, 1.444, 1.444, 1.444, 1.444];  % Silicon dioxide index of refraction
	n2s = [3.47998, 3.47768, 3.4755, 3.47344, 3.47147]; % Silicon index of refraction

	% Perform effective index calculations
	global neffs % for the auto-grader
	neffs=[]; % initialize empty matrix to store effective index values.
	for i=1:length(lambdas)
		neffs(end+1) = wgmodes_neff(lambdas(i), n1s(i), n2s(i));
	end

	% plot effective index versus wavelength
	figure
	plot (lambdas, neffs)

	% calculate group index versus wavelength ...

end

function [neff]=wgmodes_neff(lambda, n1, n2)
	% inputs:
		% lambda - wavelength, in nm
		% n1 - SiO2 lower cladding
		% n2 - Silicon core

	n3 = n1;            % upper cladding

	h1 = 500;           % lower cladding (nm)
	h2 = 220;           % silicon core (nm)
	h3 = 500;           % upper cladding (nm)

	dx = 5;           % grid size (x)
	dy = dx;            % grid size (y)

	nmodes = 1;         % number of modes to compute

	w = 500;            % waveguide full-width (nm)
	side = 500;         % space on side of waveguide (nm)

	fprintf (1,'solving for eigenmodes... '); t = cputime;

	[x,y,xc,yc,nx,ny,eps,edges] = ...
	    waveguidemesh([n1,n2,n3],[h1,h2,h3],h2,w/2,side,dx,dy);

    % Now we stretch out the mesh at the boundaries:
    stretchXY=floor(min(length(x),length(y))/2);
    [x,y,xc,yc,dx,dy] = ...
        stretchmesh(x,y,[stretchXY,stretchXY,stretchXY,0],[1.5,1.5,1.5,1]);

	[Hx,Hy,neff] = wgmodes (lambda, n2, nmodes, dx, dy, eps, '000A');

	fprintf (1,'done (cputime = %7.3f)\n', cputime-t);

	fprintf(1,'neff = %7.5f, at %4d nm.\n',neff, lambda);

end

% require the functions "wgmodes", "waveguidemesh", "stretchmesh", etc.


function [phix,phiy,neff] = wgmodes (lambda, guess, nmodes, dx, dy, varargin);

	% This function computes the two transverse magnetic field
	% components of a dielectric waveguide, using the finite
	% difference method.  For details about the method, please
	% consult:  
	%
	% A. B. Fallahkhair, K. S. Li and??T. E. Murphy, "Vector Finite
	% Difference Modesolver for Anisotropic Dielectric
	% Waveguides", J. Lightwave Technol. 26(11), 1423-1431,
	% (2008). 
	%
	% USAGE:
	% 
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        eps,boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsyy, epszz, boundary);
	% [hx,hy,neff] = wgmodes(lambda, guess, nmodes, dx, dy, ...
	%                        epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength
	% guess - scalar shift to apply when calculating the eigenvalues.
	%     This routine will return the eigenpairs which have an
	%     effective index closest to this guess
	% nmodes - the number of modes to calculate
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% hx - three-dimensional vector containing Hx for each
	%      calculated mode 
	% hy - three-dimensional vector containing Hy for each
	%      calculated mode (e.g.: hy(:,k) = two dimensional Hy
	%      matrix for the k-th mode 
	% neff - vector of modal effective indices
	%
	% NOTES:
	%
	% 1) The units are arbitrary, but they must be self-consistent
	% (e.g., if lambda is in um, then dx and dy should also be in
	% um.
	%
	% 2) Unlike the E-field modesolvers, this method calculates
	% the transverse MAGNETIC field components Hx and Hy.  Also,
	% it calculates the components at the edges (vertices) of
	% each cell, rather than in the center of each cell.  As a
	% result, if size(eps) = [n,m], then the output eigenvectors
	% will be have a size of [n+1,m+1].
	%
	% 3) This version of the modesolver can optionally support
	% non-uniform grid sizes.  To use this feature, you may let dx
	% and/or dy be vectors instead of scalars.
	%
	% 4) The modesolver can consider anisotropic materials, provided
	% the permittivity of all constituent materials can be
	% expressed in one of the following forms:   
	%
	%  [eps  0   0 ]  [epsxx   0     0  ]  [epsxx epsxy   0  ]
	%  [ 0  eps  0 ]  [  0   epsyy   0  ]  [epsyx epsyy   0  ]
	%  [ 0   0  eps]  [  0     0   epszz]  [  0     0   epszz]
	%
	% The program will decide which form is appropriate based upon
	% the number of input arguments supplied.
	%
	% 5) Perfectly matched boundary layers can be accomodated by
	% using the complex coordinate stretching technique at the
	% edges of the computation window.  (stretchmesh.m can be used
	% for complex or real-coordinate stretching.)
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)
	%           Arman B. Fallahkhair (a.b.fallah@gmail.com)
	%           Kai Sum Li (ksl3@njit.edu)

	if (nargin == 11)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 9)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 7)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))].'; % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	ns21 = n.*eyy2+s.*eyy1;
	ns34 = n.*eyy3+s.*eyy4;
	ew14 = e.*exx1+w.*exx4;
	ew23 = e.*exx2+w.*exx3;

	axxn = ((2*eyy4.*e-eyx4.*n).*(eyy3./ezz4)./ns34 + ...
	        (2*eyy1.*w+eyx1.*n).*(eyy2./ezz1)./ns21)./(n.*(e+w));

	axxs = ((2*eyy3.*e+eyx3.*s).*(eyy4./ezz3)./ns34 + ...
	        (2*eyy2.*w-eyx2.*s).*(eyy1./ezz2)./ns21)./(s.*(e+w));

	ayye = (2.*n.*exx4 - e.*exy4).*exx1./ezz4./e./ew14./(n+s) + ...
	       (2.*s.*exx3 + e.*exy3).*exx2./ezz3./e./ew23./(n+s);

	ayyw = (2.*exx1.*n + exy1.*w).*exx4./ezz1./w./ew14./(n+s) + ...
	       (2.*exx2.*s - exy2.*w).*exx3./ezz2./w./ew23./(n+s);

	axxe = 2./(e.*(e+w)) + ...
	       (eyy4.*eyx3./ezz3 - eyy3.*eyx4./ezz4)./(e+w)./ns34;

	axxw = 2./(w.*(e+w)) + ...
	       (eyy2.*eyx1./ezz1 - eyy1.*eyx2./ezz2)./(e+w)./ns21;

	ayyn = 2./(n.*(n+s)) + ...
	       (exx4.*exy1./ezz1 - exx1.*exy4./ezz4)./(n+s)./ew14;

	ayys = 2./(s.*(n+s)) + ...
	       (exx2.*exy3./ezz3 - exx3.*exy2./ezz2)./(n+s)./ew23;

	axxne = +eyx4.*eyy3./ezz4./(e+w)./ns34;
	axxse = -eyx3.*eyy4./ezz3./(e+w)./ns34;
	axxnw = -eyx1.*eyy2./ezz1./(e+w)./ns21;
	axxsw = +eyx2.*eyy1./ezz2./(e+w)./ns21;

	ayyne = +exy4.*exx1./ezz4./(n+s)./ew14;
	ayyse = -exy3.*exx2./ezz3./(n+s)./ew23;
	ayynw = -exy1.*exx4./ezz1./(n+s)./ew14;
	ayysw = +exy2.*exx3./ezz2./(n+s)./ew23;

	axxp = - axxn - axxs - axxe - axxw - axxne - axxse - axxnw - axxsw ...
	       + k^2*(n+s).*(eyy4.*eyy3.*e./ns34 + eyy1.*eyy2.*w./ns21)./(e+w);

	ayyp = - ayyn - ayys - ayye - ayyw - ayyne - ayyse - ayynw - ayysw ...
	       + k^2*(e+w).*(exx1.*exx4.*n./ew14 + exx2.*exx3.*s./ew23)./(n+s);

	axyn = (eyy3.*eyy4./ezz4./ns34 - ...
	        eyy2.*eyy1./ezz1./ns21 + ...
	        s.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	axys = (eyy1.*eyy2./ezz2./ns21 - ...
	        eyy4.*eyy3./ezz3./ns34 + ...
	        n.*(eyy2.*eyy4 - eyy1.*eyy3)./ns21./ns34)./(e+w);

	ayxe = (exx1.*exx4./ezz4./ew14 - ...
	        exx2.*exx3./ezz3./ew23 + ...
	        w.*(exx2.*exx4 - exx1.*exx3)./ew23./ew14)./(n+s);

	ayxw = (exx3.*exx2./ezz2./ew23 - ...
	        exx4.*exx1./ezz1./ew14 + ...
	        e.*(exx4.*exx2 - exx1.*exx3)./ew23./ew14)./(n+s);

	axye = (eyy4.*(1-eyy3./ezz3) - eyy3.*(1-eyy4./ezz4))./ns34./(e+w) - ...
	       2*(eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyy1.*eyy2.*(1./ezz1-1./ezz2).*w.^2./ns21 + ...
	          eyy3.*eyy4.*(1./ezz4-1./ezz3).*e.*w./ns34)./e./(e+w).^2;

	axyw = (eyy2.*(1-eyy1./ezz1) - eyy1.*(1-eyy2./ezz2))./ns21./(e+w) - ...
	       2*(eyx4.*eyy3./ezz4.*n.*e./ns34 + ...
	          eyx3.*eyy4./ezz3.*s.*e./ns34 + ...
	          eyx1.*eyy2./ezz1.*n.*w./ns21 + ...
	          eyx2.*eyy1./ezz2.*s.*w./ns21 + ...
	          eyy4.*eyy3.*(1./ezz3-1./ezz4).*e.^2./ns34 + ...
	          eyy2.*eyy1.*(1./ezz2-1./ezz1).*w.*e./ns21)./w./(e+w).^2;

	ayxn = (exx4.*(1-exx1./ezz1) - exx1.*(1-exx4./ezz4))./ew14./(n+s) - ...
	       2*(exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exx3.*exx2.*(1./ezz3-1./ezz2).*s.^2./ew23 + ...
	          exx1.*exx4.*(1./ezz4-1./ezz1).*n.*s./ew14)./n./(n+s).^2;

	ayxs = (exx2.*(1-exx3./ezz3) - exx3.*(1-exx2./ezz2))./ew23./(n+s) - ...
	       2*(exy4.*exx1./ezz4.*e.*n./ew14 + ...
	          exy1.*exx4./ezz1.*w.*n./ew14 + ...
	          exy3.*exx2./ezz3.*e.*s./ew23 + ...
	          exy2.*exx3./ezz2.*w.*s./ew23 + ...
	          exx4.*exx1.*(1./ezz1-1./ezz4).*n.^2./ew14 + ...
	          exx2.*exx3.*(1./ezz2-1./ezz3).*s.*n./ew23)./s./(n+s).^2;

	axyne = +eyy3.*(1-eyy4./ezz4)./(e+w)./ns34;
	axyse = -eyy4.*(1-eyy3./ezz3)./(e+w)./ns34;
	axynw = -eyy2.*(1-eyy1./ezz1)./(e+w)./ns21;
	axysw = +eyy1.*(1-eyy2./ezz2)./(e+w)./ns21;

	ayxne = +exx1.*(1-exx4./ezz4)./(n+s)./ew14;
	ayxse = -exx2.*(1-exx3./ezz3)./(n+s)./ew23;
	ayxnw = -exx4.*(1-exx1./ezz1)./(n+s)./ew14;
	ayxsw = +exx3.*(1-exx2./ezz2)./(n+s)./ew23;

	axyp = -(axyn + axys + axye + axyw + axyne + axyse + axynw + axysw) ...
	       - k^2.*(w.*(n.*eyx1.*eyy2 + s.*eyx2.*eyy1)./ns21 + ...
	               e.*(s.*eyx3.*eyy4 + n.*eyx4.*eyy3)./ns34)./(e+w);

	ayxp = -(ayxn + ayxs + ayxe + ayxw + ayxne + ayxse + ayxnw + ayxsw) ...
	       - k^2.*(n.*(w.*exy1.*exx4 + e.*exy4.*exx1)./ew14 + ...
	               s.*(w.*exy2.*exx3 + e.*exy3.*exx2)./ew23)./(n+s);  

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	axxs(ib)  = axxs(ib)  + sign*axxn(ib);
	axxse(ib) = axxse(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxnw(ib);
	ayxs(ib)  = ayxs(ib)  + sign*ayxn(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxnw(ib);
	ayys(ib)  = ayys(ib)  - sign*ayyn(ib);
	ayyse(ib) = ayyse(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayynw(ib);
	axys(ib)  = axys(ib)  - sign*axyn(ib);
	axyse(ib) = axyse(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	axxn(ib)  = axxn(ib)  + sign*axxs(ib);
	axxne(ib) = axxne(ib) + sign*axxse(ib);
	axxnw(ib) = axxnw(ib) + sign*axxsw(ib);
	ayxn(ib)  = ayxn(ib)  + sign*ayxs(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxse(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxsw(ib);
	ayyn(ib)  = ayyn(ib)  - sign*ayys(ib);
	ayyne(ib) = ayyne(ib) - sign*ayyse(ib);
	ayynw(ib) = ayynw(ib) - sign*ayysw(ib);
	axyn(ib)  = axyn(ib)  - sign*axys(ib);
	axyne(ib) = axyne(ib) - sign*axyse(ib);
	axynw(ib) = axynw(ib) - sign*axysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	axxw(ib)  = axxw(ib)  + sign*axxe(ib);
	axxnw(ib) = axxnw(ib) + sign*axxne(ib);
	axxsw(ib) = axxsw(ib) + sign*axxse(ib);
	ayxw(ib)  = ayxw(ib)  + sign*ayxe(ib);
	ayxnw(ib) = ayxnw(ib) + sign*ayxne(ib);
	ayxsw(ib) = ayxsw(ib) + sign*ayxse(ib);
	ayyw(ib)  = ayyw(ib)  - sign*ayye(ib);
	ayynw(ib) = ayynw(ib) - sign*ayyne(ib);
	ayysw(ib) = ayysw(ib) - sign*ayyse(ib);
	axyw(ib)  = axyw(ib)  - sign*axye(ib);
	axynw(ib) = axynw(ib) - sign*axyne(ib);
	axysw(ib) = axysw(ib) - sign*axyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	axxe(ib)  = axxe(ib)  + sign*axxw(ib);
	axxne(ib) = axxne(ib) + sign*axxnw(ib);
	axxse(ib) = axxse(ib) + sign*axxsw(ib);
	ayxe(ib)  = ayxe(ib)  + sign*ayxw(ib);
	ayxne(ib) = ayxne(ib) + sign*ayxnw(ib);
	ayxse(ib) = ayxse(ib) + sign*ayxsw(ib);
	ayye(ib)  = ayye(ib)  - sign*ayyw(ib);
	ayyne(ib) = ayyne(ib) - sign*ayynw(ib);
	ayyse(ib) = ayyse(ib) - sign*ayysw(ib);
	axye(ib)  = axye(ib)  - sign*axyw(ib);
	axyne(ib) = axyne(ib) - sign*axynw(ib);
	axyse(ib) = axyse(ib) - sign*axysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Axx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axxp(iall),axxe(iw),axxw(ie),axxn(is),axxs(in), ...
	     axxsw(ine),axxnw(ise),axxne(isw),axxse(inw)]);

	Axy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[axyp(iall),axye(iw),axyw(ie),axyn(is),axys(in), ...
	     axysw(ine),axynw(ise),axyne(isw),axyse(inw)]);

	Ayx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayxp(iall),ayxe(iw),ayxw(ie),ayxn(is),ayxs(in), ...
	     ayxsw(ine),ayxnw(ise),ayxne(isw),ayxse(inw)]);

	Ayy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[ayyp(iall),ayye(iw),ayyw(ie),ayyn(is),ayys(in), ...
	     ayysw(ine),ayynw(ise),ayyne(isw),ayyse(inw)]);

	A = [[Axx Axy];[Ayx Ayy]];

	% fprintf(1,'nnz(A) = %d\n',nnz(A));

	shift = (guess*k)^2;
	options.tol = 1e-8;
	options.disp = 0;						% suppress output

	clear Axx Axy Ayx Ayy ...
	    axxnw axxne axxne ...
	    axxw  axxp  axxe ...
	    axxsw axxse axxse ...
	    axynw axyne axyne ...
	    axyw  axyp  axye ...
	    axysw axyse axyse ...
	    ayynw ayyne ayyne ...
	    ayyw  ayyp  ayye ...
	    ayysw ayyse ayyse ...
	    ayxnw ayxne ayxne ...
	    ayxw  ayxp  ayxe ...
	    ayxsw ayxse ayxse ...
	    iall ie iw in iw ...
	    isw inw ine ise ...
	    exx1 exx2 exx3 exx4 ...
	    exy1 exy2 exy3 exy4 ...
	    eyx1 eyx2 eyx3 eyx4 ...
	    eyy1 eyy2 eyy3 eyy4 ...
	    ezz1 ezz2 ezz3 ezz4 ...
	    ns21 ns34 ew14 ew23;

	[v,d] = eigs(A,speye(size(A)),nmodes,shift,options);
	neff = lambda*sqrt(diag(d))/(2*pi);

	phix = zeros(nx,ny,nmodes);
	phiy = zeros(nx,ny,nmodes);
	temp = zeros(nx,2*ny);

	% Normalize modes

	temp = zeros(nx*ny,2);
	for kk = 1:nmodes;
	  temp(:) = v(:,kk);
	  [mag,ii] = max(sqrt(sum(abs(temp).^2,2)));
	  if gt(abs(temp(ii,1)), abs(temp(ii,2))),
	    jj = 1;
	  else 
	    jj = 2;
	  end
	  mag = mag*temp(ii,jj)/abs(temp(ii,jj));
	  temp = temp/mag;
	  phix(:,:,kk) = reshape(temp(:,1),nx,ny);
	  phiy(:,:,kk) = reshape(temp(:,2),nx,ny);
	end;

	return;
end

function [x,y,xc,yc,nx,ny,eps,varargout] = waveguidemesh(n,h,rh,rw,side,dx,dy);

	% This function creates an index mesh for the finite-difference
	% mode solver.  The function will accommodate a generalized three
	% layer rib waveguide structure.  (Note: channel waveguides can
	% also be treated by selecting the parameters appropriately.) 
	% 
	% USAGE:
	% 
	% [x,y,xc,yc,nx,ny,eps] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	% [x,y,xc,yc,nx,ny,eps,edges] = waveguidemesh(n,h,rh,rw,side,dx,dy)
	%
	% INPUT
	%
	% n - indices of refraction for layers in waveguide
	% h - height of each layer in waveguide
	% rh - height of waveguide feature
	% rw - half-width of waveguide
	% side - excess space to the right of waveguide
	% dx - horizontal grid spacing
	% dy - vertical grid spacing
	% 
	% OUTPUT
	% 
	% x,y - vectors specifying mesh coordinates
	% xc,yc - vectors specifying grid-center coordinates
	% nx,ny - size of index mesh
	% eps - index mesh (n^2)
	% edges - (optional) list of edge coordinates, to be used later
	%   with the line() command to plot the waveguide edges
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	ih = round(h/dy);
	irh = round (rh/dy);
	irw = round (rw/dx);
	iside = round (side/dx);
	nlayers = length(h);

	nx = irw+iside+1;
	ny = sum(ih)+1;

	xc = (1:(nx-1))'*dx - dx/2;
	yc = (1:(ny-1))*dy - dy/2;
	x = (0:(nx-1))'*dx;
	y = (0:(ny-1))*dy;

	eps = zeros(nx-1,ny-1);

	iy = 1;

	for jj = 1:nlayers,
	  for i = 1:ih(jj),
		eps(:,iy) = n(jj)^2*ones(nx-1,1);
		iy = iy+1;
	  end
	end

	iy = sum(ih)-ih(nlayers);
	for i = 1:irh,
	   eps(irw+1:irw+iside,iy) = n(nlayers)^2*ones(iside,1);
	   iy = iy-1;
	end

	nx = length(xc);
	ny = length(yc);

	if (nargout == 8)
	  iyp = cumsum(ih);
	  for jj = 1:nlayers-2,
	    if (ge(iyp(jj),(iyp(nlayers-1)-irh)))
	  edges{1,jj} = dx*[0,irw];
	    else
	      edges{1,jj} = dx*[0,irw+iside];
	    end
	    edges{2,jj} = dy*[1,1]*iyp(jj);
	  end
	  jj = nlayers-1;
	  edges{1,jj} = dx*[0,irw,irw,irw+iside];
	  edges{2,jj} = dy*[iyp(jj),iyp(jj),iyp(jj)-irh,iyp(jj)-irh];
	  varargout(1) = {edges};
	end

end

function [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method)

	% This function can be used to continuously stretch the grid
	% spacing at the edges of the computation window for
	% finite-difference calculations.  This is useful when you would
	% like to increase the size of the computation window without
	% increasing the total number of points in the computational
	% domain.  The program implements four different expansion
	% methods: uniform, linear, parabolic (the default) and
	% geometric.  The first three methods also allow for complex
	% coordinate stretching, which is useful for creating
	% perfectly-matched non-reflective boundaries.
	%
	% USAGE:
	% 
	% [x,y] = stretchmesh(x,y,nlayers,factor);
	% [x,y] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc] = stretchmesh(x,y,nlayers,factor,method);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor);
	% [x,y,xc,yc,dx,dy] = stretchmesh(x,y,nlayers,factor,method);
	% 
	% INPUT:
	% 
	% x,y - vectors that specify the vertices of the original
	%   grid, which are usually linearly spaced.
	% nlayers - vector that specifies how many layers of the grid
	%   you would like to expand:
	%   nlayers(1) = # of layers on the north boundary to stretch
	%   nlayers(2) = # of layers on the south boundary to stretch
	%   nlayers(3) = # of layers on the east boundary to stretch
	%   nlayers(4) = # of layers on the west boundary to stretch
	% factor - cumulative factor by which the layers are to be
	%   expanded.  As with nlayers, this can be a 4-vector.
	% method - 4-letter string specifying the method of
	%   stretching for each of the four boundaries.  Four different
	%   methods are supported: uniform, linear, parabolic (default)
	%   and geometric.  For example, method = 'LLLG' will use linear
	%   expansion for the north, south and east boundaries and
	%   geometric expansion for the west boundary.
	% 
	% OUTPUT:
	% 
	% x,y - the vertices of the new stretched grid
	% xc,yc (optional) - the center cell coordinates of the
	%   stretched grid 
	% dx,dy (optional) - the grid spacing (dx = diff(x))
	%
	% AUTHOR:  Thomas E. Murphy (tem@umd.edu)

	if (lt(nargin, 5))
	  method = 'PPPP';
	end 

	if isscalar(factor)
	  factor = factor*ones(1,4);
	end

	% Stretch out north boundary
	n = nlayers(1);
	f = factor(1);
	if and( (gt(n, 0)) , (f ~= 1) );
	  kv = (length(y)-n:length(y));
	  q1 = y(length(y)-n);
	  q2 = y(length(y));
  
	  switch upper(method(1))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-real(f)*z,real(f));
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out south boundary
	n = nlayers(2);
	f = factor(2);
	if and(  gt(n, 0), (f ~= 1));
	  kv = (1:1+n);
	  q1 = y(1+n);
	  q2 = y(1);

	  switch upper(method(2))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    y(kv) = polyval(c,y(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    y(kv) = a + b*y(kv) + c*y(kv).^2;
	   case 'P'    % Parabolic expansion
	    y(kv) = y(kv) + (f-1)*(y(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    y(kv) = q1 + a*(exp((y(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out east boundary
	n = nlayers(3);
	f = factor(3);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (length(x)-n:length(x));
      q1 = x(length(x)-n);
	  q2 = x(length(x));

	  switch upper(method(3))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	% Stretch out west boundary
	n = nlayers(4);
	f = factor(4);
	if and( gt(n, 0), (f ~= 1) );
	  kv = (1:1+n);
	  q1 = x(1+n);
	  q2 = x(1);

	  switch upper(method(4))
	   case 'U'    % Uniform expansion
	    c = polyfit([q1,q2],[q1,q1 + f*(q2-q1)],1);
	    x(kv) = polyval(c,x(kv));
	   case 'L'    % Linear expansion
	    c = (f-1)/(q2-q1);
	    b = 1 - 2*c*q1;
	    a = q1 - b*q1 - c*q1^2;
	    x(kv) = a + b*x(kv) + c*x(kv).^2;
	   case 'P'    % Parabolic expansion
	    x(kv) = x(kv) + (f-1)*(x(kv)-q1).^3/(q2-q1).^2;
	   case 'G'    % Geometric expansion
	    b = fzero(@(z) exp(z)-1-f*z,f);
	    a = (q2-q1)/b;
	    x(kv) = q1 + a*(exp((x(kv)-q1)/a) - 1);  
	  end
	end

	if (gt(nargout, 2))
	  kv = 1:length(x)-1;
	  xc = (x(kv) + x(kv+1))/2;
  
	  kv = 1:length(y)-1;
	  yc = (y(kv) + y(kv+1))/2;
	end

	if (gt(nargout, 4))
	  dx = diff(x);
	  dy = diff(y);
	end
end

function [Hz,Ex,Ey,Ez] = postprocess (lambda,neff,Hx,Hy,dx,dy,varargin);

	% This function takes the two computed transverse magnetic
	% fields (Hx and Hy) of an optical waveguide structure and
	% solves for the remaining 4 vield components:  Hz, Ex, Ey,
	% and Ez.
	%
	% USAGE:
	% 
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     eps, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsyy, epszz, boundary);
	% [Hz,Ex,Ey,Ez] = postprocess(lambda, neff, Hx, Hy, dx, dy, ...
	%                     epsxx, epsxy, epsyx, epsyy, epszz, boundary);
	% 
	% INPUT:
	% 
	% lambda - optical wavelength at which mode was calculated
	% neff - the calculated effective index of the optial mode
	% Hx, Hy - the calculated transverse magnetic fields of the mode
	% dx - horizontal grid spacing (vector or scalar)
	% dy - vertical grid spacing (vector or scalar)
	% eps - index mesh (isotropic materials)  OR:
	% epsxx, epsxy, epsyx, epsyy, epszz - index mesh (anisotropic)
	% boundary - 4 letter string specifying boundary conditions to be
	% applied at the edges of the computation window.  
	%   boundary(1) = North boundary condition
	%   boundary(2) = South boundary condition
	%   boundary(3) = East boundary condition
	%   boundary(4) = West boundary condition
	% The following boundary conditions are supported: 
	%   'A' - Hx is antisymmetric, Hy is symmetric.
	%   'S' - Hx is symmetric and, Hy is antisymmetric.
	%   '0' - Hx and Hy are zero immediately outside of the
	%         boundary. 
	% 
	% OUTPUT:
	% 
	% Hz - calculated longitudinal magnetic field.  This output will 
	%   have the same dimensions as Hx and Hy.
	% Ex, Ey, Ez - calculated electric field.  These field components 
	%   are computed at the center of each element instead of on the
	%   edges or vertices.
	%
	% NOTES:
	%
	% 1) This routine is meant to be used in conjunction with
	% wgmodes.m, the vector eigenmode solver.  Please consult the
	% help file for wgmodes.m for more information.
	%
	% 2) The boundary conditions and waveguide specifications
	% (given in dx, dy, eps, and boundary) should be the same as
	% what was used in wgmodes.m to compute the mode.
	%
	% 3) The magnetic field components (Hx, Hy, and Hz) are
	% calculated at the edges of each cell, whereas the electric
	% field components are computed at the center of each cell.
	% Therefore if size(eps) = [n,m], then the magnetic fields
	% will have a size of [n+1,m+1] while the computed electric
	% fields will have a size of [n,m].
	%
	% 4) Even though wgmodes.m will optionally calculate more than
	% one mode at a time, this postprocessing routine must be
	% invoked separately for each computed mode.
	%
	% AUTHORS:  Thomas E. Murphy (tem@umd.edu)

	if (nargin == 12)
	  epsxx = varargin{1};
	  epsxy = varargin{2};
	  epsyx = varargin{3};
	  epsyy = varargin{4};
	  epszz = varargin{5};
	  boundary = varargin{6};
	elseif (nargin == 10)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = varargin{2};
	  epszz = varargin{3};
	  boundary = varargin{4};
	elseif (nargin == 8)
	  epsxx = varargin{1};
	  epsxy = zeros(size(epsxx));
	  epsyx = zeros(size(epsxx));
	  epsyy = epsxx;
	  epszz = epsxx;
	  boundary = varargin{2};
	else
	  error('Incorrect number of input arguments.\n');
	end

	[nx,ny] = size(epsxx);
	nx = nx + 1;
	ny = ny + 1;

	% now we pad eps on all sides by one grid point
	epsxx = [epsxx(:,1),epsxx,epsxx(:,ny-1)];
	epsxx = [epsxx(1,1:ny+1);epsxx;epsxx(nx-1,1:ny+1)];

	epsyy = [epsyy(:,1),epsyy,epsyy(:,ny-1)];
	epsyy = [epsyy(1,1:ny+1);epsyy;epsyy(nx-1,1:ny+1)];

	epsxy = [epsxy(:,1),epsxy,epsxy(:,ny-1)];
	epsxy = [epsxy(1,1:ny+1);epsxy;epsxy(nx-1,1:ny+1)];

	epsyx = [epsyx(:,1),epsyx,epsyx(:,ny-1)];
	epsyx = [epsyx(1,1:ny+1);epsyx;epsyx(nx-1,1:ny+1)];

	epszz = [epszz(:,1),epszz,epszz(:,ny-1)];
	epszz = [epszz(1,1:ny+1);epszz;epszz(nx-1,1:ny+1)];

	k = 2*pi/lambda;  % free-space wavevector
	b = neff*k;       % propagation constant (eigenvalue)

	if isscalar(dx)
	  dx = dx*ones(nx+1,1);             % uniform grid
	else
	  dx = dx(:);                       % convert to column vector
	  dx = [dx(1);dx;dx(length(dx))];   % pad dx on top and bottom
	end

	if isscalar(dy)
	  dy = dy*ones(1,ny+1);             % uniform grid
	else
	  dy = dy(:);                       % convert to column vector
	  dy = [dy(1);dy;dy(length(dy))]';  % pad dy on top and bottom
	end

	% distance to neighboring points to north south east and west,
	% relative to point under consideration (P), as shown below.

	n = ones(1,nx*ny);      n(:) = ones(nx,1)*dy(2:ny+1);
	s = ones(1,nx*ny);      s(:) = ones(nx,1)*dy(1:ny);
	e = ones(1,nx*ny);      e(:) = dx(2:nx+1)*ones(1,ny);
	w = ones(1,nx*ny);      w(:) = dx(1:nx)*ones(1,ny);

	% epsilon tensor elements in regions 1,2,3,4, relative to the
	% mesh point under consideration (P), as shown below.
	%
	%                 NW------N------NE
	%                 |       |       |
	%                 |   1   n   4   |
	%                 |       |       |
	%                 W---w---P---e---E
	%                 |       |       |
	%                 |   2   s   3   |
	%                 |       |       |
	%                 SW------S------SE

	exx1 = ones(1,nx*ny);   exx1(:) = epsxx(1:nx,2:ny+1);
	exx2 = ones(1,nx*ny);   exx2(:) = epsxx(1:nx,1:ny);
	exx3 = ones(1,nx*ny);   exx3(:) = epsxx(2:nx+1,1:ny);
	exx4 = ones(1,nx*ny);   exx4(:) = epsxx(2:nx+1,2:ny+1);

	eyy1 = ones(1,nx*ny);   eyy1(:) = epsyy(1:nx,2:ny+1);
	eyy2 = ones(1,nx*ny);   eyy2(:) = epsyy(1:nx,1:ny);
	eyy3 = ones(1,nx*ny);   eyy3(:) = epsyy(2:nx+1,1:ny);
	eyy4 = ones(1,nx*ny);   eyy4(:) = epsyy(2:nx+1,2:ny+1);

	exy1 = ones(1,nx*ny);   exy1(:) = epsxy(1:nx,2:ny+1);
	exy2 = ones(1,nx*ny);   exy2(:) = epsxy(1:nx,1:ny);
	exy3 = ones(1,nx*ny);   exy3(:) = epsxy(2:nx+1,1:ny);
	exy4 = ones(1,nx*ny);   exy4(:) = epsxy(2:nx+1,2:ny+1);

	eyx1 = ones(1,nx*ny);   eyx1(:) = epsyx(1:nx,2:ny+1);
	eyx2 = ones(1,nx*ny);   eyx2(:) = epsyx(1:nx,1:ny);
	eyx3 = ones(1,nx*ny);   eyx3(:) = epsyx(2:nx+1,1:ny);
	eyx4 = ones(1,nx*ny);   eyx4(:) = epsyx(2:nx+1,2:ny+1);

	ezz1 = ones(1,nx*ny);   ezz1(:) = epszz(1:nx,2:ny+1);
	ezz2 = ones(1,nx*ny);   ezz2(:) = epszz(1:nx,1:ny);
	ezz3 = ones(1,nx*ny);   ezz3(:) = epszz(2:nx+1,1:ny);
	ezz4 = ones(1,nx*ny);   ezz4(:) = epszz(2:nx+1,2:ny+1);

	bzxne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx4./ezz4./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx4./ezz4)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzxse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*eyx3./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx3./ezz3)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzxnw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx1./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1-exx1./ezz1)./ezz3./ezz2./(w.*exx3+e.*exx2)./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzxsw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*eyx2./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1-exx2./ezz2)./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzxn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*n.*ezz1.*ezz2./eyy1.*(2.*eyy1./ezz1./n.^2+eyx1./ezz1./n./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*n.*ezz4.*ezz3./eyy4.*(2.*eyy4./ezz4./n.^2-eyx4./ezz4./n./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*((1-exx1./ezz1)./n./w-exy1./ezz1.*(2./n.^2-2./n.^2.*s./(n+s)))./exx1.*ezz1.*w+(ezz4-ezz1).*s./n./(n+s)+1./2.*ezz1.*(-(1-exx4./ezz4)./n./e-exy4./ezz4.*(2./n.^2-2./n.^2.*s./(n+s)))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(-ezz3.*exy2./n./(n+s)./exx2.*w+(ezz3-ezz2).*s./n./(n+s)-ezz2.*exy3./n./(n+s)./exx3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxs =((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*s.*ezz2.*ezz1./eyy2.*(2.*eyy2./ezz2./s.^2-eyx2./ezz2./s./w)+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*s.*ezz3.*ezz4./eyy3.*(2.*eyy3./ezz3./s.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(-ezz4.*exy1./s./(n+s)./exx1.*w-(ezz4-ezz1).*n./s./(n+s)-ezz1.*exy4./s./(n+s)./exx4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-(1-exx2./ezz2)./s./w-exy2./ezz2.*(2./s.^2-2./s.^2.*n./(n+s)))./exx2.*ezz2.*w-(ezz3-ezz2).*n./s./(n+s)+1./2.*ezz2.*((1-exx3./ezz3)./s./e-exy3./ezz3.*(2./s.^2-2./s.^2.*n./(n+s)))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxe = ((n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(2./e.^2-eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(2./e.^2+eyx3./ezz3./s./e))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(1-exx4./ezz4)./n./exx4.*ezz4-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(1-exx3./ezz3)./s./exx3.*ezz3)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxw = ((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(2./w.^2+eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(2./w.^2-eyx2./ezz2./s./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(1-exx1./ezz1)./n./exx1.*ezz1+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(1-exx2./ezz2)./s./exx2.*ezz2)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzxp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-2./w.^2-2.*eyy1./ezz1./n.^2+k.^2.*eyy1-eyx1./ezz1./n./w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-2./w.^2-2.*eyy2./ezz2./s.^2+k.^2.*eyy2+eyx2./ezz2./s./w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-2./e.^2-2.*eyy4./ezz4./n.^2+k.^2.*eyy4+eyx4./ezz4./n./e)+1./2.*s.*ezz3.*ezz4./eyy3.*(-2./e.^2-2.*eyy3./ezz3./s.^2+k.^2.*eyy3-eyx3./ezz3./s./e)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-k.^2.*exy1-(1-exx1./ezz1)./n./w-exy1./ezz1.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx1.*ezz1.*w+(ezz4-ezz1).*(n-s)./n./s+1./2.*ezz1.*(-k.^2.*exy4+(1-exx4./ezz4)./n./e-exy4./ezz4.*(-2./n.^2-2./n.^2.*(n-s)./s))./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-k.^2.*exy2+(1-exx2./ezz2)./s./w-exy2./ezz2.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx2.*ezz2.*w+(ezz3-ezz2).*(n-s)./n./s+1./2.*ezz2.*(-k.^2.*exy3-(1-exx3./ezz3)./s./e-exy3./ezz3.*(-2./s.^2+2./s.^2.*(n-s)./n))./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyne = (1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy4./ezz4)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy3.*eyy1.*w.*eyy2+1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy4./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx1.*s)./b;

	bzyse = (-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1-eyy3./ezz3)./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy1.*w.*eyy2+1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy3./ezz3./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*n.*exx1.*exx4)./b;

	bzynw = (-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy1./ezz1)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy2.*e-1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*exy1./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*exx4.*s)./b;

	bzysw = (1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1-eyy2./ezz2)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*exy2./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx3.*n.*exx1.*exx4)./b;

	bzyn = ((1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz1.*ezz2./eyy1.*(1-eyy1./ezz1)./w-1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz4.*ezz3./eyy4.*(1-eyy4./ezz4)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(2./n.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(2./n.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzys = ((-1./2.*(-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*ezz2.*ezz1./eyy2.*(1-eyy2./ezz2)./w+1./2.*(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*ezz3.*ezz4./eyy3.*(1-eyy3./ezz3)./e)./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(2./s.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(2./s.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzye = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(-n.*ezz2./eyy1.*eyx1./e./(e+w)+(ezz1-ezz2).*w./e./(e+w)-s.*ezz1./eyy2.*eyx2./e./(e+w))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(2./e.^2-2./e.^2.*w./(e+w)))+1./2.*s.*ezz3.*ezz4./eyy3.*((1-eyy3./ezz3)./s./e-eyx3./ezz3.*(2./e.^2-2./e.^2.*w./(e+w)))+(ezz4-ezz3).*w./e./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz1.*(2.*exx4./ezz4./e.^2-exy4./ezz4./n./e)./exx4.*ezz4.*e-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz2.*(2.*exx3./ezz3./e.^2+exy3./ezz3./s./e)./exx3.*ezz3.*e)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyw = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*((1-eyy1./ezz1)./n./w-eyx1./ezz1.*(2./w.^2-2./w.^2.*e./(e+w)))-(ezz1-ezz2).*e./w./(e+w)+1./2.*s.*ezz2.*ezz1./eyy2.*(-(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(2./w.^2-2./w.^2.*e./(e+w))))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(-n.*ezz3./eyy4.*eyx4./w./(e+w)-s.*ezz4./eyy3.*eyx3./w./(e+w)-(ezz4-ezz3).*e./w./(e+w)))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+(1./2.*(ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*ezz4.*(2.*exx1./ezz1./w.^2+exy1./ezz1./n./w)./exx1.*ezz1.*w-1./2.*(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*ezz3.*(2.*exx2./ezz2./w.^2-exy2./ezz2./s./w)./exx2.*ezz2.*w)./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	bzyp = (((-n.*ezz4.*ezz3./eyy4-s.*ezz3.*ezz4./eyy3).*(1./2.*n.*ezz1.*ezz2./eyy1.*(-k.^2.*eyx1-(1-eyy1./ezz1)./n./w-eyx1./ezz1.*(-2./w.^2+2./w.^2.*(e-w)./e))+(ezz1-ezz2).*(e-w)./e./w+1./2.*s.*ezz2.*ezz1./eyy2.*(-k.^2.*eyx2+(1-eyy2./ezz2)./s./w-eyx2./ezz2.*(-2./w.^2+2./w.^2.*(e-w)./e)))+(n.*ezz1.*ezz2./eyy1+s.*ezz2.*ezz1./eyy2).*(1./2.*n.*ezz4.*ezz3./eyy4.*(-k.^2.*eyx4+(1-eyy4./ezz4)./n./e-eyx4./ezz4.*(-2./e.^2-2./e.^2.*(e-w)./w))+1./2.*s.*ezz3.*ezz4./eyy3.*(-k.^2.*eyx3-(1-eyy3./ezz3)./s./e-eyx3./ezz3.*(-2./e.^2-2./e.^2.*(e-w)./w))+(ezz4-ezz3).*(e-w)./e./w))./ezz4./ezz3./(n.*eyy3+s.*eyy4)./ezz2./ezz1./(n.*eyy2+s.*eyy1)./(e+w).*eyy4.*eyy3.*eyy1.*w.*eyy2.*e+((ezz3./exx2.*ezz2.*w+ezz2./exx3.*ezz3.*e).*(1./2.*ezz4.*(-2./n.^2-2.*exx1./ezz1./w.^2+k.^2.*exx1-exy1./ezz1./n./w)./exx1.*ezz1.*w+1./2.*ezz1.*(-2./n.^2-2.*exx4./ezz4./e.^2+k.^2.*exx4+exy4./ezz4./n./e)./exx4.*ezz4.*e)-(ezz4./exx1.*ezz1.*w+ezz1./exx4.*ezz4.*e).*(1./2.*ezz3.*(-2./s.^2-2.*exx2./ezz2./w.^2+k.^2.*exx2+exy2./ezz2./s./w)./exx2.*ezz2.*w+1./2.*ezz2.*(-2./s.^2-2.*exx3./ezz3./e.^2+k.^2.*exx3-exy3./ezz3./s./e)./exx3.*ezz3.*e))./ezz3./ezz2./(w.*exx3+e.*exx2)./ezz4./ezz1./(w.*exx4+e.*exx1)./(n+s).*exx2.*exx3.*n.*exx1.*exx4.*s)./b;

	ii = zeros(nx,ny);
	ii(:) = (1:nx*ny); 

	% NORTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,ny);

	switch (boundary(1))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized north boundary condition: %s.\n', boundary(1));
	end

	bzxs(ib)  = bzxs(ib)  + sign*bzxn(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxnw(ib);
	bzys(ib)  = bzys(ib)  - sign*bzyn(ib);
	bzyse(ib) = bzyse(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzynw(ib);

	% SOUTH boundary

	ib = zeros(nx,1);  ib(:) = ii(1:nx,1);

	switch (boundary(2))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized south boundary condition: %s.\n', boundary(2));
	end

	bzxn(ib)  = bzxn(ib)  + sign*bzxs(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxse(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxsw(ib);
	bzyn(ib)  = bzyn(ib)  - sign*bzys(ib);
	bzyne(ib) = bzyne(ib) - sign*bzyse(ib);
	bzynw(ib) = bzynw(ib) - sign*bzysw(ib);

	% EAST boundary

	ib = zeros(1,ny);  ib(:) = ii(nx,1:ny);

	switch (boundary(3))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized east boundary condition: %s.\n', boundary(3));
	end

	bzxw(ib)  = bzxw(ib)  + sign*bzxe(ib);
	bzxnw(ib) = bzxnw(ib) + sign*bzxne(ib);
	bzxsw(ib) = bzxsw(ib) + sign*bzxse(ib);
	bzyw(ib)  = bzyw(ib)  - sign*bzye(ib);
	bzynw(ib) = bzynw(ib) - sign*bzyne(ib);
	bzysw(ib) = bzysw(ib) - sign*bzyse(ib);

	% WEST boundary

	ib = zeros(1,ny);  ib(:) = ii(1,1:ny);

	switch (boundary(4))
	  case 'S',   sign = +1;
	  case 'A',   sign = -1;
	  case '0',   sign = 0;
	  otherwise,  
	    error('Unrecognized west boundary condition: %s.\n', boundary(4));
	end

	bzxe(ib)  = bzxe(ib)  + sign*bzxw(ib);
	bzxne(ib) = bzxne(ib) + sign*bzxnw(ib);
	bzxse(ib) = bzxse(ib) + sign*bzxsw(ib);
	bzye(ib)  = bzye(ib)  - sign*bzyw(ib);
	bzyne(ib) = bzyne(ib) - sign*bzynw(ib);
	bzyse(ib) = bzyse(ib) - sign*bzysw(ib);

	% Assemble sparse matrix

	iall = zeros(1,nx*ny);          iall(:) = ii;
	is = zeros(1,nx*(ny-1));        is(:) = ii(1:nx,1:(ny-1));
	in = zeros(1,nx*(ny-1));        in(:) = ii(1:nx,2:ny);
	ie = zeros(1,(nx-1)*ny);        ie(:) = ii(2:nx,1:ny);
	iw = zeros(1,(nx-1)*ny);        iw(:) = ii(1:(nx-1),1:ny);
	ine = zeros(1,(nx-1)*(ny-1));   ine(:) = ii(2:nx, 2:ny);
	ise = zeros(1,(nx-1)*(ny-1));   ise(:) = ii(2:nx, 1:(ny-1));
	isw = zeros(1,(nx-1)*(ny-1));   isw(:) = ii(1:(nx-1), 1:(ny-1));
	inw = zeros(1,(nx-1)*(ny-1));   inw(:) = ii(1:(nx-1), 2:ny);

	Bzx = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzxp(iall),bzxe(iw),bzxw(ie),bzxn(is),bzxs(in), ...
	     bzxsw(ine),bzxnw(ise),bzxne(isw),bzxse(inw)]);

	Bzy = sparse ([iall,iw,ie,is,in,ine,ise,isw,inw], ...
		[iall,ie,iw,in,is,isw,inw,ine,ise], ...
		[bzyp(iall),bzye(iw),bzyw(ie),bzyn(is),bzys(in), ...
	     bzysw(ine),bzynw(ise),bzyne(isw),bzyse(inw)]);

	B = [Bzx Bzy];

	Hz = zeros(size(Hx));
	Hz(:) = B*reshape([Hx,Hy],2*nx*ny,1)/j;

	nx = nx-1;
	ny = ny-1;

	exx = epsxx(2:nx+1,2:ny+1);
	exy = epsxy(2:nx+1,2:ny+1);
	eyx = epsyx(2:nx+1,2:ny+1);
	eyy = epsyy(2:nx+1,2:ny+1);
	ezz = epszz(2:nx+1,2:ny+1);
	edet = (exx.*eyy - exy.*eyx);

	h = dx(2:nx+1)*ones(1,ny);
	v = ones(nx,1)*dy(2:ny+1);

	i1 = ii(1:nx,2:ny+1);
	i2 = ii(1:nx,1:ny);
	i3 = ii(2:nx+1,1:ny);
	i4 = ii(2:nx+1,2:ny+1);

	Dx = +neff*(Hy(i1) + Hy(i2) + Hy(i3) + Hy(i4))/4 + ...
	     (Hz(i1) + Hz(i4) - Hz(i2) - Hz(i3))./(j*2*k*v);
	Dy = -neff*(Hx(i1) + Hx(i2) + Hx(i3) + Hx(i4))/4 - ...
	     (Hz(i3) + Hz(i4) - Hz(i1) - Hz(i2))./(j*2*k*h);
	Dz = ((Hy(i3) + Hy(i4) - Hy(i1) - Hy(i2))./(2*h) - ...
	      (Hx(i1) + Hx(i4) - Hx(i2) - Hx(i3))./(2*v))/(j*k);

	Ex = (eyy.*Dx - exy.*Dy)./edet;
	Ey = (exx.*Dy - eyx.*Dx)./edet;
	Ez = Dz./ezz;

end

function [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% Produces a properly scaled color plot of a two-dimensional
	% mode.  This routine is especially useful when x and y are
	% non-uniformly spaced vectors.  In this case, the mode is
	% interpolated over a uniformly-spaced grid before producing
	% an image plot.  The output can be directly saved to a file
	% using the imwrite() function.
	% 
	% USAGE:
	% 
	% [xf,yf,modebmp] = imagemode(x,y,mode);
	% [xf,yf,modebmp] = imagemode(x,y,mode,dx,dy);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dx, dy (optional) - fine grid spacing at which to oversample
	%   (interpolate) the mode.  If left unspecified, this routine
	%   will use the smallest value of diff(x) and diff(y).
	% 
	% OUTPUT:
	% 
	% xf,yf - points at which the mode was interpolated
	% modebmp - 8-bit unsigned integer array representing the mode
	%    image

	x = real(x);
	y = real(y);

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (nargin == 3)
	  [dx,ix] = min(diff(x));
	  [dy,iy] = min(diff(y));
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	  % line up with finest portion of grid
	  delta = dx*(interp1(xf,(1:length(xf)),x(ix+1)) - ...
	              round(interp1(xf,(1:length(xf)),x(ix+1))));
	  xf = xf + delta;
	  delta = dy*(interp1(yf,(1:length(yf)),y(iy+1)) - ...
	              round(interp1(yf,(1:length(yf)),y(iy+1))));
	  yf = yf + delta;
	  % eliminate points outside of range
	  kv = find( and ( lt(min(x),xf), lt(xf, max(x)) ));
	  xf = xf(kv);
	  kv = find( and ( lt(min(y),yf), lt(yf,max(y)) ));
	  yf = yf(kv);
	else
	  xf = (min(x):dx:max(x))';
	  yf = (min(y):dy:max(y));
	end

	cmax = size(colormap,1)-1;

	modebmp = uint8(transpose(interp2(y,x, ...
	                abs(cmax*mode),yf,xf)));
	image(xf,yf,modebmp);
	set(gca,'YDir','normal');
	v = [min(xf),max(xf),min(yf),max(yf)];
	axis(v);
	set(gca,'PlotBoxAspectRatio',[v(2)-v(1) v(4)-v(3) 1]);

end

function contourmode(x,y,mode,dB,xyrange);

	% Produces a contour plot (in dB) of one field component of the
	% mode of an optical waveguide.
	% 
	% USAGE:
	% 
	% contourmode(x,y,mode);
	% contourmode(x,y,mode,dBrange);
	% contourmode(x,y,mode,dBrange,xyrange);
	% 
	% INPUT:
	% 
	% x,y - vectors describing horizontal and vertical grid points
	% mode - the mode or field component to be plotted
	% dBrange - contour levels to plot (in dB), with 0 dB corresponding
	%   to the level |mode| = 1. default = (0:-3:-45)
	% xyrange - axis range to use (optional)
	%
	% EXAMPLE:  Make a contour plot of the magnetic field component Hx,
	% with contours from 0 dB down to -50 dB, relative to the maximum
	% value, in 5 dB increments. 
	%
	%     contourmode(x,y,Hx/max(abs(Hx(:))),(0:-5:-50));
	%
	% NOTES:  
	%
	% (1) This function uses the current color map to determine the
	%     colors of each contour, with 0 dB corresponding to the
	%     maximum color and -dbmax corresponding to the minimum color.
	%     You can use the 'colormap' command to change the current
	%     color map.
	% (2) The aspect ratio of the plot box is automatically adjusted so
	%     that the horizontal and vertical scales are equal.
	% (3) The mode is not normalized or scaled in any way.

	x = real(x);
	y = real(y);

	if (lt(nargin, 5))
	  xyrange = [min(x),max(x),min(y),max(y)];
	end

	if (size(mode) == [length(x)-1,length(y)-1])
	    x = (x(1:end-1) + x(2:end))/2;
	    y = (y(1:end-1) + y(2:end))/2;
	end

	if (lt(nargin, 4)) || isempty(dB)
	  dB = (0:-3:-45);
	end

	% Compute and plot contours
	c = contourc(x,y,20*log10(abs(transpose(mode))),dB);
	cmap = colormap;
	ii = 1;
%	cla;
	while (lt(ii, length(c))),
	  level = c(1,ii);
	  n = c(2,ii);
	  jj = 1+round((length(cmap)-1)*(level - min(dB))/(max(dB)-min(dB)));
	  color = cmap(jj,:);
	  line(c(1,ii+1:ii+n),c(2,ii+1:ii+n),'Color',color);
	  ii = ii+n+1;
	end

	axis(xyrange);
	set(gca,'PlotBoxAspectRatio',[xyrange(2)-xyrange(1) xyrange(4)-xyrange(3) 1],...
	        'Box','on');

end


      

Copy and paste the WGMODE codes from the previous unit at the bottom of the above code block.  

Change the material index of refraction values.
	  

		%%
      



Could not parse problem




Perform numerical calculations for the following waveguide:



500 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm


TE polarization



Enter the effective index:






Explanation
To arrive at the correct answer, make sure you have done the following:
    Change the wavelength to 1550 nm.Follow the steps in the preceeding tutorial.
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




Perform numerical calculations for the following waveguide:


600 nm width


220 nm height


silicon core


oxide cladding


wavelength = 1550 nm



TM polarization



Enter the effective index (within an accuracy of 0.02):






Explanation
To arrive at the correct answer, make sure you have done the following:
    Look at the 2nd mode, which should be TM polarized. The effective index is smaller than the TE mode.Change the wavelength to 1550 nm.Change the width of the waveguide to 600 nm.Increase the simulation region.  Check that the fields have decayed to 1e-9 (in energy).  This is achieved for an FDE simulation width of 3 micron, and height of 3.5 micron.  
 If you cannot obtain the correct answer, please start a discussion in the discussion section below. 
  
            


Could not parse problem




The group index of the waveguide is a very important parameter, which as we will see, determines one of the most important features of the Mach-Zehnder Interferometer circuit -- the Free Spectral Range.
Find the group index for the following waveguide:



        500 nm width
      

        220 nm height
      

        silicon core
      

        oxide cladding
      

        wavelength = 1550 nm
      

        TM polarization (hint: this is the 2nd mode; the one with the TE polarization fraction (Ex) that is close to 0.)
      


Enter the group index:  (answer checked within +/- 0.03 of the instructor's answer)






Explanation
Make sure you make the following changes in the simulation:
  Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.Increase the number of simulation mesh points, e.g., 200.  Check the simulation mesh, and make sure it lines up with the waveguide edges.Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode. Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
If you are still not getting the same answer (but are "close"), continue on.  There is a unit "Convergence tests", which analyzes the sources of error in the simulations.




 Make sure you make the following changes in the simulation: 
 1) Increase the simulation region to ensure that the fields have decayed.  e.g., height of 3.5 micron, width of 3 micron.   
 2) Increase the number of simulation mesh points, e.g., 200, or even more.  
 3) Check the simulation mesh, and make sure it lines up with the waveguide edges.  
 4) Look at the TM polarization, namely the 2nd mode.  Use the "track selected mode" feature to simulate the selected mode.  
 5) Perform a frequency sweep from 1.55 to 1.55 microns, for 1 point.    Use "detailed dispersion calculation".  Find the group index at 1.55 microns.   
	  
If you are still not getting the same answer (but are "close"), continue on.  There is a later unit "Convergence tests", which analyzes the sources of error in the simulations.


Could not parse problem





Find a polynomial curve fit for the effective index versus wavelength of the fundamental TE mode for a 500x220 nm waveguide, in the 1500 to 1600 nm range.
    
 Note: when your run the code, the last plot is generated by the instructor's code. It allows you to compare your answer with the instructor's.
If you are using Dropbox, you need to change the link to replace dl=0 with dl=1.
Download the matlab script, Phot1x_fit_wg_compactmodel.m
 Note: This is a graded problem.  Click "CHECK" to verify your answer.



      %%    

disp('****************************************************')
disp('The following output is generated by the instructor:')
	  
% Check fit:
if exist('r2')
  if lt(r2,0.8)
    disp 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.'
  end
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
end


% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

if gt(abs(X(1)-X_lukas(1)),0.01)
  disp ('The X(1) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(2)-X_lukas(2)),0.01)
  disp('The X(2) parameter is more than 1% different than the instructor answer.')
end
if gt(abs(X(3)-X_lukas(3)),0.01)
  disp('The X(3) parameter is more than 1% different than the instructor answer.')
end

      



% User provides a matrix of neff values vs. wavelength
% Matlab curve fits to an expression.

% example 1
% TM polarization for a 500 x 220 nm waveguide
% data was copy and pasted from Lumerical MODE to this script:
if (1) 
  neff = [ 1.83383800636377 + 8.05890497290360e-10i, 1.81907207440938 + 7.74616649077559e-10i, ...
           1.80449944644501 + 7.43420301068018e-10i, 1.79013738069386 + 7.12371827806454e-10i, ...
           1.77600267415464 + 6.81543437568018e-10i, 1.76211152154899 + 6.51008307756216e-10i, ...
           1.74847937779721 + 6.20839666142533e-10i, 1.73512082686004 + 5.91109842262606e-10i, ...
           1.72204945969007 + 5.61889315346028e-10i, 1.70927776383582 + 5.33245785940170e-10i];
  f = [ 199861638666667, 198473710620370, 197085782574074, 195697854527778, ...
       194309926481481, 192921998435185, 191534070388889,  190146142342593, ...
       188758214296296, 187370286250000];
end

% example 2
% TM polarization for a 500 x 220 nm waveguide
% data was saved as a MATLAB file, and is loaded
% this requires that you either have the file on the internet and use the "websave" command to access it
% (this is necessary if you are using the in-browser edX MATLAB)
% or run this script on your own computer and load the file from your local disk.
if (0)
  % url='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
  url='https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/wg-export-TM.mat'
  a=websave('wg.mat',url); % get data from Dropbox
  load('wg.mat');
end

neff = real(neff)  % take the real part of the effective index.

c=299792458;  % speed of light, m/s
lambdas = c ./ f;  % f is the matrix of frequency points, 
                   % where the effective index is recorded.
lambdas = lambdas * 1e6  % convert to microns.
lambda0 = 1.55;   % replace with desired centre wavelength

figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;

% use Matlab anonymous function for the effective index expression:
neff_eq = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 

% initial guess.
% The X matrix is defined as follows:  n1 = X(1), n2 = X(2), n3 = X(3)
X=[2.4 0 0]; 

plot ( lambdas, neff_eq(X, lambdas), 'r')

% curve fit to find expression for neff.
format long
X = lsqcurvefit (neff_eq, X, lambdas, neff);

disp (['n1 = ' num2str(X(1)) ', n2 = ' num2str(X(2)) ', n3 = ' num2str(X(3))]);

r=corrcoef(neff,neff_eq(X, lambdas));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

lambdas2=linspace(min(lambdas), max(lambdas), 100);

plot ( lambdas2, neff_eq(X, lambdas2), 'k')
xlabel ('Wavelength [nm]');
ylabel ('Effective Index');

legend ('Data','Initial Guess','Curve Fit')

      

If you don't have Dropbox, you can create the two variables to be used by the above code: neff, and lambdas.  Then proceed to curve fit this data, and compare to the instructor result.
	  

%%
% Grader:
%disp('****************************************************')
%disp('The following output is generated by the instructor:')

% Check:
if exist('url')
 url0='https://www.dropbox.com/s/xv4he4preyfa9v2/wg-export-TM.mat?dl=1'
 assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
end
        
% Check fit:
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

% Check - plot figure:
X_lukas = [2.444509959585626  -1.127332617426486  -0.033346089292517];
if and(and(and(exist('lambdas'), exist('neff')), exist('lambdas2')), exist('neff_eq'))
 figure; plot (lambdas, neff,'o','MarkerSize',10); hold on;
 whitebg([1 .95 1])
 plot ( lambdas2, neff_eq(X, lambdas2), 'k-','LineWidth',4)
 neff_eq_lc = @(nx, lambda) ...
 		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
 lambdas_lc=linspace(1.5, 1.6, 100);
 plot ( lambdas_lc, neff_eq_lc(X_lukas, lambdas_lc), 'g','LineWidth',2)
 xlabel ('Wavelength [nm]');
 ylabel ('Effective Index');
 legend ('Your Data','Your Curve Fit','Instructor Curve Fit')
 disp('The pink figure is generated by the instructor.');
end

% Check:
assert(lt(abs(X(1)-X_lukas(1)),0.01), 'The X(1) parameter is more than 1% different than the instructor answer.')
assert(lt(abs(X(2)-X_lukas(2)),0.02), 'The X(2) parameter is more than 2% different than the instructor answer.')
assert(lt(abs(X(3)-X_lukas(3)),0.1), 'The X(3) parameter is more than 10% different than the instructor answer.')
		
      



Could not parse problem





The objective of this problem is to create a compact model for the waveguide, in the form of an expression.  Find an expression for the effective index versus wavelength.

  Use (ONLY) the following parameters:
  lambda: units micronsthe other parameters should be numbers
Your expression will be verified with the instructor's answer.
The answer should be in the format such as "2.4 - 1 * (lambda-1.55) -0.1 *(lambda-1.55)^2" 

neff = "2.444509 -1.1273 * (lambda - 1.55) -0.03335 * (lambda-1.55)^2"







Explanation
The answer is in the form of \( n_\text{eff}(\lambda) = 2.4 - 1.1 (\lambda - 1.55) + 0.1 (\lambda-1.55)^2 \)



To check the answer, we evaluate your expression over a range of 1.5 to 1.6 microns.  We then compare to the instructor's answer, and check that the effective index you provide is within +/- 0.02 of the correct answer.  


Could not parse problem




What is the waveguide geometry that gives the smallest mode area, for the TE polarization at 1550, for a silicon thickness of 220 nm, strip waveguide?  Answer is the waveguide width, with units of nanometers (required accuracy with 20 nm).






Explanation
Find the smallest mode area to be for a waveguide of approximately 360 nm in width.



Modify the script to sweep (using a for loop), the waveguide width parameter (width_ridge in the script).  Plot the mode area and confinement factor, versus the waveguide width.  
Or do it manually, iteratively.


Could not parse problem


Assume that 1 mW of light is input into an ideal Y-Branch splitter (Port E_0).  
The port labels in this problem are based on the diagram at 1:00 in the video.
_____________________________________________________________________________
How much optical power comes out of output 1 (Port E_1)? [Answer in mW]



Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.




Could not parse problem


Assume that 1 mW of light is input into ONE of the branches of an ideal Y-Branch combiner (Port E_1).  
The port labels in this problem are based on the diagram at 1:45 in the video.
_____________________________________________________________________________
How much optical power comes out of output 0 (Port E_0)?   [Answer in mW]



Explanation
Half the light (optical power, in mW).  1 divided by the square root of two for the E-field.




Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions).  You can ignore the radiation losses (loss in dB/cm in MODE Solutions) since they are small.  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is joined to the bent waveguide with no shift.
 
Determine the bend radius required for a TE mode to ensure that the loss is less than 0.1% (which is 0.004 dB) [Answer in microns, accuracy with +/-0.5]:






Explanation
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap.  Or you can use scripts, as provided in the next unit.
(Sorry for the brief explanation.  Post in the discussion below for more info.)



You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap calculations.  Do it iteratively, which only takes a few minutes. 
Or you can use scripts, as provided in the next unit.
The desired total transmission through the bend is 0.999.  Make sure that you are searching for the overlap value of sqrt(0.999).


Could not parse problem




Find the minimum bend radius required to meet the requirements, for 1550 nm wavelength.  Consider the mode-mismatch (power coupling in MODE Solutions) and radiation losses (loss in dB/cm in MODE Solutions).  Assume an ideal waveguide with 0 dB/cm scattering loss. Assume the straight waveguide is joined to the bent waveguide with no shift.
 
Determine the bend radius required for a TM mode to ensure that the loss is less than 1% (which is 0.04 dB insertion loss)  [Answer in microns, accuracy with +/-1]:




Determine the bend radius required for a TM mode to ensure that the loss is less than 0.1%  [Answer in microns, accuracy with +/-3]:






Explanation
For 11 µm, we find:
  Propagation loss, coming from radiation loss:  0.277 dB/cm.  For a 1/4 circle, you can find the dB for the bend by: ?(-2*pi*11e-4/4*0.277); which is 0.000479 dB.  In linear units, this is   ?10^(-2*pi*11e-4/4*0.277 /10);  which is 0.99989.  Mode-mismatch loss, using overlap calculation:  0.99533Multiply the two together:  ?10^(-2*pi*11e-4/4*0.277 /10) *  (0.99533)^2; = 0.9906.

Quite likely your numbers will be slightly different, due to different simulation configuration (mesh, span, etc).   I used a span of 2.8 µm, with a 10 nm mesh.
  
              For 33 µm, we find:
  Propagation loss, coming from radiation loss: ~0 dB/cm. Mode-mismatch loss, using overlap calculation: 0.99951
(Post in the discussion below for more info.)



For the TM mode, you need to increase the thickness of the simulation, namely in the Z direction, so that the boundaries do not interfere with the simulation.  
If you are having trouble finding the TM mode: In the Eigenmode Analysis settings, you can also use search - near n - 1.8, to help the software find the correct TM mode. 
You can complete this problem by doing manual simulations (as per the video tutorial) using mode overlap and radiation loss calculations.  Doing it manually, iteratively, only takes a few minutes.  
Or you can use scripts, as provided in the next unit.
Don't forget to consider that there are two mode-mismatch losses per bend, so square the overlap value.  And add the radiation loss in dB/cm times the length.


Could not parse problem




Calculate the mode-mismatch and radiation losses for the following bends, for TE polarization, 1550 nm wavelength [Answer in dB]:
Bend radius of 3 µm:




Bend radius of 5 µm:






Explanation
Can do it manually using mode overlap calculations, or using script.



Could not parse problem




Consider an interferometer with ideal lossless components (no waveguide loss, no additional loss in the splitter).
What is the maximum optical output power, if the input power is 1 mW?  [Answer in mW].





Explanation
Constructive interference with no loss in the circuit gives 100% transmission, or 1 mW output.



Could not parse problem




Consider a thermo-optic switch based on a balanced MZI. The switch consists of two Y branches connected with identical waveguides. One of the waveguides is covered with a metal heater, which is attached to two electrical probe pads. 



This Mach Zehnder Interferometer has an optical transfer function 
\[ \cfrac{I_o}{I_i} = \frac{1}{2} \left[ 1+  \cos{ (\beta_1 L_1 - \beta_2  L_2) } \right] \]
where \(I_i\) is the input light intensity, \(I_o\) is the output intensity, \(L_1\) and \(L_2\) are lengths of the two waveguides, and \(\beta_1\) and \(\beta_2\) are the waveguide propagation constants, and are defined as
\[ \beta_{1,2} = \cfrac{2 \pi \left( n + \frac{dn}{dt} \Delta T_{1,2} \right) } {\lambda} \]
where \(\Delta T_{1,2}\) represent the temperature increase above room temperature for each waveguide, and \(\lambda\) is the wavelength, 1550 nm.

Consider a thermal source that is applied to waveguide 1 (e.g., the metal heater covers one waveguide; neglect thermal cross-talk).  Estimate the required temperature change, \(\Delta T_1\), to change the switch from being ON (where there is 100% transmission) to being OFF (where there is 0% transmission). Assume an experimental value for \(\frac{dn}{dt} = 2 \times 10^{-4} / {^\circ}C\), and \(L_1 = L_2 =100 \mu m\).

  
What is the required temperature increase to change the switch from being ON to OFF?  [Answer in \(^\circ\)C].






Explanation
The switch changes from ON to OFF when there is a π phase change in the heated waveguide.  The phase shift due to propagation in waveguide is:
\[ \beta_1 L_1 = \cfrac{2 \pi \left( n + \frac{dn}{dt} \Delta T_{1} \right) } {\lambda} L_1 \]
The change of the phase due to the heater is:
\[ \Delta \beta_1 L_1 = \cfrac{2 \pi \frac{dn}{dt} \Delta T_{1}  } {\lambda} L_1 \]
We need to solve for \(\Delta T_1\) in \(\pi = \Delta \beta_1 L_1\):
\[ \Delta T_{1}  = \cfrac{ \lambda}{2 \frac{dn}{dt} L_1 } \]
\[ \Delta T_{1}  = \cfrac{1.55\times10^{-6}}{2 \cdot 2 \times 10^{-4} \cdot 100\times10^{-6} } = 38.75 ^ {\circ} C \]





Could not parse problem




Assume a waveguide has the following effective index values:
  2.5 at 1.5 µm 2.4 at 1.6 µm 
What is the waveguide group index at 1.55 µm? [answer accuracy +/- 0.001]






Explanation
ng = 2.45 - 1.55 * (-0.1)/0.1.



Could not parse problem




Assume an interferometer with the following properties:
  Wavelength of operation is 1.55 µmWaveguide's group index is 4.2Path length mismatch ∆L is 100 µm
What is the Free Spectral Range, in [answer in nm, accuracy +/- 0.01]?






Explanation
FSR = 1.55e-6^2 / 100e-6 / 4.2 * 1e9
Don't forget to convert from meters to nanometers.



Make sure your answer is correct to +/- 0.01 nm.
The answer is in units of nanometers.


Could not parse problem


You may use this MATLAB window as a calculator to help you answer the questions.
  



      %%    
      
      







        %%
   
        
      



Could not parse problem





  In this unit, we provide you with MATLAB code (download Phot1x_MZI_matlab.m) to simulate the optical transmission spectrum (or transfer function) of the Mach-Zehnder Interferometer.  You can use this code to experiment with the MZI behaviour, gain insight into how the spectrum changes as a function of \(L_2-L_1\), see how loss impacts the extinction ratio, and so on.  Also, be sure to modify the compact waveguide model parameters to match the waveguide you have modelled and are planning on using in your design.
  

You will need to make adjustments to the constants in the model.  Specifically, change the following:
    n1, n2, n3: the compact waveguide model coefficients. lambda0: the centre wavelength used for the waveguide model. lambda_min, lambda_max: the wavelength range over which you want to plot.  lambda_step: the wavelength step for the plot. Keep in mind that the Agilent/Keysight Technologies laser (81600B) has a wavelength resolution of 0.1 pm, however, we perform automated measurements typically with a 10 pm resolution.  alpha: the propagation loss of the waveguide. L1, L2: the lengths of the two waveguides in the interferometer. 
Note that all constants are in units of microns, unless noted.

          


      %%    
      
      



% MATLAB script to plot the MZI transfer function.
% by Lukas Chrostowski
% user must configure several variables below.
        
% specify the wavelength range of interest.
lambda_min = 1.5;  % Units [µm, microns]
lambda_max = 1.6;
lambda_step = 0.01e-3; % wavelength step [microns]
                       % Typical minimum step for a tunable laser is 1-10 pm.
lambda=lambda_min:lambda_step:lambda_max;


% Define the waveguide effective index compact model:
% - as a Taylor expansion around the central wavelength, lambda0
%  use a Matlab anonymous function 
lambda0 = 1.55; n1=2.4; n2=-1; n3=0;  % these are constants from the waveguide model.
neff = @(lambda) ...
		(n1 + n2.*(lambda-lambda0) + n3.*(lambda-lambda0).^2); 
        
% plot the effective index version wavelength, and check if this is as expected:
figure;
plot(lambda, neff(lambda),'LineWidth',3);

% Complex propagation constant for the waveguide
alpha = 1e-3;  % propagation loss [micron^-1]; constant
beta = @(lambda) ...
		(2*pi*neff(lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );


% Define the MZI transfer function
T_MZI = @(L1, L2, lambda) ...
        ( 0.25* abs(exp(-1i*beta(lambda)*L1)+exp(-1i*beta(lambda)*L2)).^2);

% Define the two waveguide lengths in the MZI
L1=100;  % Waveguide 1 length, Units [µm, microns]
L2=200;  % Waveguide 2 length, Units [µm, microns]

% plot the MZI transfer function, and check if this is as expected:
% plot in linear scale:
figure;
plot(lambda, T_MZI(L1, L2, lambda),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission');
axis tight
title ('MZI transfer function');

% plot in log (dB) scale:
figure;
T_MZI_dB = 10*log10(T_MZI(L1, L2, lambda));
plot(lambda, T_MZI_dB,'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI transfer function');
      



        %%
var0=[n1, n2, n3, alpha, L1, L2];
var1=[2.4, -1, 0, 1e-3, 100, 200];
assert(not(isequal(var0,var1)), 'Looks like you just ran the code without changing the parameters: n1, n2, n3, alpha, L1, L2.  These are parameters specific to your waveguide and need to be changed.');
        
      



Could not parse problem




Consider an MZI with a small path length difference, \(\Delta L\). In this case, the output power can be adjusted by varying \(\Delta L\). 



We can obtain an arbitrary splitting ratio.  We start with the Mach Zehnder Interferometer optical transfer function 
\[ \cfrac{I_o}{I_i} = \frac{1}{2} \left[ 1+  \cos{ (\beta \Delta L) } \right] \]
where \(I_i\) is the input light intensity, \(I_o\) is the output intensity, \(\Delta L\) is the path length difference between  the two waveguides, and \(\beta\) is the waveguide propagation constant, and is defined by
\[ \beta = \cfrac{2 \pi  n  } {\lambda} \]
where \(n\) is the waveguide effective index (wavelengthd dependant), and \(\lambda\) is the wavelength, say 1550 nm. 

    Given a desired output, \(\frac{I_o}{I_i}\), e.g., 0.1 for 10%, we can solve for \(\Delta L\).  
Note that there are an infinite number of solutions, however we want to use the shortest path difference possible, which will result in a broadband operation (without an FSR).  Only a very small length difference is required to obtain any percentage between 0% to 100% transmission.  For example, assuming that when the paths are equal, we obtain 100% transmission, then 0% transmission occurs for a path length difference that corresponds to a \(\pi\) phase shift:
\[ \beta L = \pi \]
For a waveguide effective index of 2.4, and a wavelength of 1550 nm, a \(\pi\) shift occurs for approximately 323 nm.
  
What is the required path length difference to obtain a 80% power output, at a wavelength of 1550 nm?  Assume the waveguide effective index is 2.4. [Answer in nm].






Explanation

  \[ 0.8 = \frac{1}{2} \left[ 1+  \cos{ (\beta \Delta L) } \right] \]
  \[ 1.6 -1 =   \cos{ (\cfrac{2 \pi \cdot 2.4  } {1550 nm} \Delta L) }  \]
  \[ \Delta L [nm] =     \frac{\cos^{-1}(0.6) 1550} {2 \pi \cdot 2.4} \]
  \[ \Delta L [nm] =    95.3 nm \]




Could not parse problem




Wavelength dependance of the splitting ratio
Simulate the transmission spectrum of the above 80% splitter MZI, using the transfer function in the previous unit.

Observe that the splitting ratio is 80% at 1550 nm, but varies by +/- 2% across the wavelength range.
  

You will need to make adjustments to the parameters in the model.  Specifically, change the following:
    n1, n2, n3: the compact waveguide model coefficients. lambda0: the centre wavelength used for the waveguide model. lambda_min, lambda_max: the wavelength range over which you want to plot.  lambda_step: the wavelength step for the plot.alpha: the propagation loss of the waveguide. L1, L2: the lengths of the two waveguides in the interferometer. 
Note that all constants are in units of microns, unless noted.

          
Scroll down below the graphs to see if your answer is correct.




      %%    
      
      



% MATLAB script to plot the MZI transfer function.
% by Lukas Chrostowski
% user must configure several variables below.
        
% specify the wavelength range of interest.
lambda_min = 1.5;  % Units [µm, microns]
lambda_max = 1.6;
lambda_step = 0.01e-3; % wavelength step [microns]
                       % Typical minimum step for a tunable laser is 1-10 pm.
lambda=lambda_min:lambda_step:lambda_max;


% Define the waveguide effective index compact model:
% - as a Taylor expansion around the central wavelength, lambda0
%  use a Matlab anonymous function 
lambda0 = 1.55; n1=2.4; n2=-1; n3=0;  % these are constants from the waveguide model.
neff = @(lambda) ...
		(n1 + n2.*(lambda-lambda0) + n3.*(lambda-lambda0).^2); 
        
% plot the effective index version wavelength, and check if this is as expected:
figure;
plot(lambda, neff(lambda),'LineWidth',3);

% Complex propagation constant for the waveguide
alpha = 1e-3;  % propagation loss [micron^-1]; constant
beta = @(lambda) ...
		(2*pi*neff(lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );


% Define the MZI transfer function
T_MZI = @(L1, L2, lambda) ...
        ( 0.25* abs(exp(-1i*beta(lambda)*L1)+exp(-1i*beta(lambda)*L2)).^2);

% Define the two waveguide lengths in the MZI
L1=100;  % Waveguide 1 length, Units [µm, microns]
L2=200;  % Waveguide 2 length, Units [µm, microns]

% plot the MZI transfer function, and check if this is as expected:
% plot in linear scale:
figure;
plot(lambda, T_MZI(L1, L2, lambda),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission');
axis tight
title ('MZI transfer function');

% plot in log (dB) scale:
figure;
T_MZI_dB = 10*log10(T_MZI(L1, L2, lambda));
plot(lambda, T_MZI_dB,'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI transfer function');
      



        %%
var0=[n1, n2, n3, alpha, L1, L2];
var1=[2.4, -1, 0, 1e-3, 100, 200];
assert(not(isequal(var0,var1)), 'Looks like you just ran the code without changing the parameters: n1, n2, n3, alpha, L1, L2.  These are parameters specific to your waveguide and need to be changed.');
assert(lt(alpha,3e-4), 'Your alpha value is too high.  Please consider less than 10 dB/cm propagation loss.  Note that if the waveguide loss, alpha, is too high, your splitting ratio will be lower than expected.');
dL_error = abs(abs(L2-L1)-95.3e-3);
assert(lt(dL_error,10e-3), 'Your L2-L1 value needs to be adjusted to obtain a 80% splitter. ');
        
      



Could not parse problem




An optical frequency of 193.1 THz corresponds to what wavelength? [Answer in nm, accuracy +/- 0.01].






Explanation
Wavelength = Speed of light / Frequency.
In INTERCONNECT, you can write in the "Script Prompt": ?c/193.1e12;
and obtain the answer 1.55252e-6



Could not parse problem




Consider an ideal Y-branch. What is the transmission from the input to one of the outputs, in dB? (what is a dB?) [Answer accuracy +/- 0.001].






Explanation
In INTERCONNECT, you can write in the "Script Prompt": ?10*log10(0.5); which equals -3.0103



The insertion loss is a positive number in dB.  The transmission for a passive component is always less than 0 dB (negative number).  
Transmission in dB = 10 x log10 (T), where T is the transmission in the linear scale.  In INTERCONNECT, you can type in the Script Prompt to calculate:  ?10*log10(T);
The ideal Y-Branch has a transmission, T = 0.5.


Could not parse problem




Answer this question by constructing the following circuit in Lumerical INTERCONNECT:
  Two grating couplers   Connect to a network analyzer.
Measure the best-case fibre-to-fibre insertion loss.
  
          Best-case insertion loss of two grating couplers (positive value, in dB, required accuracy +/- 0.1):





  For this question, please use the provided S-Parameter file for the grating coupler: S_TE1550_SubGC_neg31_oxide.txt; the one in the PDK is not exactly the same.

Loss is a positive number.


Could not parse problem




Build a Michelson Interferometer circuit as follows:


One 2x2 splitter (Broadband Directional Coupler): Design kits/ebeam_v1.2/ebeam_bdc_1550

Two strip waveguides, TE 1550 nm, to create the interferometer, and connected to the outputs of the 2x2 splitter: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide lengths: L1 = 215 µm, L2 = 15 µm.
    
A loop-back mirror.  A loop-back mirror consists of one 1x2 splitter (y-branch) with both outputs connected together with a waveguide so the light "reflects" back to the input. It consists of:
    A Y-Branch, TE 1550 nm: Design kits/ebeam_v1.2/ebeam_y_1550.  
    A strip waveguide, TE 1550 nm, connected to the two outputs of the y-branch: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide length is arbitrary, e.g., 10 µm.
    

An Optical Network Analyzer.  Properties: centre frequency = 1550 nm; frequency range = large enough so that you can see multiple peaks; Results view: turn on annotation for "gain" and "free spectral range".
    







What is the free spectral range (FSR) of the peak nearest 1550 nm. [Answer in nm, accuracy +/- 0.1]






Explanation
Here is the INTERCONNECT project for the solution.








Could not parse problem





The free spectral range (FSR) of the Michelson Interferometer is different from the Mach-Zehnder Interferometer.
    Why? 

In this math expression input problem, your text represents a
mathematical expression, and text is converted to a symbolic
expression that appears below the field. You can refer to 

Entering Mathematical and Scientific Expressions in the edX Guide for information about how to enter text into the field.


  Determine the expression for the FSR (in terms of wavelength) of the Michelson Interferometer based on the path length difference, \(\Delta = | L_2-L_1 | \) (write it as "Delta" below), the centre wavelength, \( \lambda \) (write it as "lambda"), and the waveguide group index, \( n_g \) (write it as "n_g"). 





FSR = "lambda^2/(2 * Delta * n_g)"


Verify your formula using the example circuit we simulted above. 
You can review the derivation of the Free Spectral Range for the Mach-Zehnder Interferometer (unit: Photonic Circuits > Interferometers > FSR of imbalanced MZI.
Here is a paper of a fabricated Michselson Interferometer
Watch the video on in the unit: Photonic Circuits > Interferometers > Overview of interferometer types, applications, where the Michselson Interferometer is discussed at time 9:10.


Could not parse problem




Build a Michelson-like Interferometer circuit as follows (I'm sorry, I don't know what this is called):


Two 2x2 splitters (Broadband Directional Coupler): Design kits/ebeam_v1.2/ebeam_bdc_1550

Two strip waveguides, TE 1550 nm, in the interferometer section: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide lengths: L1 = 115 µm, L2 = 15 µm.
    
A strip waveguide, TE 1550 nm, for the loop-back mirror: Design kits/ebeam_v1.2/ebeam_wg_strip_1550.  Waveguide length is arbitrary. (Loop-back mirror consists of one splitter with both outputs connected together with a waveguide so the light "reflects" back to the input.)
    
An Optical Network Analyzer.  Properties: centre frequency = 1550 nm; frequency range = large enough so that you can see multiple peaks; Results view: turn on annotation for "gain" and "free spectral range".
    







What is the free spectral range (FSR) of the peak nearest 1550 nm. [Answer in nm, accuracy +/- 0.1]






Explanation
Here is the INTERCONNECT project for the solution.








Could not parse problem




Design an Adjustable Splitter
In this question, we wish to design a 20-80% splitter, where 20% comes out of opt_2 and 80% comes out of opt_1.  Make sure your design uses the shortest possible \(\Delta L\). Adjust the length of one of the waveguides (the longest one, wgs_2).





What is the \(\Delta L\) for the adjustable splitter configured to be 20-80% at 1550 nm?  [Answer in nm] 






Explanation
Adjust the 2nd waveguide path length.  Increasing it slightly from 20.06 microns will decrease the power in opt_1, thus making it closer to a 50-50 splitter; decreasing the length slightly will bring it closer to a 99-1% splitter. Find the value where you obtain a 80-20 splitter.  This turns out to be 20.091 microns. 
Here is the INTERCONNECT project for the solution: mzi_splitter.icp 



Could not parse problem




In this question, we wish to compare the flatness of the filters (1 stage versus 2 stages).  For a fair comparison, we use the same types of waveguides and the same 50-50 splitters in both designs.  We compare the flatness by determining the 1 dB bandwidth of the single-stage MZI, versus the 2-stage FIR filter.  Note: the 1-dB bandwidth is defined as the bandwidth as measured 1 dB below the peak transmission.  



  What is the ratio of the 2-stage vs. 1-stage bandwidth, where the ratio is defined as \(\frac{BW_{2-stage}}{BW_{1-stage}}\)?







Explanation

We analyze this near 1550 nm.  For the N=2 filter, the peak transmission is -0.17 dB.
At -1.17 dB, the wavelengths are 1543.68 nm and 1547.77 nm, hence the bandwidth is 4.09 nm.


For the single stage filter, the peak tranmission is -0.056 dB, and the wavelengths are 1546.91 nm and 1550.23 nm, hence the bandwidth is 3.32 nm.  


  Thus, the ratio is 4.09 / 3.32 = 1.23  


Download the INTERCONNECT project file: FIR filter.icp



Could not parse problem




For your Mach-Zehnder Inteferometer designs, enter the parameter variations for the path length difference (∆L).  When you press "check", the system will give you some feedback - we are performing a simple sanity-check to make sure that your designs are reasonable.  
Keep in mind that the smallest laser step size is 1 pm, and the typical measurement bandwidth limited by the grating couplers is 50 nm.
 
Enter your design parameters separated by commas, in units of [µm]




def make_a_list(name_string):
    return name_string.split(',')

def count_names(name_list):
    return len(name_list)

def num(s):
    try:
        return float(s)
    except ValueError:
        return 0
      
def how_many_oli(expect, ans):
    names = make_a_list(ans)
    how_many = len(set(names))
    message_hint = ''
    check = True
    for e in names:
        e=e.strip('"')
        e=e.strip("'")
        e=e.strip()
        e=e.lower()
        dL=num(e)
        who_is = e
        if dL &lt; 22:
            if dL == 0:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" (0) micron, you may still have a path length mismatch due to fabrication variations.  \n "
                check = False
            else:
                message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, you will not see oscillations within the measurement span; longer path length mismatch required.  \n"
                check = False
        if dL &gt; 57200:
            message_hint = message_hint+"For dL = "+str(who_is).title()+" micron, we will not be able to resolve the oscillations since they the FSR is too small and the loss differential too high; shorter path length mismatch required.  \n"
            check = False
    if how_many &lt; 1:
        return { 'ok': False, 'msg': 'None at all?'}
    if how_many &lt; 5:
        return { 'ok': check, 'msg': 'Only '+str(how_many)+" variations?  "+message_hint}
    if how_many == 5:
        return { 'ok': check, 'msg': message_hint }
    if how_many &gt; 5:
        return { 'ok': check, 'msg': message_hint }
    return False

  





Explanation
Assuming you want to see oscillations versus wavelength, the minimum path length difference is limited by span.  For 50 nm, 2 oscillations, is FSR = 25 nm.  Assuming ng=4.2, the min dL is ~ 23 µm.

            The maximum path length difference, to be able to resolve oscillations with 10 points per oscillation: 1 point is 1 pm, 10 is 10 pm.  So FSR is 10 pm, hence max ∆L=57 mm.  Assuming 3 dB/cm, this would yield a 17 dB loss difference.  The oscillation fringes would not be visible.  For such a large path-length mismatch, lower loss waveguides would be required (e.g., 3 µm wide multi-mode waveguide).
          



Could not parse problem


Use the Matlab code below to download and plot the measurement data.  The data is for two TE grating couplers, connected with a short waveguide (about 150 microns).  
  

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
% or same file from aws:
url = 'https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/ZiheGao_MZI2_271_Scan1.mat'

PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');
     
      



%%        
      



Could not parse problem


Use the Matlab code below to download, plot, and analyze the measurement data for YBranches for the TM polarization.  The data is for two TM grating couplers, and several YBranches.  The GDS file for the layout used for this experiment is EBeam_LukasChrostowski_TM_YBranches.gds.
  
Note that you can download and run this Matlab file, lukasc_YBranch_TM.m.  If you have the Statistics Toolbox, the program will generate an error estimation.  In the following graph, the shaded region corresponds to the 95% confidence interval.
    

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the insertion loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess insertion loss of about 10 dB.  For example,
% if the DUT is estimated to have an insertion loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the insertion loss, we plot the measured insertion loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the insertion loss for one DUT.

% For the case of the YBranch, the circuit consists of two YBranches facing
% each other. This creates an interferometer.  Assuming the waveguides are
% perfectly matched, the interferometer insertion loss will be only due to
% the excess loss of the YBranch.

% The following layout implements test structures for the YBranch described
% in paper http://dx.doi.org/10.1364/OE.21.001310
% EBeam_LukasChrostowski_TM_YBranches.gds
% https://www.dropbox.com/s/vs0hvrggbn5f9ip/EBeam_LukasChrostowski_TM_YBranches.gds?dl=1

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'YBranch (TM)';
% At what wavelength do you want to find out the insertion loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'lukasc_YBranch3_1262.mat', ...
    'lukasc_YBranch9_1261.mat', ...
    'lukasc_YBranch15_1260.mat', ...
    'lukasc_YBranch21_1263.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 3, 9, 15, 21 ] * 2;
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/louspt78v28x1dw/lukasc_YBranch3_1262.mat', ...
        'https://www.dropbox.com/s/cqyc233aqm8b2rc/lukasc_YBranch9_1261.mat', ...
        'https://www.dropbox.com/s/xrvtv54hmvjpfh4/lukasc_YBranch15_1260.mat', ...
        'https://www.dropbox.com/s/eiypug7qkx1p1ry/lukasc_YBranch21_1263.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength, nm');
ylabel ('Insertion Loss, dB');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the insertion loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the insertion loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Number of YBranches');
ylabel ('Insertion Loss (dB)');
title (['Cut-back method, ' deviceName ' insertion loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/YBranch'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' insertion loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/YBranch'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/YBranch'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' insertion loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/YBranch'])
end



% wavelength dependance of the DUT insertion loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Insertion loss, 95% Confidence Interval', ...
        'Insertion loss, from polyfit', ...
        'Insertion loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Insertion loss, from polyfit', ...
        'Insertion loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' insertion loss, wavelength dependance'] )
ylabel ('Insertion Loss (dB)');
xlabel ('Wavelength, nm');
set(gca,'FontSize',FONTSIZE)
     
      



%%        
      



Could not parse problem


Given the space allocation for this course, what is the largest number of fibre grating couplers that can be connected to a single circuit? [Answer: an integer]



Explanation
The total height of 4 couplers is 127 µm x 3 = 381, plus some extra height for the coupler itself (about 20 µm). This is why the 405 µm height was chosen.




Please take Design For Test into account; namely, we are using a 1D fibre array with the fibres in the vertical direction.
The "pitch" of the grating couplers is defined as the centre-to-centre distance.


Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The fibre grating couplers must be vertically spaced exactly 127 µm apart, and horizontally aligned.  In this layout, the bottom grating coupler is offset hence light will not be efficiently coupled into the bottom fibre. 



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
The highlighted waveguide has sharp 90º angles; these should be replaced with smooth 90º bends to provide low optical loss and low back-reflections.  



Could not parse problem


    In the layout below, identify the design error.
  





Explanation
This layout is missing a label for the automated measurements, e.g., "opt_in_TE_1550_device_LukasChrostowski_MZI3".  



Could not parse problem

You can enter your license code here, to help you remember. When you click "Check", it will come back incorrect; don't worry. It's just there to for your convenience.





Explanation



Could not parse problem

Consider an EBL system with a minimum writing grid of 1 nm, and a field size of 1 mm.   
How many bits are required in the Digital to Analog converter (DAC) to achieve the necessary resolution? [answer is an integer]





Explanation
The distance is twice that of the 500 µm example, hence one extra bit, thus 20.



Could not parse problem

Consider a single chip (25 x 25 mm), with four quarters each, with each quarter having a design area of 8.8 mm x 8.8 mm.  
Consider a single participant design size of 605 x 410 µm.  
How many participant designs can fit on a single chip? [required answer accuracy +/- 100]






Explanation
in MATLAB: answer = floor(8800/410)*floor(8800/605)*4 = 1176.
Spread the word about this course, since we have a lot more room for designers.



Our chip is at about 10% capacity.  Spread the word about this course, since we have a lot more room for designers.


Could not parse problem

Consider a single design area of 8.8 mm x 8.8 mm.  
Consider an extremely dense silicon photonic waveguide-based circuit, consisting of 500 nm wide waveguides, on a 3 µm centre-to-centre pitch.  Assume these waveguides are covering the entire design, as a series of parallel lines.  The layout is to be fabricated with a 6 nm shot pitch on the JEOL EBL system at UW, and written with a dose of 2800 uC/cm^2, with a current of 8 nA. 
How long would it take to write this chip? [answer in Hours, required answer accuracy +/- 1.0]






Explanation
in MATLAB:
Dose = 2800/1e4^2 % convert µC/cm^2 to µC/µm^2
A_written=(8800*.5/3)*(8800) % in µm^2
Ibeam = 8000/1e6 % convert pA to µA
t_seconds = Dose * A_written / Ibeam
t_minutes = t_seconds / 60
t_hours = t_minutes / 60
 ANSWER 12.5 hours.  



The gap between waveguides is not 3 µm.
You can use Matlab to calculate using the formula t_seconds = Dose * A_written / Ibeam.  Don't forget to convert the units.
You can use the provided online EBEAM calculator.
The machine can be left running overnight.


Could not parse problem




Consider an MZI that was designed to be balanced, with both path lengths being 100 µm.  Assume a lossless interferometer, such that if it was perfectly manufactured, it would have 100% transmission at 1550 nm.
Consider a chip where due to on-chip manufacturing variations, the effective index of both waveguides increases simultaneously by 1%.
What is the transmission of this MZI? [answer in percentage, an integer without the % symbol. required answer accuracy of +/-1%].






Explanation
no change in the transmission



No math required for this question.  This about it intuitively.
The ideal design has 100% transmission due to constructive interference.  What happens if the same phase shift is added to both arms of the interferometer?


Could not parse problem




Consider an MZI that was designed to be balanced, with both path lengths being 100 µm.  Assume a lossless interferometer, such that if it was perfectly manufactured, it would have 100% transmission at 1550 nm.
Consider a chip where due to on-chip manufacturing variations, the effective index of the two waveguides differs by 0.00775.
What is the transmission of this MZI? [answer in percentage, an integer without the % symbol. required answer accuracy of +/-1%].






Explanation
dneff=0.00775
L=100e-6
dbetaL = 2*3.1415*dneff*L/1550e-9 = 3.1415
Pi phase shift results in desctructive interference, or 0 transmission.



You'll probably need to go back to the interferometer equations (Photonic Circuits | Modelling - MATLAB | MZI Transfer Function).
The ideal design has 100% transmission due to constructive interference.  What happens if there is a relative phase shift between the waveguides?


Could not parse problem




Perform the corner analysis on the 500x220 nm waveguide, for TE, at 1550 nm.  Determine the range of values possible for the group index, ng.



Assume that the wafer thickness varies between 215.3 and 223.1 nm
Assume that the waveguide width varies between 470 and 510 nm


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Explanation
No explanation yet.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the 9 cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength).
  


Could not parse problem

Consider an MZI with a ∆L = 100 µm, with 500x220 nm waveguides, operating in the TE polarization, at 1550 nm.  Using a corner analysis, determine the range of values possible for the Free Spectral Range.
What is the minimum value for the FSR? [answer in units of nm, within an accuracy of 0.04] 




What is the maximum value for the FSR? [answer in units of nm, within an accuracy of 0.04]






Explanation
.




I found it easiest to answer these questions by performing calculations in MODE for the group index, saving this data for the corner cases, then using MATLAB to calculate the min/max ng at 1550 (interpolating to 1550 nm wavelength), then using the formula for FSR for the given ng values.
  


Could not parse problem

  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 



      %%    
      
      







        %%
      



Could not parse problem


Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      



% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');


     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data (ZiheGao_MZI2_271_Scan1.mat). 
  
Choose the polynomial order (POLY_ORDER, or the value the polyfit function) to a value such at the polynomial follows the envelope of the MZI + Grating Couplers spectrum. Namely, the resulting polynomial should approximate the grating coupler insertion loss, and the flattened spectrum should look like the ideal MZI spectrum with the peaks at approximately 0 dB.
  



      %%    
      
      



% Enter the order of the polynomial for the curve fitting:
POLY_ORDER = 1;
        
% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
PORT=1; % Which Fibre array port is the output connected to?

a=websave('a.mat',url); % get data from Dropbox
load('a.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Plot the raw data:
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (raw)');

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, POLY_ORDER);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 
figure;
plot (lambda*1e6, amplitude); hold all;
plot (lambda*1e6, amplitude_baseline, 'LineWidth',4);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with polymial fit)');

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');
     
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem




 What value for the polynomial order (POLY_ORDER) is appropriate for correcting the baseline? 


1 You need a higher order polynomial; try increasing POLY_ORDER.
2 Too few.
3 Ok.
4 Ok.
5+ Likely the polynomial has too high an order. Be very careful not to "overfit" the data.



Adjust POLY_ORDER above, and re-run the code.  You should see a polynomial that looks similar to a grating coupler response (as in the first plot at the top).


Could not parse problem




In this section, you can calibrate a measured spectrum using a "loopback" structure.
Objective:



remove the baseline shape of the grating couplers



Method:



curve-fit the spectrum of two grating couplers (or an MZI with ∆L=0) using a low-order polynomial
Restrict to ~10 dB from peak to avoid using data with a large error
Subtract this polynomial from subsequent data



You can download and run the Matlab code on your own computer. 

Use the Matlab code below to download and plot the measurement data.
  



      %%    
      
      




% Read data files from experiments
% Enter the Dropbox URLs here.  Make sure the URL has a =1 at the end:
%  Loopback structure:
	url_loopback = 'https://www.dropbox.com/s/w915qfix9kwlwv7/ZiheGao_MZI1_272_Scan1.mat?dl=1';
%  MZI:
	url_mzi = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
% Calibrate the MZI data using the loopback structure
% Plot


PORT=1; % Which Fibre array port is the output connected to?
FONTSIZE=20;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Loopback data:
a=websave('loopback.mat',url_loopback); % get data from Dropbox
load('loopback.mat');
% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda*1e6, amplitude);
title ('Calibration loopback'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)
hold all;

% Fit the data with a polynomial
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 5);
amplitude_LOOPBACK=polyval(p,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, amplitude_LOOPBACK);
% find wavelength range with usable data, in the loopback
loopback_IL = max(amplitude);
new_lambda_i=find(amplitude>loopback_IL-10);
lambda=lambda(new_lambda_i);
lambda_min = min(lambda);
lambda_max = max(lambda);
amplitude=amplitude(new_lambda_i);
% refit the loopback
LOOPBACK=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_LOOPBACK=polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
plot (lambda*1e6, [amplitude_LOOPBACK],'r-','Linewidth',5);
axis tight;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data:
a=websave('mzi.mat',url_mzi); % get data from Dropbox
load('mzi.mat');
lambda1=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);
figure;
plot (lambda1*1e6, amplitude);
title ('MZI (raw data)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MZI data - calibrated
%
% data only within the bandwidth of interest.
lambda=lambda_min:min(diff(lambda1)):lambda_max;
amplitude=interp1(lambda1, amplitude, lambda,'linear');
amplitude(find(amplitude==-inf))=-50;
% calibrate data
amplitude_cal=amplitude-polyval(LOOPBACK,(lambda-mean(lambda))*1e6);
figure;
plot (lambda*1e6, amplitude_cal);
title ('MZI (calibrated with loopback)'); 
xlabel ('Wavelength [\mum]','FontSize',FONTSIZE)
ylabel ('Insertion Loss [dB]','FontSize',FONTSIZE)


    
      



        %%
	url_mzi0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url_mzi0, url_mzi)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

You will need to make adjustments to the initial parameters for the fitting function.  Specifically, change the following line:
  


   nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
    

 Check your answer when you think you have a good fit.  
  
Please note that this code fits the response using the MZI transfer function. This function includes the path length difference, ∆L. This must match the design, in order to have meaningful results. 



      %%    
      
      




% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);
figure;
plot (lambda*1e6, amplitude_corrected);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected)');

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
lambda0 = mean(lambda)*1e6;		
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.

% initial function for fitting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
nx_init = [2.38, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];
figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');

% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      

nx_init = [2.4, -1, 0];   %%%%%%%%%%%% CHANGE THE FIRST PARAMETER
      

        %%
%url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
%assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  
Note that two data file examples are provided. Note that the ∆L path length difference must be correctly set.



      %%    
      
      



% Lukas Chrostowski, curve fitting the MZI using findpeaks, 2015/08/14

% Enter the Dropbox URL here.  Make sure it has a =1 at the end:

% TE
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

% TM:
%url = 'https://www.dropbox.com/s/onjwrarapf6dumv/ADCL_1_1153_Scan1_L2-L1%3D100um.mat?dl=1';
%dL = 100;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
if not(exist('lambda_min'))
	lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
end
if not(exist('lambda_max'))
	lambda_max = max(lambda);   %  if the data on the edges is noisy
end
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find peaks, extract FSR and ng, and neff
% as initial parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% smooth (0.1% moving average filter)
windowSize = floor(1e-3*length(lambda)); b = (1/windowSize)*ones(1,windowSize);
amplitude_smooth=filter(b,1,amplitude);
% FIND PEAKS
[pks,x_values,w,p]=findpeaks(-amplitude_smooth, lambda, 'minPeakProminence',4,'Annotate','extents');

% plot spectrum with peaks
figure;
plot (x_values*1e6, interp1(lambda, amplitude, x_values,'pchip'), 'ro','MarkerSize',10); 
hold all;
plot (lambda*1e6, amplitude_smooth);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (with peaks)');

% Calculate and plot ng data points from FSR
lambda_ng = (x_values(1:end-1)+x_values(2:end))/2;
FSR=(x_values(2:end)-x_values(1:end-1));
ng = abs(lambda_ng.^2/1/(dL*1e-6)./FSR);
% find average ng from all reasonable ng values:
indexes = find(gt(ng,3)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
indexes = find(lt(ng,5)); ng=ng(indexes); lambda_ng = lambda_ng(indexes); FSR = FSR(indexes);
ng_av = mean(ng);
if eq(length(ng),0)
  disp ('No group index values found.  Terminating script.');
  return
end
disp (['(estimate) Group index: ' num2str(ng_av)])

% plot FSR
figure;
plot (lambda_ng*1e6, FSR*1e9, '-o','LineWidth',1,'MarkerSize',7 );
xlabel ('Wavelength [\mum]')
ylabel ('Free Spectral Range [nm]')
xlim([min(lambda), max(lambda)]*1e6);
title ('Free Spectral Range, from Experimental data');

% plot ng
figure
plot (lambda_ng*1e6, ng, '-o','LineWidth',1,'MarkerSize',7 )
xlabel ('Wavelength [\mum]')
ylabel ('Group Index')
xlim([min(lambda), max(lambda)]*1e6);
title ('Waveguide Group Index, from Experimental data');


% find starting point for curve fitting MZI, using the ng data
% Part 1 - n1
% lambda0 is in microns.
lambda0 = x_values(floor(length(x_values)/2)) * 1e6;
n1_initial=2.4;
modeNumber = n1_initial * dL / lambda0 - 0.5;
n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
% Part 1 - n2 from ng_av
n2 = (n1-ng_av)/lambda0;
% Part 3 - n3 from slope of ng vs. lambda, to get the dispersion
f_line = @(x,xdata)x(2)*xdata+x(1);
[xfit,resnorm]  = lsqcurvefit(f_line,[ng_av 0],lambda_ng*1e6,ng);
r=corrcoef(ng,f_line(xfit, lambda_ng*1e6));
r2_ng=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2_ng)] )
hold all;
plot (lambda_ng*1e6, f_line(xfit, lambda_ng*1e6),'LineWidth',3)
n3 = -xfit(2)/2/lambda0;
Dispersion0 = -(lambda0*1e-6) / 299792458 * 2* (n3*1e12) * 1e12 /1e9 /1e-3;     	
disp (['(estimate from ng slope) Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
if lt(r2_ng,0.01)   % only use the result if the fit is good
  n3 = 0;
end

% Initial conditions for fitting:
nx_init = [n1 n2 n3];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];

	
% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'-','LineWidth',2);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2;
disp (['Goodness of fit, r^2 value: ' num2str(r2) ])

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  disp (['Waveguide parameters at wavelength [um]: ' num2str(lambda0)])
  ng0 = xfit(1) - lambda0*xfit(2);
  disp (['Group index: ' num2str(ng0)])

  % Dispersion:
  c=299792458;	
  Dispersion0 = -(lambda0*1e-6) / c * 2* (xfit(3)*1e12);  % [s/m^2]
  % [ps/nm/km]: 
  Dispersion0 = Dispersion0 * 1e12 /1e9 /1e-3;
  disp (['Dispersion [ps/nm/km]: ' num2str(Dispersion0) ])
  
  
end
      



        %%
		
if exist('r2')
  assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
  if ge(r2,0.8)
    disp('Fitting seems good.');
  end
else
  assert(0, 'Fitting not performed.')
end        

url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');

      



Could not parse problem





Use the Matlab code below to download and plot the measurement data, and curve fit it to the MZI transfer function.
    

 Check your answer when you think you have a good fit.  
  
Note that two data file examples are provided. Note that the ∆L path length difference must be correctly set.



      %%    
      
      





% Enter the Dropbox URL here.  Make sure it has a =1 at the end:
url = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
dL = 111.915;  % [micron] Path length difference in the MZI

%url = 'https://www.dropbox.com/s/zojmleq3gu77dsw/ZiheGao_MZI17_265_Scan1.mat?dl=1';
%dL = 219.366;

PORT=1; % Which Fibre array port is the output connected to?

a=websave('mzi.mat',url); % get data from Dropbox
load('mzi.mat');

% Data is stored in variable "scanResults".
% There are two columns - wavelength (1), and amplitude (2)
lambda=scanResults(1,PORT).Data(:,1)/1e9;
amplitude=scanResults(1,PORT).Data(:,2);

% Curve fit data to a polynomial for baseline correction
p=polyfit((lambda-mean(lambda))*1e6, amplitude, 4);
amplitude_baseline=polyval(p,(lambda-mean(lambda))*1e6); 

% Perform baseline correction to flatten the spectrum
% Use the curve polynomial, and subtract from original data
amplitude_corrected = amplitude - amplitude_baseline;
amplitude_corrected = amplitude_corrected + max(amplitude_baseline) - max(amplitude);

% data only within the wavelength range of interest.
lambda_min = min(lambda);	% Can limit the analysis to a range of wavelengths
lambda_max = max(lambda);   %  if the data on the edges is noisy
lambda_max = 1.57e-6;
lambda1=lambda_min:min(diff(lambda)):lambda_max;
amplitude=interp1(lambda, amplitude_corrected, lambda1,'linear');
lambda=lambda1;
amplitude(find(amplitude==-inf))=-50;  % check if there are -infinity data points

% plot baseline corrected spectrum
figure;
plot (lambda*1e6, amplitude);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('Experimental data (baseline corrected, wavelength range)');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Find ng from autocorrelation-based frequency estimation of spectrum
% auto-correction
[r,lags]=xcorr(amplitude); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
figure
plot(lags,r);
% estimate the frequency
d=diff(r);
start = find(gt(d,0)); start=start(1);
[peak_m, peak_i]=max(r(start:end));
peak_i=peak_i+start;  % location of the 1st peak in the autocorrelation
hold on;
plot(peak_i,0,'s','MarkerSize',20);
title ('Autocorrelation of spectrum')
xlabel('lag, sample number');

fsr = peak_i * mean(diff(lambda))
ng_av = mean(lambda)^2/(dL*1e-6)/fsr


% find starting point for curve fitting, using the ng value
% lambda0 is in microns.
lambda0 = mean(lambda) * 1e6;
n1=2.4;
%modeNumber = n1_initial * dL / lambda0 - 0.5;
%n1 = (2*floor(modeNumber)+1)*lambda0/2/dL;
n2 = (n1-ng_av)/lambda0;
nx_init = [n1 n2 0];
alpha_init = 1e-3;  % propagation loss [micron^-1]
x0=[nx_init, alpha_init, 0];


% Define the MZI transfer function
% - as a Taylor expansion around the central wavelength
% - Use units of [microns] – keeps the variables closer to 1.
% - These make the curve fitting easier.
% use Matlab anonymous functions
% effective index:
neff = @(nx, lambda) ...
		(nx(1) + nx(2).*(lambda-lambda0) + nx(3).*(lambda-lambda0).^2); 
% neff([2.4, -1, 0], 1.56)  % test it.
% alpha = 1e-3;  % propagation loss [micron^-1]
% complex propagation constant
beta = @(nx, alpha, lambda) ...
		(2*pi*neff(nx, lambda)./lambda - 1i*alpha/2*ones(1,length(lambda)) );
% beta([2.4, -1, 0], 1e-3, [1.56, 1.57]) % test it.
% MZI transfer function
T_MZI = @(X, lambda) ...
        (10*log10( 0.25* abs(1+exp(-1i*beta(X(1:3), X(4), lambda)*dL)).^2) +X(5) );
% T_MZI([2.4, -1, 0, 1e-3], [1.56, 1.57]) % test it.


figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters)');


% Autocorrelation again, to find the shift between the fit function and experimental data
[r,lags]=xcorr(amplitude, T_MZI(x0, lambda*1e6)); 
r=r(ge(lags,0));
lags=lags(ge(lags,0));
[peak_m, peak_i]=max(r);
lambda_offset = peak_i(1) * mean(diff(lambda));
n_shift = lambda_offset*lambda0/fsr/dL;
x0(1)=x0(1)+n_shift;

figure;
plot (lambda*1e6, amplitude);
hold all;
plot (lambda0, -40,'s','MarkerSize',20);
plot(lambda*1e6, T_MZI(x0, lambda*1e6),'--','LineWidth',3);
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (initial parameters, with shift)');


% Curve fit:  
[xfit,resnorm] = lsqcurvefit(T_MZI,x0,lambda*1e6,amplitude);
xfit
r=corrcoef(amplitude,T_MZI(xfit, lambda*1e6));
r2=r(1,2).^2

figure;
plot (lambda*1e6, amplitude);
hold all;
plot(lambda*1e6, T_MZI(xfit, lambda*1e6),'LineWidth',3); 
xlabel ('Wavelength [\mum]');
ylabel ('Transmission [dB]');
axis tight
title ('MZI model (fit parameters)');

% Check if the fit is good.  If so, find ng
if (ge(r2,0.8))
  % plot ng curve
  figure;
  neff_fit = neff(xfit(1:3),lambda*1e6);
  dndlambda=diff(neff_fit)./diff(lambda); dndlambda=[dndlambda, dndlambda(end)];
  ng=(neff_fit - lambda .* dndlambda);
  plot(lambda*1e6, ng, 'LineWidth',4);
  xlabel ('Wavelength [\mum]');
  ylabel ('Group index, n_g');
  axis tight
  title ('Group index (from MZI fit)');
    
  % waveguide parameters at lambda0
  ng0 = xfit(1) - lambda0*xfit(2)
end
      



        %%
url0 = 'https://www.dropbox.com/s/1rvjfef4jqybc12/ZiheGao_MZI2_271_Scan1.mat?dl=1';
assert(not(strcmp(url0, url)), 'Looks like you just ran the code without changing the data file.  Try plotting a different data file.');
assert(ge(r2,0.8), 'The goodness-of-fit is low.  The R^2 value should be greater than 0.8.  Adjust the initial conditions until the fit quality is higher.')
        
      



Could not parse problem






      %%    
      
      







        %%
   
        
      



Could not parse problem

Example code for waveguide propagation loss analysis
The follow code includes example measurement data from a previous run. The script analyzes the dB/cm propagation loss.
Cut-back method, Spiral waveguide (TM) Loss, at 1550 nm is = 6.6 dB/cm 
Test structure for spiral waveguides, TM polarization

Use the Matlab code below to download, plot, and analyze the measurement data for waveguide propagation loss for the TM polarization.  The data is for two TM grating couplers, and spirals of length 0, 0.5, 1.0, 3.0 cm.  The GDS file for the layout used for this experiment is EBeam_lukasc_WGLoss_TM.gds.
  
Note that you can download and run this Matlab file, lukasc_spiralWG.m.  If you have the Statistics Toolbox, the program will generate an error estimation.  In the following graph, the shaded region corresponds to the 95% confidence interval.




Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the Loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess Loss of about 10 dB.  For example,
% if the DUT is estimated to have an Loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the Loss, we plot the measured Loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the Loss for one DUT.

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'Spiral waveguide (TM)';
% At what wavelength do you want to find out the Loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'LukasC_SpiralWG0kTM_1293.mat', ...
    'LukasC_SpiralWG5kTM_1296.mat', ...
    'LukasC_SpiralWG10kTM_1294.mat', ...
    'LukasC_SpiralWG30kTM_1295.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 0, 0.5, 1.0, 3.0 ];
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/anlo8zmydrji1f8/LukasC_SpiralWG0kTM_1293.mat', ...
        'https://www.dropbox.com/s/yvdfgl8qoq3d0fz/LukasC_SpiralWG5kTM_1296.mat', ...
        'https://www.dropbox.com/s/rossgslht5r5cq7/LukasC_SpiralWG10kTM_1294.mat', ...
        'https://www.dropbox.com/s/vj4uf6u59h9vt60/LukasC_SpiralWG30kTM_1295.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength (nm)');
ylabel ('Optical Power (dBm)');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the Loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the Loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Waveguide length (cm)');
ylabel ('Loss (dB/cm)');
title (['Cut-back method, ' deviceName ' Loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    a=annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    set(a,'FontSize',FONTSIZE);
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/cm'])
end



% wavelength dependance of the DUT Loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Loss, 95% Confidence Interval', ...
        'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' Loss, wavelength dependance'] )
ylabel ('Loss (dB/cm)');
xlabel ('Wavelength (nm)');
set(gca,'FontSize',FONTSIZE)
     
           
      



        %%
   
        
      



Could not parse problem

Cut-back method, Spiral waveguide (TE) Loss, at 1550 nm is = 11 dB/cm 
Test structure for spiral waveguides, TE polarization

Use the Matlab code below to download, plot, and analyze the measurement data for waveguide propagation loss for the TE polarization.  The data is for two TM grating couplers, and spirals of length 0, 0.5, 1.0, 3.0 cm.  The GDS file for the layout used for this experiment is EBeam_lukasc_WGLoss_TE.gds.
  

Note: this is an ungraded Matlab window.  "Check" will give you a correct answer as long as there are no errors.   



      %%    
      
      



% This script analyzes experimental data to determine the Loss
% of a device under test (DUT), e.g., YBranch, using the cut-back method.
% The layout is several (e.g., 4) circuits each consisting of N devices in
% series, where N ranges from a small number (e.g., 0) to a large number.  The
% large number is chosen as a trade-off between the layout size and a
% value that gives an excess Loss of about 10 dB.  For example,
% if the DUT is estimated to have an Loss of 0.3 dB, we would
% choose the largest value of N to be 10 dB / 0.24 dB = 42.

% To find the Loss, we plot the measured Loss versus
% the number of DUTs in the circuit.  Then we perform a linear regression,
% and the slope tells us the Loss for one DUT.

% calculate error confidence intervals?
% check if regress function is present. This is part of the statistics toolbox.
Error_Intervals = exist('regress'); 

FONTSIZE = 13;  % font size for the figures;

% Identify the name of the Device Under Test.
deviceName = 'Spiral waveguide (TE)';
% At what wavelength do you want to find out the Loss of the DUT
lambda0 = 1.55e-6;

% matrix of measurement data files, and # of components in each
files = { ...
    'LukasC_SpiralWG0kTE_1297.mat', ...
    'LukasC_SpiralWG5kTE_1300.mat', ...
    'LukasC_SpiralWG10kTE_1298.mat', ...
    'LukasC_SpiralWG30kTE_1299.mat' ...
    };
% number of DUTs in each circuit:
Num = [ 0, 0.5, 1.0, 3.0 ];
PORT=2;  % fibre measurement configuration; detector number.

% Load data from Dropbox:
if ~exist(files{1})
    disp 'Loading files from Dropbox'
    url = { ...
        'https://www.dropbox.com/s/1v5wzon5nexggn6/LukasC_SpiralWG0kTE_1297.mat', ...
        'https://www.dropbox.com/s/7r8svd1ukjae8ox/LukasC_SpiralWG5kTE_1300.mat', ...
        'https://www.dropbox.com/s/kfsv1yeghue0i38/LukasC_SpiralWG10kTE_1298.mat', ...
        'https://www.dropbox.com/s/5o66l3xd7rnxtgq/LukasC_SpiralWG30kTE_1299.mat' ...
        };
    for i=1:length(files)
        a=websave(files{i},url{i},'dl', '1'); % get data from Dropbox
    end
else
    disp 'Loading files from local disk'
end

% Plot all the raw data, and also curve-fit each to a polynomial
figure;
LegendText={};
for i=1:length(files)
    load(files{i});                             % Load the data
    lambda = scandata.wavelength';              % wavelength
    amplitude(:,i) = scandata.power(:,PORT);    % detector data
    plot (lambda*1e6, amplitude(:,i)); hold all;
    
    % Curve-fit data to a polynomial
    p=polyfit((lambda-mean(lambda))*1e6, amplitude(:,i), 4);
    amplitude_poly(:,i)=polyval(p,(lambda-mean(lambda))*1e6);
    plot (lambda*1e6, amplitude_poly(:,i), 'LineWidth',2);
    
    % legend entries
    LegendText(2*i-1)=cellstr(['raw data: ' strrep(files{i},'_','\_')]);
    LegendText(2*i)=cellstr(['fit data: ' strrep(files{i},'_','\_')]);
end
title (['Optical spectra for the ' deviceName ' test structures']);
xlabel ('Wavelength (nm)');
ylabel ('Optical Power (dBm)');
legend (LegendText,'Location','South');
axis tight;
set(gca,'FontSize',FONTSIZE)

% least-squares linear regression of the Loss values vs. number
% of DUTs, at lambda0, to find the slope, A(2), and y-intercept, A(1)
% The slope, A(2), is the Loss for one DUT
[c index] = min(abs(lambda-lambda0));  % find lambda0 in lambda vector.
A = [ ones(length(Num),1) Num'] \ amplitude_poly(index,:)';
figure;
plot (Num, amplitude(index,:),'x'); hold all;
plot (Num, amplitude_poly(index,:),'o', 'MarkerSize',7);
plot (Num, A(1) + Num*A(2),'LineWidth',3)
legend ('raw data at lambda0', 'polyfit of raw data', ...
    'linear regression of polyfit');
xlabel ('Waveguide length (cm)');
ylabel ('Loss (dB/cm)');
title (['Cut-back method, ' deviceName ' Loss, at ' num2str(lambda0*1e9) ' nm'] )
set(gca,'FontSize',FONTSIZE)

% Calculate the slope error, +/- dB, with a 95% confidence interval
if Error_Intervals
    [b, bint] = regress(amplitude_poly(index,:)', [Num' ones(numel(Num),1)]);
    SlopeError95CI = diff(bint (1,:))/2;
    InterceptError95CI = diff(bint (2,:))/2;
    a=annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results, with 90% confidence intervals: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' +/- ' ...
        num2str(InterceptError95CI,'%.02g') ' dB'] ...
        });
    set(a,'FontSize',FONTSIZE);
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' +/- ' ...
        num2str(SlopeError95CI,'%.01g') ' dB/cm'])
else
    disp 'Skipping fitting error estimations'
    annotation('textbox', [.2 .2 .1 .1], 'String', ...
        {['Fit results: '], ...
        ['slope is = ',num2str(A(2),'%0.2g') ' dB/cm'], ...
        ['intercept is = ',num2str(A(1),'%0.3g') ' dB'] ...
        });
    disp (['Cut-back method, ' deviceName ' Loss, at ' ...
        num2str(lambda0*1e9) ' nm is = ',num2str(-A(2),'%0.2g') ' dB/cm'])
end



% wavelength dependance of the DUT Loss
% perform a linear regression at each wavelength, using the raw data
C = [ ones(length(Num),1) Num'] \ amplitude';

figure
if Error_Intervals
    % perform a linear regression at each wavelength, using the polyfit data
    slope=[]; slope_int=[];
    lambda_downsampled = lambda(1:100:end);
    amplitude_poly_downsampled = amplitude_poly (1:100:end,:);
    for i=1:length(lambda_downsampled)
        [b, bint] = regress(amplitude_poly_downsampled(i,:)', ...
            [Num' ones(numel(Num),1)]);
        slope(i)=b(1);
        slope_int(i,:)=bint(1,:);
    end
    % Plot the 95% confidence interval as a shaded region. It is based on the
    % polyfit fit results
    X=[lambda_downsampled; flip(lambda_downsampled)]*1e6;
    Y=[slope_int(:,1); flip(slope_int(:,2))];
    fill(X,-Y,[0.7 1 1],'LineStyle','none');  hold all;
    
    % plot the linear regression results from the polyfit data
    plot(lambda_downsampled*1e6, -slope', 'b', 'LineWidth',3);
    
    % plot the linear regression results from the raw data
    plot(lambda*1e6, -[C(2,:)']); hold all;
    legend ( 'Loss, 95% Confidence Interval', ...
        'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
else
    % perform a linear regression at each wavelength, using the polyfit data
    D = [ ones(length(Num),1) Num'] \ amplitude_poly';
    plot(lambda*1e6, -[D(2,:)' C(2,:)']); hold all;
    legend ( 'Loss, from polyfit', ...
        'Loss, from Raw data', ...
        'Location','Best' )
end
axis tight; yl=ylim;
ylim ([0, yl(2)]);
title (['Cut-back method, ' deviceName ...
    ' Loss, wavelength dependance'] )
ylabel ('Loss (dB/cm)');
xlabel ('Wavelength (nm)');
set(gca,'FontSize',FONTSIZE)
     
                 
      



        %%
   
        
      



Could not parse problem



Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 


Could not parse problem


  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 




      %%    
      
      







        %%
      



Could not parse problem




Unbalanced MZI Interferometer, TM polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TM_1550_device_LukasChrostowski_MZI_TM_oneside". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.03]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.03]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.03]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.03]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TM_oneside.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.02]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100; within an accuracy of +/- 2 %]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/lukasc_TETM_simVSexp.zip  




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
Follow the Convergence Tests section, in Waveguide Modelling - Lumerical MODE
The TM layout used a bend radius of 10 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of lambda_min=1.54e-6; lambda_max=1.56e-6.
     


Could not parse problem


  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 




      %%    
      
      







        %%
      



Could not parse problem




Unbalanced MZI Interferometer, TE polarization
Theoretical Analysis:
  
The device for this question is "opt_in_TE_1550_device_LukasChrostowski_MZI_TE_oneside2". 
As-designed analysis:
  


What is the numerically simulated theoretical value for the group index of this waveguide? [answer within an accuracy of +/- 0.02]




What is the simulated free spectral range? [answer in nm, within an accuracy of +/- 0.02]






Corner analysis:
  Perform a Corner Analysis, and identify the min/max values


What is the minimum value for the group index? [answer within an accuracy of +/- 0.02]




What is the maximum value for the group index? [answer within an accuracy of +/- 0.02]






Measurement Data Analysis:  
Download the following experimental data (LukasChrostowski_MZI_TE_oneside2.mat, PORT 2).


What is the measured free spectral range? [answer in nm, within an accuracy of +/- 0.02]




What is the extracted group index? [answer within an accuracy of +/- 0.04]






Experiment vs. Model:  


What is the % discrepancy for the group index? [answer as a number between 0 and 100 percent; within an accuracy of +/- 2 (%)]




Does the experimental data lie within the range determined by the Corner Analysis? [Yes = 1; No = 0]








Explanation
Solution: https://s3.amazonaws.com/edx-course-phot1x-chrostowski/Phot1x/lukasc_TETM_simVSexp.zip 




I found it easiest to answer these questions by performing calculations in MODE for the group index at one wavelength (1550), for the as-designed case, and for the 4 corner cases, then calculate the min/max ng and FSR.
  

You can use either material model for silicon: a) materials.lsf, or b) fit the Palik data between 1.2 and 1.8 microns.  The difference between the two results is about ∆ng = 0.01.
  
The TE layout used a bend radius of 5 µm.

You can find the length of the waveguide by finding it's area and dividing by the width.  Select the polygon, and use the Tools | Compute total area of selected shape, which can be added to KLayout as described in http://klayout.de/forum/comments.php?DiscussionID=25 
For the experimental data curve fitting, I found I obtained good results when zooming in to the data in a range of          lambda_min=1.543e-6; lambda_max=1.557e-6.
     


Could not parse problem


  Note: This MATLAB window doesn't check your answer.   It is here for your convenience only. 




      %%    
      
      







        %%
      



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
Query done.
Processed: 7.9 MB

Retrieving results...
  Got page: 1; 30% done. Elapsed 9.7 s.
  Got page: 2; 59% done. Elapsed 15.4 s.
  Got page: 3; 89% done. Elapsed 20.29 s.
  Got page: 4; 100% done. Elapsed 22.33 s.
Got 130779 rows.

Total time taken 25.76 s.
Finished at 2017-06-30 20:59:09.
Saved to ./../data/ReligionX_1T2017/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
Query done.
Processed: 156.5 MB

Retrieving results...
Got 0 rows.

Total time taken 9.36 s.
Finished at 2017-06-30 20:59:21.
Saved to ./../data/ReligionX_1T2017/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 12.55 s. Waiting...
Query done.
Processed: 145.7 MB

Retrieving results...
  Got page: 1; 16% done. Elapsed 20.99 s.
  Got page: 2; 33% done. Elapsed 26.95 s.
  Got page: 3; 49% done. Elapsed 31.35 s.
  Got page: 4; 65% done. Elapsed 36.23 s.
  Got page: 5; 82% done. Elapsed 45.31 s.
  Got page: 6; 98% done. Elapsed 49.27 s.
  Got page: 7; 100% done. Elapsed 50.11 s.
Got 143027 rows.

Total time taken 55.95 s.
Finished at 2017-06-30 21:00:19.
Saved to ./../data/ReligionX_1T2017/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 6.3 KB

Retrieving results...
Got 71 rows.

Total time taken 0.84 s.
Finished at 2017-06-30 21:00:23.
Saved to ./../data/ReligionX_1T2017/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 789.9 KB

Retrieving results...
Got 1087 rows.

Total time taken 1.61 s.
Finished at 2017-06-30 21:00:26.
Saved to ./../data/ReligionX_1T2017/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.0 MB

Retrieving results...
Got 5097 rows.

Total time taken 4.72 s.
Finished at 2017-06-30 21:00:32.
Saved to ./../data/ReligionX_1T2017/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 298.3 KB

Retrieving results...
Got 31 rows.

Total time taken 1.14 s.
Finished at 2017-06-30 21:00:35.
Saved to ./../data/ReligionX_1T2017/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 506.1 KB

Retrieving results...
Got 1440 rows.

Total time taken 1.62 s.
Finished at 2017-06-30 21:00:38.
Saved to ./../data/ReligionX_1T2017/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 75.9 KB

Retrieving results...
Got 768 rows.

Total time taken 1.28 s.
Finished at 2017-06-30 21:00:40.
Saved to ./../data/ReligionX_1T2017/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 93.8 MB

Retrieving results...
  Got page: 1; 29% done. Elapsed 11.85 s.
  Got page: 2; 58% done. Elapsed 17.15 s.
  Got page: 3; 88% done. Elapsed 23.02 s.
  Got page: 4; 100% done. Elapsed 25.61 s.
Got 199538 rows.

Total time taken 28.99 s.
Finished at 2017-06-30 21:01:11.
Saved to ./../data/ReligionX_1T2017/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 256.3 KB

Retrieving results...
Got 768 rows.

Total time taken 1.26 s.
Finished at 2017-06-30 21:01:15.
Saved to ./../data/ReligionX_1T2017/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 9.7 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 7.54 s.
Got 39 rows.

Total time taken 7.55 s.
Finished at 2017-06-30 21:01:24.
Saved to ./../data/ReligionX_1T2017/external_link_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.6 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 11.16 s.
Got 11213 rows.

Total time taken 11.42 s.
Finished at 2017-06-30 21:01:37.
Saved to ./../data/ReligionX_1T2017/page_dirt.csv
Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 10.6 MB

Retrieving results...
  Got page: 1; 24% done. Elapsed 12.11 s.
  Got page: 2; 48% done. Elapsed 17.62 s.
  Got page: 3; 71% done. Elapsed 23.84 s.
  Got page: 4; 95% done. Elapsed 29.21 s.
  Got page: 5; 100% done. Elapsed 30.62 s.
Got 163409 rows.

Total time taken 35.66 s.
Finished at 2017-06-30 21:03:41.
Saved to ./../data/SPD1x_1T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 13.69 s. Waiting...
Query done.
Processed: 2.2 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 23.62 s.
Got 1405 rows.

Total time taken 23.65 s.
Finished at 2017-06-30 21:04:08.
Saved to ./../data/SPD1x_1T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 14.88 s. Waiting...
  Elapsed 25.29 s. Waiting...
  Elapsed 35.73 s. Waiting...
  Elapsed 46.14 s. Waiting...
  Elapsed 56.26 s. Waiting...
  Elapsed 66.37 s. Waiting...
  Elapsed 76.48 s. Waiting...
  Elapsed 86.58 s. Waiting...
  Elapsed 96.66 s. Waiting...
Query done.
Processed: 2.0 GB

Retrieving results...
  Got page: 1; 1% done. Elapsed 105.28 s.
  Got page: 2; 2% done. Elapsed 110.98 s.
  Got page: 3; 3% done. Elapsed 115.83 s.
  Got page: 4; 4% done. Elapsed 120.9 s.
  Got page: 5; 4% done. Elapsed 125.4 s.
  Got page: 6; 5% done. Elapsed 130.48 s.
  Got page: 7; 6% done. Elapsed 135.35 s.
  Got page: 8; 7% done. Elapsed 141.88 s.
  Got page: 9; 8% done. Elapsed 146.53 s.
  Got page: 10; 9% done. Elapsed 151.43 s.
  Got page: 11; 10% done. Elapsed 156.31 s.
  Got page: 12; 11% done. Elapsed 163.06 s.
  Got page: 13; 12% done. Elapsed 168.6 s.
  Got page: 14; 12% done. Elapsed 173.64 s.
  Got page: 15; 13% done. Elapsed 178.62 s.
  Got page: 16; 14% done. Elapsed 185.18 s.
  Got page: 17; 15% done. Elapsed 192.23 s.
  Got page: 18; 16% done. Elapsed 197.5 s.
  Got page: 19; 17% done. Elapsed 201.9 s.
  Got page: 20; 18% done. Elapsed 206.15 s.
  Got page: 21; 19% done. Elapsed 212.35 s.
  Got page: 22; 19% done. Elapsed 217.64 s.
  Got page: 23; 20% done. Elapsed 221.97 s.
  Got page: 24; 21% done. Elapsed 227.05 s.
  Got page: 25; 22% done. Elapsed 231.41 s.
  Got page: 26; 23% done. Elapsed 235.86 s.
  Got page: 27; 24% done. Elapsed 243.31 s.
  Got page: 28; 25% done. Elapsed 248.02 s.
  Got page: 29; 26% done. Elapsed 252.81 s.
  Got page: 30; 27% done. Elapsed 259.5 s.
  Got page: 31; 27% done. Elapsed 266.31 s.
  Got page: 32; 28% done. Elapsed 274.44 s.
  Got page: 33; 29% done. Elapsed 281.52 s.
Requesting query... ok.
Query running...
Query done.
Processed: 10.4 KB

Retrieving results...
Got 150 rows.

Total time taken 0.82 s.
Finished at 2017-06-30 21:09:44.
Saved to ./../data/SPD1x_1T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.5 MB

Retrieving results...
Got 7792 rows.

Total time taken 6.38 s.
Finished at 2017-06-30 21:09:52.
Saved to ./../data/SPD1x_1T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.4 MB

Retrieving results...
Got 2332 rows.

Total time taken 2.87 s.
Finished at 2017-06-30 21:09:56.
Saved to ./../data/SPD1x_1T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.5 MB

Retrieving results...
Got 1181 rows.

Total time taken 2.52 s.
Finished at 2017-06-30 21:10:00.
Saved to ./../data/SPD1x_1T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 4.1 MB

Retrieving results...
Got 32896 rows.

Total time taken 6.24 s.
Finished at 2017-06-30 21:10:07.
Saved to ./../data/SPD1x_1T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 129.3 KB

Retrieving results...
Got 1409 rows.

Total time taken 0.87 s.
Finished at 2017-06-30 21:10:10.
Saved to ./../data/SPD1x_1T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 113.9 MB

Retrieving results...
  Got page: 1; 24% done. Elapsed 12.85 s.
  Got page: 2; 47% done. Elapsed 20.53 s.
  Got page: 3; 71% done. Elapsed 29.02 s.
  Got page: 4; 95% done. Elapsed 35.56 s.
  Got page: 5; 100% done. Elapsed 37.39 s.
Got 246537 rows.

Total time taken 40.84 s.
Finished at 2017-06-30 21:10:52.
Saved to ./../data/SPD1x_1T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 449.2 KB

Retrieving results...
Got 1000 rows.

Total time taken 1.4 s.
Finished at 2017-06-30 21:10:57.
Saved to ./../data/SPD1x_1T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 91.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 10.04 s.
Got 874 rows.

Total time taken 10.06 s.
Finished at 2017-06-30 21:11:09.
Saved to ./../data/SPD1x_1T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.95 s. Waiting...
  Elapsed 23.35 s. Waiting...
Query done.
Processed: 161.7 MB

Retrieving results...
  Got page: 1; 6% done. Elapsed 35.66 s.
  Got page: 2; 12% done. Elapsed 42.29 s.
  Got page: 3; 17% done. Elapsed 48.88 s.
  Got page: 4; 23% done. Elapsed 54.93 s.
  Got page: 5; 29% done. Elapsed 60.74 s.
  Got page: 6; 35% done. Elapsed 68.15 s.
  Got page: 7; 40% done. Elapsed 75.08 s.
  Got page: 8; 46% done. Elapsed 80.72 s.
  Got page: 9; 52% done. Elapsed 87.53 s.
  Got page: 10; 58% done. Elapsed 94.44 s.
  Got page: 11; 64% done. Elapsed 100.26 s.
  Got page: 12; 69% done. Elapsed 107.16 s.
  Got page: 13; 75% done. Elapsed 112.68 s.
  Got page: 14; 81% done. Elapsed 118.62 s.
  Got page: 15; 87% done. Elapsed 125.62 s.
  Got page: 16; 92% done. Elapsed 131.95 s.
  Got page: 17; 98% done. Elapsed 139.84 s.
  Got page: 18; 100% done. Elapsed 143.21 s.
Got 943836 rows.

Total time taken 166.68 s.
Finished at 2017-06-30 21:13:57.
Saved to ./../data/SPD1x_1T2016/page_dirt.csv
Could not parse problem

If you haven't already done so, go download the pythag-starter.rkt file from the week 1 page. Use only the language you've learned so far to answer the question.
Assume that the two short sides of a right triangle have length 3 and 4. What is the length of the long side? Recall the Pythagorean Theorem tells us that:

Write a BSL expression that produces the value of ? for this triangle where the other two sides have lengths 3 and 4.
Once you have completed the problem, paste your expression here.

(sqrt(+(sqr 3)(sqr 4)))
(sqrt (+ (sqr 3)(sqr 4)))
(sqrt (+(sqr 3)(sqr 4)))
(sqrt(+ (sqr 3) (sqr 4)))
(sqrt(+ (sqr 3)(sqr 4)))
(sqrt(+(sqr 3) (sqr 4)))




Explanation
If your answer was incorrect and you don't understand why, watch the continuation of the video.



Could not parse problem

What is the next step in the following evaluation? 
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
   Step 1: (/ 12 (+ (- 7 4) 3)) 
   Step 2:  __________________





Explanation
The second operand to / is an expression, so it must be evaluated. And the first operand to + is an expression, so it must be evaluated. All of the operands to - are values, so - can be called with 7 and 4 as arguments. This replaces the - call expression with 3.



Could not parse problem


What is the next step in the following evaluation? 
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
Step 1: (/ 12 (+ (- 7 4) 3)) 
Step 2: (/ 12 (+ 3 3)) 
Step 3:  ______________





Explanation:
All of the operands to + have been evaluated, so + can be called with the arguments 3 and 3.




Could not parse problem


What is the next step in the following evaluation?
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
Step 1: (/ 12 (+ (- 7 4) 3)) 
Step 2: (/ 12 (+ 3 3)) 
Step 3: (/ 12 6) 
Step 4: _________





Explanation:
All of the operands to / have been evaluated, so the primitive can be called with the arguments 12 and 6.




Could not parse problem

Consider the following program:

(define FOO (* 2 3))
(define BAR (* FOO 2))

(* FOO BAR)
What result is produced when the program is run? (The best way to figure this out would be to work through the evaluation rules you know one at a time until you have the final result.)




Could not parse problem



    Click the mouse to move the green dot on top of one example of an operator.





Explanation
Operators are primitives built into BSL that consume primitive data and produce  results. Examples include +, *, -, / and many more.  
      		




Could not parse problem



	Identify one example of a function name.





Explanation
	Recall:





Could not parse problem



	Click the mouse to move the green dot on top of one example of a function body.





Explanation
	Recall:





Could not parse problem



	Click the mouse to move the green dot on top of one example of a parameter.





Explanation
	Recall:





Could not parse problem

Problem: Design a function that pluralizes a given word. (Pluralize means to convert the word
          to its plural form.) For simplicity you may assume that just adding s is enough to pluralize a word.
  	

    What is an appropriate signature for this function? Leave out the two semi-colons and the space, but
    otherwise be sure to get the capitalization and all other aspects of the signature correct.
  





Explanation
The most appropriate way to represent a word is with a string, so the primitive type the function should consume and produce is String. This means the signature line, including the semi-colons, is:
;; String -> String
 Note: type names should use upper camel case.



Could not parse problem

A "pointing on a picture" problem (also called an "image mapped input" problem) presents an image, and asks you to click on an area in the image. To help ensure accuracy, make sure you click near the middle of what the question asks for.
In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
The signature shows the function as producing String. But this doesn't match the purpose, the check-expects or the stub, all of which have the function producing Number.



Could not parse problem

In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
In the second check-expect, the operand in the call to empty-string? is 0. But 0 is a number, the signature says the function must consume String, and all the other parts of the design have the function consuming String. 



Could not parse problem

In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
The false answer in the if expression produces true. But true is a boolean, which does not match the signature, purpose or any of the check-expects. 



Could not parse problem

The issue of how many tests a function needs is something we will discuss in more and more detail as the course moves forwards.  
_____________________________________________________________________________
Take a moment to think about how many tests are necessary for the function in the previous video?





Explanation
Continue watching part 2 of the video for an explanation of why each test is necessary. 



Could not parse problem








Build a cond expression equivalent to the above nested if expressions by dragging each of the parts below into the proper place in the cond.
















correct_answer = [{
    'draggables': ['2', '5', '3', '4', '1', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5', 't6'],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        


Could not parse problem

Match each of the following problem statement fragments to the corresponding form of data definition.
 1 - "percentage score"
      2 - "TV volume level 1-30, or mute"
      3 - "primary colors: red, green, blue"
      4 - "height of a rocket"












correct_answer = {'1d':'tb', '2d':'td', '3d':'tc', '4d':'ta'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        


ExplanationGiven the problem statement fragments, the types comments should look something like this:

;; RocketHeight is Natural

;; PercentageScore is Number[0, 100]

;; PrimaryColor is one of:
;; - "red"
;; - "green"
;; - "blue"

;; TelevisionVolume is one of:
;; - Number[1, 30]    
;; - "mute"



Could not parse problem


What is the minimum number of data examples needed to illustrate this data definition? [Enter a number]





Explanation
We need at least 1 example that represents Natural[1, 100], and 1 that represents "standby".




Could not parse problem

How many function examples (tests) would a function need if it consumes Reservation and produces true if the reservation is the last one? [Enter a number]





Explanation
We need at least 3 tests: 2 for the interval case, because the result is true if the reservation is 100, and false otherwise, and we need at least 1 test for the second case, "standby".



Could not parse problem

















correct_answer = correct_answer = [
    {
      'draggables': ['1'],
      'targets': ['t2', 't5'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['2'],
      'targets': ['t1', 't6'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['4', '3'],
      'targets': ['t3', 't4'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem



Drag the Cat data onto it's corresponding image in the world program.











correct_answer = {'1': 't2', '2': 't3', '3': 't1'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Move the green dot to the set of images which most accurately reflects what the domain analysis should look like for the countdown program. Assume the images were drawn from left to right to represent different clock ticks in the program.






Explanation
 The bottom left is the best domain analysis because it shows the numbers in the center of the screen, decreasing until reaching zero.



Could not parse problem



Again consider the countdown program. Categorize each piece of information as either constant or changing.














correct_answer = {
        '1': 'constant', '2': 'constant', '3': 'constant', '4': 'constant', '5': 'change', '6': 'constant', '7': 'constant', '8': 'constant'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem



Drag the Countdown data to complete each check-expect for our handle-mouse function. Note, each value can be used more than once, and you don't need to use every one.












correct_answer = [{
      'draggables': ['1'],
      'targets': ['t1', 't3', 't4'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['3'],
      'targets': ['t2'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Here is the signature and purpose for the function that produces true if the list contains a negative number.
;; ListOfNumber -> Boolean
;; produce true if a lon contains a negative number
What is the result of the following tests?
(check-expect (contains-negative? (cons 1 empty)) _____)





Explanation
The list has only 1 element and it is positive.



Could not parse problem

(check-expect (contains-negative? (cons 1 (cons -1.5 empty))) _____)





Explanation
The second element of the list is negative.



Could not parse problem

(check-expect (contains-negative? empty) _____)





Explanation
The list is empty, so it contains no negative numbers.



Could not parse problem

Is this self-referential type comment well-formed?
;; ListOfNumber is one of:
;; - (cons Number ListOfNumber)





Explanation
Although it has a self-referential case, it does not have a base case, so it is not well formed.



Could not parse problem

Is this self-referential type comment well-formed?
;; NonEmptyListOfNumber is one of:
;; - (cons Number empty)
;; - (cons Number NonEmptyListOfNumber)





Explanation
This is a type comment for a non-empty list - a list that at it's shortest just has a single element. It is well-formed because it has both a base case which has no self-reference: (cons Number empty), and a self-referential case: (cons Number NonEmptyListOfNumber).



Could not parse problem

Choose the part of the template that results from each highlighted part of the Type Comment.






Explanation
ListOfNumber has two cases, so we need a cond expression. empty is the first case, and it is atomic distinct, so the answer clause is (...).



Could not parse problem







Explanation
(cons Number ListOfNumber) is compound, so we separate it into two parts, the first being (first lon).



Could not parse problem







Explanation
The second part of the compound is (rest lon) which is ListOfNumber. This is a self-reference in the type comment, so (rest lon) is wrapped in a call to fn-for-lon to form a natural recursion.



Could not parse problem


Drag the template rules to create the correct template rules for foo. Only use as many template rules as are necessary.











correct_answer = [{
    'draggables': ['compound', 'atomic', 'reference' ],
    'targets': ['t1', 't2', 't3' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Use the options below to create the correct template rules for ListOfConcert.
You can use up to six template rules, but you do not need to use all the space.
Note, if you drap the options out of the bar at the bottom, they become bigger and you will be able to read the template rules.
















correct_answer = [{
    'draggables': ['2', '3', '4', '5', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

The factorial of a natural number n is n*n-1*n-2*...1. So factorial of 3 is 3*2*1*1. Let's design a function called fact to compute the factorial.

factorial of 0 is 1
factorial of n is n*factorial(n-1)

Here is the signature and purpose for fact:
;; Natural -> Natural
;; compute n * n-1 * n-2 * ... * 1
What is the result of each check-expect?
(check-expect (fact 0) ____ )



(check-expect (fact 3) ____ )





Explanation
0 factorial is 1, so (fact 0) should produce 1. 
3 factorial is 3*2*1 whihc is 6.



Could not parse problem

In the two boxes below, complete the two cases in the types comment for the data definition for a list of images. 

;; ListOfImage is one of:




















Explanation
The correct type comment for a list of images is 
;; ListOfImage is one of:
;; - empty
;; - (cons Image ListOfImage)



Could not parse problem

After we run the program, we notice that one test in arrange-strings is still failing. Are we done working on layout-strings?






Explanation
We didn't complete the sorting part of this program, so that test for arrange-strings should fail. But since the tests for layout-strings are passing we are ready to move on to completing the rest of the program. 



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
First we look at the root, the node 3:c. It does not have the key 4. We go down the right subtree since the key we are looking for is greater than 3. Then we look at the node 4:d, and it has key 4 and we are done. So we looked at 2 nodes, 3:c and 4:d.



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
To find key 4, we need to look at nodes 1:a, 2:b, 3:c, and then 4:d. So 4 nodes in total.



Could not parse problem



Suppose instead of producing the value of a node with a given key, we would like to 
    produce the path that we took when we searched for that key. So the function that we 
    would like to design should produce a list of "L" or "R", and should end with either
    "Fail" or "Succeed", depending on whether we found the key.
  

    We're almost done designing this function. We have the signature, purpose, tests,
    and we've even started filling in the template.
Drag the expressions below, into the appropriate box on the partially filled in template.












        
correct_answer = {'1': 'second', '2': 'third', '3': 'fourth', '4': 'first'}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


    You're still not comfortable with the idea that trees are layed out from above to below in computer 
    science, instead you would prefer to have your trees layed out left to right. So the root is at the 
    left, it's children are to it's right etc. For example, with your new version the result of 
    evaluating:
(render-bst (make-node 100 "C"
                       (make-node  50  "L" false false)
                       (make-node 150 "CL" false false)))
would look something like:




Again, that would look a lot better with a little extra whitespace in it, but please ignore that for now.
By remembering the role that combination positions play in templates, you realize that the new function definition should be very close to the old function definition. Edit the current render function definition so that it has the new left-to-right behavior by dragging one or more function names from the scrollbar below, onto the  function definition where you want to replace one function name with another.









        
correct_answer = {'2': [[130, 75], 45], '4': [[200, 95], 50]}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference.










correct_answer = [
      {
      'draggables': ['R'], 
      'targets': ['Rt'], 
      'rule':'exact'
      },
      {
      'draggables': ['SR'], 
      'targets': ['SRt'], 
      'rule':'exact'
      },
      {
      'draggables': ['MR', 'MR'],
      'targets': ['MRt1', 'MRt2'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference. (The arrows are coloured to help distinguish between them).














correct_answer = [
      {
      'draggables': ['SR', 'SR'],
      'targets': ['SRt1', 'SRt2'],
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['MR', 'MR', 'MR', 'MR', 'MR', 'MR'],
      'targets': ['MRt1', 'MRt2', 'MRt3', 'MRt4', 'MRt5', 'MRt6'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Below are the templates for the above type comments. Select the correct number for each arrow to show the correspondence between the templates and the type comments










correct_answer = [
      {
      'draggables': ['1'], 
      'targets': ['t1'], 
      'rule':'exact'
      },
      {
      'draggables': ['2', '2'], 
      'targets': ['t2', 't4'], 
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['3'],
      'targets': ['t3'],
      'rule':'exact'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

 How many self-references are there?




ExplanationListOfPerson has a self-reference in it.
 


 
 How many references are there?





Explanation
 All remaining references are part of a mutual reference cycle, so there are 0. 


 How many mutual-references are there?




ExplanationListOfPerson has a reference to Person and vice versa.
 



Could not parse problem


Complete the function design for names-under-20--person and names-under-20--lop.







correct_answer = [{
      'draggables': ['cons', 'append'],
      'targets': ['t1', 't2'],
      'rule':'exact'
      }]
        
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Correctly label each arrow on the template with one of R, SR, MR, NH, NR, or NMR.













correct_answer = [{
    'draggables': ['NH', 'NR'],
    'targets': ['t1', 't4'],
    'rule':'exact'
},
{   'draggables': ['NMR', 'NMR'],
    'targets': ['t2', 't3'],
    'rule':'unordered_equal+number'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Design the function has-path? that consumes a BinaryTree and a Path. The function should produce true if following the path through the tree leads to a node. If the path leads to false or runs into false before reaching the end of the path, the function should produce false.

;; BinaryTree Path -> Boolean
;; prodcue true if following p through bt leads to a node; false otherwise

Lets design a cross product of type comments table to help us write tests for this function. Note Nat, Str and BT stand for Natural, String and BinaryTree.

   p        bt  | false | (make-node Nat Str BT BT)
----------------|-------|----------------------------
empty           |       |            
----------------|-------|----------------------------
(cons "L" Path) |       |            
----------------|-------|----------------------------
(cons "R" Path) |       |            

Recall:

(define BT1 (make-node 1 "a" false false))
(define BT4 (make-node 4 "d"
                       (make-node 2 "b")
                                  (make-node 1 "a" false false)
                                  (make-node 3 "c" false false))
                       (make-node 5 "e" false false))) 
We need at least one check-expect for every cell in the table.
What is the value of each check-expcet?
(check-expect (has-path? false empty) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path ends at false. 




Could not parse problem

(check-expect (has-path? false (list "L")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? false (list "R")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? BT1 empty) _____ )




Explanationhas-path should produce true if the path leads to a node. 




Could not parse problem

(check-expect (has-path? BT4 (list "R")) _____ )





Explanation
Following the given path leads to a node. 



Could not parse problem

(check-expect (has-path? BT4 (list "L" "L" "R")) _____ )





Explanation
Following the given path leads to false. 



Could not parse problem

Look at the table again:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|-------|--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|-------|--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))

How many cases can we reduce it to?





Explanation
The table can be reduced to these four cases:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|       |--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|       |--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))




Could not parse problem

In the practice problem find-person-starter.rkt we asked you to use local to improve your functions performance as the tree gets larger. Would the following be a correct use of local for that purpose?

(define (find--lop n lop)
  (local [(define try (find--person n (first lop)))]
    (cond [(empty? lop) false]
          [else
           (if (not (false? (find--person n (first lop))))
               (find--person n (first lop))
               (find--lop n (rest lop)))])))





Explanation
In this case the local has not been moved to surround the nearest expression that encloses all occurrences of the repeated computation. That would be around the if. Instead it moved outside of the cond answer the if appeared in. Try running it with this definition and see what happens. Step it carefully to be sure you understand why. 



Could not parse problem

Would this version that doesn't use local work?

(define try (find--person n (first lop)))

(define (find--lop n lop)
  (cond [(empty? lop) false]
        [else
         (if (not (false? try))
             try
             (find--lop n (rest lop)))]))





Explanation
The paramaters n and lop are not defined outside of find--lop, so this will not work either.



Could not parse problem


Use the pieces below.













correct_answer = [
    {
      'draggables': ['3'],
      'targets': ['t2', 't3'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['7'],
      'targets': ['t1'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


    An image mapped input problem presents an image for the student.
    Input is given by the location of mouse clicks on the image.
    Correctness of input can be evaluated based on expected dimensions of a rectangle.
  
Which animal shown below is a kitten?





Explanation
The animal on the right is a kitten. The animal on the left is a puppy, not a kitten.



Could not parse problem

In adding the accumulator paramater, we have missed a spot where it should be added. Click to move the green dot to the location of the missing accumulator paramater.





Explanation
We need to add acc at all of the ...s, as well as adding an extra paramater to every call of number-list.



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Opening and ending tag mismatch: vertical line 563 and problem
Opening and ending tag mismatch: sequential line 389 and vertical
Opening and ending tag mismatch: chapter line 365 and sequential
Opening and ending tag mismatch: course line 1 and chapter
Extra content at the end of the document
[1] "XML is malformed — using htmlInternalTreeParse."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 8.8 MB

Retrieving results...
  Got page: 1; 28% done. Elapsed 12.15 s.
  Got page: 2; 56% done. Elapsed 17.51 s.
  Got page: 3; 85% done. Elapsed 22.5 s.
  Got page: 4; 100% done. Elapsed 25.51 s.
Got 137756 rows.

Total time taken 29.59 s.
Finished at 2017-06-30 21:22:15.
Saved to ./../data/SPD1x_2T2015/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 14.42 s. Waiting...
  Elapsed 24.82 s. Waiting...
Query done.
Processed: 1.8 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 26.64 s.
Got 3205 rows.

Total time taken 26.72 s.
Finished at 2017-06-30 21:22:45.
Saved to ./../data/SPD1x_2T2015/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 14.18 s. Waiting...
  Elapsed 24.68 s. Waiting...
  Elapsed 35.19 s. Waiting...
  Elapsed 45.6 s. Waiting...
  Elapsed 56.06 s. Waiting...
  Elapsed 66.31 s. Waiting...
Query done.
Processed: 1.7 GB

Retrieving results...
  Got page: 1; 1% done. Elapsed 77.84 s.
  Got page: 2; 2% done. Elapsed 83.91 s.
  Got page: 3; 3% done. Elapsed 88.59 s.
  Got page: 4; 4% done. Elapsed 93.08 s.
  Got page: 5; 5% done. Elapsed 97.6 s.
  Got page: 6; 6% done. Elapsed 103.77 s.
  Got page: 7; 8% done. Elapsed 109.54 s.
  Got page: 8; 9% done. Elapsed 114.12 s.
  Got page: 9; 10% done. Elapsed 118.5 s.
  Got page: 10; 11% done. Elapsed 123.24 s.
  Got page: 11; 12% done. Elapsed 128.04 s.
  Got page: 12; 13% done. Elapsed 133.37 s.
  Got page: 13; 14% done. Elapsed 138.75 s.
  Got page: 14; 15% done. Elapsed 144.53 s.
  Got page: 15; 16% done. Elapsed 148.76 s.
  Got page: 16; 17% done. Elapsed 154.12 s.
  Got page: 17; 18% done. Elapsed 159.16 s.
  Got page: 18; 19% done. Elapsed 163.59 s.
  Got page: 19; 20% done. Elapsed 170.18 s.
  Got page: 20; 22% done. Elapsed 175.16 s.
  Got page: 21; 23% done. Elapsed 180.41 s.
  Got page: 22; 24% done. Elapsed 187.83 s.
  Got page: 23; 25% done. Elapsed 192.9 s.
  Got page: 24; 26% done. Elapsed 198.43 s.
  Got page: 25; 27% done. Elapsed 203.0 s.
  Got page: 26; 28% done. Elapsed 209.36 s.
  Got page: 27; 29% done. Elapsed 220.63 s.
  Got page: 28; 30% done. Elapsed 226.05 s.
  Got page: 29; 31% done. Elapsed 230.49 s.
  Got page: 30; 32% done. Elapsed 235.01 s.
  Got page: 31; 33% done. Elapsed 240.81 s.
  Got page: 32; 35% done. Elapsed 246.79 s.
  Got page: 33; 36% done. Elapsed 253.15 s.
Requesting query... ok.
Query running...
Query done.
Processed: 10.5 KB

Retrieving results...
Got 151 rows.

Total time taken 0.97 s.
Finished at 2017-06-30 21:27:31.
Saved to ./../data/SPD1x_2T2015/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.2 MB

Retrieving results...
Got 7521 rows.

Total time taken 3.9 s.
Finished at 2017-06-30 21:27:36.
Saved to ./../data/SPD1x_2T2015/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.5 MB

Retrieving results...
Got 4558 rows.

Total time taken 4.58 s.
Finished at 2017-06-30 21:27:42.
Saved to ./../data/SPD1x_2T2015/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.0 MB

Retrieving results...
Got 2275 rows.

Total time taken 1.66 s.
Finished at 2017-06-30 21:27:45.
Saved to ./../data/SPD1x_2T2015/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 9.5 MB

Retrieving results...
  Got page: 1; 62% done. Elapsed 7.64 s.
  Got page: 2; 100% done. Elapsed 11.3 s.
Got 94828 rows.

Total time taken 12.75 s.
Finished at 2017-06-30 21:27:59.
Saved to ./../data/SPD1x_2T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 128.4 KB

Retrieving results...
Got 1399 rows.

Total time taken 1.01 s.
Finished at 2017-06-30 21:28:02.
Saved to ./../data/SPD1x_2T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 115.3 MB

Retrieving results...
  Got page: 1; 25% done. Elapsed 13.83 s.
  Got page: 2; 51% done. Elapsed 19.33 s.
  Got page: 3; 76% done. Elapsed 26.1 s.
  Got page: 4; 100% done. Elapsed 30.93 s.
Got 230246 rows.

Total time taken 33.69 s.
Finished at 2017-06-30 21:28:37.
Saved to ./../data/SPD1x_2T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 449.0 KB

Retrieving results...
Got 1000 rows.

Total time taken 1.37 s.
Finished at 2017-06-30 21:28:41.
Saved to ./../data/SPD1x_2T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 6.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 11.22 s.
Got 103 rows.

Total time taken 11.22 s.
Finished at 2017-06-30 21:28:54.
Saved to ./../data/SPD1x_2T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 4.1 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 14.83 s.
Got 20425 rows.

Total time taken 15.22 s.
Finished at 2017-06-30 21:29:10.
Saved to ./../data/SPD1x_2T2015/page_dirt.csv
Could not parse problem

If you haven't already done so, go download the pythag-starter.rkt file from the week 1 page. Use only the language you've learned so far to answer the question.
Assume that the two short sides of a right triangle have length 3 and 4. What is the length of the long side? Recall the Pythagorean Theorem tells us that:

Write a BSL expression that produces the value of ? for this triangle where the other two sides have lengths 3 and 4.
Once you have completed the problem, paste your expression here.

(sqrt(+(sqr 3)(sqr 4)))
(sqrt (+ (sqr 3)(sqr 4)))
(sqrt (+(sqr 3)(sqr 4)))
(sqrt(+ (sqr 3) (sqr 4)))
(sqrt(+ (sqr 3)(sqr 4)))
(sqrt(+(sqr 3) (sqr 4)))




Explanation
If your answer was incorrect and you don't understand why, watch the continuation of the video.



Could not parse problem

What is the next step in the following evaluation? 
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
   Step 1: (/ 12 (+ (- 7 4) 3)) 
   Step 2:  __________________





Explanation
The second operand to / is an expression, so it must be evaluated. And the first operand to + is an expression, so it must be evaluated. All of the operands to - are values, so - can be called with 7 and 4 as arguments. This replaces the - call expression with 3.



Could not parse problem


What is the next step in the following evaluation? 
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
Step 1: (/ 12 (+ (- 7 4) 3)) 
Step 2: (/ 12 (+ 3 3)) 
Step 3:  ______________





Explanation:
All of the operands to + have been evaluated, so + can be called with the arguments 3 and 3.




Could not parse problem


What is the next step in the following evaluation?
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
Step 1: (/ 12 (+ (- 7 4) 3)) 
Step 2: (/ 12 (+ 3 3)) 
Step 3: (/ 12 6) 
Step 4: _________





Explanation:
All of the operands to / have been evaluated, so the primitive can be called with the arguments 12 and 6.




Could not parse problem

Consider the following program:

(define FOO (* 2 3))
(define BAR (* FOO 2))

(* FOO BAR)
What result is produced when the program is run? (The best way to figure this out would be to work through the evaluation rules you know one at a time until you have the final result.)




Could not parse problem



    Click the mouse to move the green dot on top of one example of an operator.





Explanation
Operators are primitives built into BSL that consume primitive data and produce  results. Examples include +, *, -, / and many more.  
      		




Could not parse problem



	Identify one example of a function name.





Explanation
	Recall:





Could not parse problem



	Click the mouse to move the green dot on top of one example of a function body.





Explanation
	Recall:





Could not parse problem



	Click the mouse to move the green dot on top of one example of a parameter.





Explanation
	Recall:





Could not parse problem

Problem: Design a function that pluralizes a given word. (Pluralize means to convert the word
          to its plural form.) For simplicity you may assume that just adding s is enough to pluralize a word.
  	

    What is an appropriate signature for this function? Leave out the two semi-colons and the space, but
    otherwise be sure to get the capitalization and all other aspects of the signature correct.
  





Explanation
The most appropriate way to represent a word is with a string, so the primitive type the function should consume and produce is String. This means the signature line, including the semi-colons, is:
;; String -> String
 Note: type names should use upper camel case.



Could not parse problem

A "pointing on a picture" problem (also called an "image mapped input" problem) presents an image, and asks you to click on an area in the image. To help ensure accuracy, make sure you click near the middle of what the question asks for.
In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
The signature shows the function as producing String. But this doesn't match the purpose, the check-expects or the stub, all of which have the function producing Number.



Could not parse problem

In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
In the second check-expect, the operand in the call to empty-string? is 0. But 0 is a number, the signature says the function must consume String, and all the other parts of the design have the function consuming String. 



Could not parse problem

In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
The false answer in the if expression produces true. But true is a boolean, which does not match the signature, purpose or any of the check-expects. 



Could not parse problem

The issue of how many tests a function needs is something we will discuss in more and more detail as the course moves forwards.  
_____________________________________________________________________________
Take a moment to think about how many tests are necessary for the function in the previous video?





Explanation
Continue watching part 2 of the video for an explanation of why each test is necessary. 



Could not parse problem








Build a cond expression equivalent to the above nested if expressions by dragging each of the parts below into the proper place in the cond.
















correct_answer = [{
    'draggables': ['2', '5', '3', '4', '1', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5', 't6'],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        


Could not parse problem

Match each of the following problem statement fragments to the corresponding form of data definition.
 1 - "percentage score"
      2 - "TV volume level 1-30, or mute"
      3 - "primary colors: red, green, blue"
      4 - "height of a rocket"












correct_answer = {'1d':'tb', '2d':'td', '3d':'tc', '4d':'ta'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        


ExplanationGiven the problem statement fragments, the types comments should look something like this:

;; RocketHeight is Natural

;; PercentageScore is Number[0, 100]

;; PrimaryColor is one of:
;; - "red"
;; - "green"
;; - "blue"

;; TelevisionVolume is one of:
;; - Number[1, 30]    
;; - "mute"



Could not parse problem


What is the minimum number of data examples needed to illustrate this data definition? [Enter a number]





Explanation
We need at least 1 example that represents Natural[1, 100], and 1 that represents "standby".




Could not parse problem

How many function examples (tests) would a function need if it consumes Reservation and produces true if the reservation is the last one? [Enter a number]





Explanation
We need at least 3 tests: 2 for the interval case, because the result is true if the reservation is 100, and false otherwise, and we need at least 1 test for the second case, "standby".



Could not parse problem

















correct_answer = correct_answer = [
    {
      'draggables': ['1'],
      'targets': ['t2', 't5'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['2'],
      'targets': ['t1', 't6'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['4', '3'],
      'targets': ['t3', 't4'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem



Drag the Cat data onto it's corresponding image in the world program.











correct_answer = {'1': 't2', '2': 't3', '3': 't1'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Move the green dot to the set of images which most accurately reflects what the domain analysis should look like for the countdown program. Assume the images were drawn from left to right to represent different clock ticks in the program.






Explanation
 The bottom left is the best domain analysis because it shows the numbers in the center of the screen, decreasing until reaching zero.



Could not parse problem



Again consider the countdown program. Categorize each piece of information as either constant or changing.














correct_answer = {
        '1': 'constant', '2': 'constant', '3': 'constant', '4': 'constant', '5': 'change', '6': 'constant', '7': 'constant', '8': 'constant'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem



Drag the Countdown data to complete each check-expect for our handle-mouse function. Note, each value can be used more than once, and you don't need to use every one.












correct_answer = [{
      'draggables': ['1'],
      'targets': ['t1', 't3', 't4'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['3'],
      'targets': ['t2'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Here is the signature and purpose for the function that produces true if the list contains a negative number.
;; ListOfNumber -> Boolean
;; produce true if a lon contains a negative number
What is the result of the following tests?
(check-expect (contains-negative? (cons 1 empty)) _____)





Explanation
The list has only 1 element and it is positive.



Could not parse problem

(check-expect (contains-negative? (cons 1 (cons -1.5 empty))) _____)





Explanation
The second element of the list is negative.



Could not parse problem

(check-expect (contains-negative? empty) _____)





Explanation
The list is empty, so it contains no negative numbers.



Could not parse problem

Is this self-referential type comment well-formed?
;; ListOfNumber is one of:
;; - (cons Number ListOfNumber)





Explanation
Although it has a self-referential case, it does not have a base case, so it is not well formed.



Could not parse problem

Is this self-referential type comment well-formed?
;; NonEmptyListOfNumber is one of:
;; - (cons Number empty)
;; - (cons Number NonEmptyListOfNumber)





Explanation
This is a type comment for a non-empty list - a list that at it's shortest just has a single element. It is well-formed because it has both a base case which has no self-reference: (cons Number empty), and a self-referential case: (cons Number NonEmptyListOfNumber).



Could not parse problem

Choose the part of the template that results from each highlighted part of the Type Comment.






Explanation
ListOfNumber has two cases, so we need a cond expression. empty is the first case, and it is atomic distinct, so the answer clause is (...).



Could not parse problem







Explanation
(cons Number ListOfNumber) is compound, so we separate it into two parts, the first being (first lon).



Could not parse problem







Explanation
The second part of the compound is (rest lon) which is ListOfNumber. This is a self-reference in the type comment, so (rest lon) is wrapped in a call to fn-for-lon to form a natural recursion.



Could not parse problem


Drag the template rules to create the correct template rules for foo. Only use as many template rules as are necessary.











correct_answer = [{
    'draggables': ['compound', 'atomic', 'reference' ],
    'targets': ['t1', 't2', 't3' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Use the options below to create the correct template rules for ListOfConcert.
You can use up to six template rules, but you do not need to use all the space.
Note, if you drap the options out of the bar at the bottom, they become bigger and you will be able to read the template rules.
















correct_answer = [{
    'draggables': ['2', '3', '4', '5', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

The factorial of a natural number n is n*n-1*n-2*...1. So factorial of 3 is 3*2*1*1. Let's design a function called fact to compute the factorial.

factorial of 0 is 1
factorial of n is n*factorial(n-1)

Here is the signature and purpose for fact:
;; Natural -> Natural
;; compute n * n-1 * n-2 * ... * 1
What is the result of each check-expect?
(check-expect (fact 0) ____ )



(check-expect (fact 3) ____ )





Explanation
0 factorial is 1, so (fact 0) should produce 1. 
3 factorial is 3*2*1 whihc is 6.



Could not parse problem

In the two boxes below, complete the two cases in the types comment for the data definition for a list of images. 

;; ListOfImage is one of:




















Explanation
The correct type comment for a list of images is 
;; ListOfImage is one of:
;; - empty
;; - (cons Image ListOfImage)



Could not parse problem

After we run the program, we notice that one test in arrange-strings is still failing. Are we done working on layout-strings?






Explanation
We didn't complete the sorting part of this program, so that test for arrange-strings should fail. But since the tests for layout-strings are passing we are ready to move on to completing the rest of the program. 



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
First we look at the root, the node 3:c. It does not have the key 4. We go down the right subtree since the key we are looking for is greater than 3. Then we look at the node 4:d, and it has key 4 and we are done. So we looked at 2 nodes, 3:c and 4:d.



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
To find key 4, we need to look at nodes 1:a, 2:b, 3:c, and then 4:d. So 4 nodes in total.



Could not parse problem



Suppose instead of producing the value of a node with a given key, we would like to 
    produce the path that we took when we searched for that key. So the function that we 
    would like to design should produce a list of "L" or "R", and should end with either
    "Fail" or "Succeed", depending on whether we found the key.
  

    We're almost done designing this function. We have the signature, purpose, tests,
    and we've even started filling in the template.
Drag the expressions below, into the appropriate box on the partially filled in template.












        
correct_answer = {'1': 'second', '2': 'third', '3': 'fourth', '4': 'first'}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


    You're still not comfortable with the idea that trees are layed out from above to below in computer 
    science, instead you would prefer to have your trees layed out left to right. So the root is at the 
    left, it's children are to it's right etc. For example, with your new version the result of 
    evaluating:
(render-bst (make-node 100 "C"
                       (make-node  50  "L" false false)
                       (make-node 150 "CL" false false)))
would look something like:




Again, that would look a lot better with a little extra whitespace in it, but please ignore that for now.
By remembering the role that combination positions play in templates, you realize that the new function definition should be very close to the old function definition. Edit the current render function definition so that it has the new left-to-right behavior by dragging one or more function names from the scrollbar below, onto the  function definition where you want to replace one function name with another.









        
correct_answer = {'2': [[130, 75], 45], '4': [[200, 95], 50]}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference.










correct_answer = [
      {
      'draggables': ['R'], 
      'targets': ['Rt'], 
      'rule':'exact'
      },
      {
      'draggables': ['SR'], 
      'targets': ['SRt'], 
      'rule':'exact'
      },
      {
      'draggables': ['MR', 'MR'],
      'targets': ['MRt1', 'MRt2'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference. (The arrows are coloured to help distinguish between them).














correct_answer = [
      {
      'draggables': ['SR', 'SR'],
      'targets': ['SRt1', 'SRt2'],
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['MR', 'MR', 'MR', 'MR', 'MR', 'MR'],
      'targets': ['MRt1', 'MRt2', 'MRt3', 'MRt4', 'MRt5', 'MRt6'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Below are the templates for the above type comments. Select the correct number for each arrow to show the correspondence between the templates and the type comments










correct_answer = [
      {
      'draggables': ['1'], 
      'targets': ['t1'], 
      'rule':'exact'
      },
      {
      'draggables': ['2', '2'], 
      'targets': ['t2', 't4'], 
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['3'],
      'targets': ['t3'],
      'rule':'exact'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

 How many self-references are there?




ExplanationListOfPerson has a self-reference in it.
 


 
 How many references are there?





Explanation
 All remaining references are part of a mutual reference cycle, so there are 0. 


 How many mutual-references are there?




ExplanationListOfPerson has a reference to Person and vice versa.
 



Could not parse problem


Complete the function design for names-under-20--person and names-under-20--lop.







correct_answer = [{
      'draggables': ['cons', 'append'],
      'targets': ['t1', 't2'],
      'rule':'exact'
      }]
        
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Correctly label each arrow on the template with one of R, SR, MR, NH, NR, or NMR.













correct_answer = [{
    'draggables': ['NH', 'NR'],
    'targets': ['t1', 't4'],
    'rule':'exact'
},
{   'draggables': ['NMR', 'NMR'],
    'targets': ['t2', 't3'],
    'rule':'unordered_equal+number'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Design the function has-path? that consumes a BinaryTree and a Path. The function should produce true if following the path through the tree leads to a node. If the path leads to false or runs into false before reaching the end of the path, the function should produce false.

;; BinaryTree Path -> Boolean
;; prodcue true if following p through bt leads to a node; false otherwise

Lets design a cross product of type comments table to help us write tests for this function. Note Nat, Str and BT stand for Natural, String and BinaryTree.

   p        bt  | false | (make-node Nat Str BT BT)
----------------|-------|----------------------------
empty           |       |            
----------------|-------|----------------------------
(cons "L" Path) |       |            
----------------|-------|----------------------------
(cons "R" Path) |       |            

Recall:

(define BT1 (make-node 1 "a" false false))
(define BT4 (make-node 4 "d"
                       (make-node 2 "b")
                                  (make-node 1 "a" false false)
                                  (make-node 3 "c" false false))
                       (make-node 5 "e" false false))) 
We need at least one check-expect for every cell in the table.
What is the value of each check-expcet?
(check-expect (has-path? false empty) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path ends at false. 




Could not parse problem

(check-expect (has-path? false (list "L")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? false (list "R")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? BT1 empty) _____ )




Explanationhas-path should produce true if the path leads to a node. 




Could not parse problem

(check-expect (has-path? BT4 (list "R")) _____ )





Explanation
Following the given path leads to a node. 



Could not parse problem

(check-expect (has-path? BT4 (list "L" "L" "R")) _____ )





Explanation
Following the given path leads to false. 



Could not parse problem

Look at the table again:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|-------|--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|-------|--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))

How many cases can we reduce it to?





Explanation
The table can be reduced to these four cases:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|       |--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|       |--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))




Could not parse problem

In the practice problem find-person-starter.rkt we asked you to use local to improve your functions performance as the tree gets larger. Would the following be a correct use of local for that purpose?

(define (find--lop n lop)
  (local [(define try (find--person n (first lop)))]
    (cond [(empty? lop) false]
          [else
           (if (not (false? (find--person n (first lop))))
               (find--person n (first lop))
               (find--lop n (rest lop)))])))





Explanation
In this case the local has not been moved to surround the nearest expression that encloses all occurrences of the repeated computation. That would be around the if. Instead it moved outside of the cond answer the if appeared in. Try running it with this definition and see what happens. Step it carefully to be sure you understand why. 



Could not parse problem

Would this version that doesn't use local work?

(define try (find--person n (first lop)))

(define (find--lop n lop)
  (cond [(empty? lop) false]
        [else
         (if (not (false? try))
             try
             (find--lop n (rest lop)))]))





Explanation
The paramaters n and lop are not defined outside of find--lop, so this will not work either.



Could not parse problem


Use the pieces below.













correct_answer = [
    {
      'draggables': ['3'],
      'targets': ['t2', 't3'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['7'],
      'targets': ['t1'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


    An image mapped input problem presents an image for the student.
    Input is given by the location of mouse clicks on the image.
    Correctness of input can be evaluated based on expected dimensions of a rectangle.
  
Which animal shown below is a kitten?





Explanation
The animal on the right is a kitten. The animal on the left is a puppy, not a kitten.



Could not parse problem

In adding the accumulator paramater, we have missed a spot where it should be added. Click to move the green dot to the location of the missing accumulator paramater.





Explanation
We need to add acc at all of the ...s, as well as adding an extra paramater to every call of number-list.



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Opening and ending tag mismatch: vertical line 401 and problem
Opening and ending tag mismatch: sequential line 354 and vertical
Opening and ending tag mismatch: chapter line 330 and sequential
Opening and ending tag mismatch: course line 1 and chapter
Extra content at the end of the document
[1] "XML is malformed — using htmlInternalTreeParse."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
  Elapsed 11.25 s. Waiting...
Query done.
Processed: 23.8 MB

Retrieving results...
  Got page: 1; 11% done. Elapsed 17.77 s.
  Got page: 2; 21% done. Elapsed 23.47 s.
  Got page: 3; 32% done. Elapsed 30.61 s.
  Got page: 4; 43% done. Elapsed 35.97 s.
  Got page: 5; 54% done. Elapsed 40.19 s.
  Got page: 6; 64% done. Elapsed 46.05 s.
  Got page: 7; 75% done. Elapsed 53.15 s.
  Got page: 8; 86% done. Elapsed 58.13 s.
  Got page: 9; 97% done. Elapsed 63.6 s.
  Got page: 10; 100% done. Elapsed 65.63 s.
Got 362276 rows.

Total time taken 77.29 s.
Finished at 2017-06-30 21:31:48.
Saved to ./../data/SPD1x_2T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
Query done.
Processed: 4.2 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 13.17 s.
Got 2395 rows.

Total time taken 13.22 s.
Finished at 2017-06-30 21:32:07.
Saved to ./../data/SPD1x_2T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 12.63 s. Waiting...
  Elapsed 23.08 s. Waiting...
  Elapsed 33.49 s. Waiting...
  Elapsed 43.93 s. Waiting...
  Elapsed 54.43 s. Waiting...
  Elapsed 64.63 s. Waiting...
Query done.
Processed: 3.9 GB

Retrieving results...
  Got page: 1; 1% done. Elapsed 80.46 s.
  Got page: 2; 1% done. Elapsed 85.64 s.
  Got page: 3; 2% done. Elapsed 89.57 s.
  Got page: 4; 2% done. Elapsed 93.59 s.
  Got page: 5; 3% done. Elapsed 100.11 s.
  Got page: 6; 4% done. Elapsed 105.94 s.
  Got page: 7; 4% done. Elapsed 110.0 s.
  Got page: 8; 5% done. Elapsed 114.64 s.
  Got page: 9; 5% done. Elapsed 119.07 s.
  Got page: 10; 6% done. Elapsed 123.88 s.
  Got page: 11; 6% done. Elapsed 128.73 s.
  Got page: 12; 7% done. Elapsed 134.18 s.
  Got page: 13; 8% done. Elapsed 141.97 s.
  Got page: 14; 8% done. Elapsed 146.34 s.
  Got page: 15; 9% done. Elapsed 151.38 s.
  Got page: 16; 9% done. Elapsed 156.73 s.
  Got page: 17; 10% done. Elapsed 165.94 s.
  Got page: 18; 11% done. Elapsed 170.76 s.
  Got page: 19; 11% done. Elapsed 176.95 s.
  Got page: 20; 12% done. Elapsed 181.91 s.
  Got page: 21; 12% done. Elapsed 187.7 s.
  Got page: 22; 13% done. Elapsed 192.43 s.
  Got page: 23; 14% done. Elapsed 197.01 s.
  Got page: 24; 14% done. Elapsed 201.74 s.
  Got page: 25; 15% done. Elapsed 207.36 s.
  Got page: 26; 15% done. Elapsed 211.96 s.
  Got page: 27; 16% done. Elapsed 218.92 s.
  Got page: 28; 16% done. Elapsed 224.36 s.
  Got page: 29; 17% done. Elapsed 230.77 s.
  Got page: 30; 18% done. Elapsed 235.91 s.
  Got page: 31; 18% done. Elapsed 240.85 s.
  Got page: 32; 19% done. Elapsed 246.4 s.
  Got page: 33; 19% done. Elapsed 255.1 s.
Requesting query... ok.
Query running...
Query done.
Processed: 10.4 KB

Retrieving results...
Got 150 rows.

Total time taken 0.95 s.
Finished at 2017-06-30 21:37:03.
Saved to ./../data/SPD1x_2T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.2 MB

Retrieving results...
  Got page: 2; 100% done. Elapsed 7.08 s.
Got 13537 rows.

Total time taken 7.96 s.
Finished at 2017-06-30 21:37:12.
Saved to ./../data/SPD1x_2T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.9 MB

Retrieving results...
Got 4682 rows.

Total time taken 4.95 s.
Finished at 2017-06-30 21:37:19.
Saved to ./../data/SPD1x_2T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.6 MB

Retrieving results...
Got 1869 rows.

Total time taken 1.62 s.
Finished at 2017-06-30 21:37:22.
Saved to ./../data/SPD1x_2T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 6.7 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 9.12 s.
Got 51982 rows.

Total time taken 9.75 s.
Finished at 2017-06-30 21:37:33.
Saved to ./../data/SPD1x_2T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 129.0 KB

Retrieving results...
Got 1406 rows.

Total time taken 0.91 s.
Finished at 2017-06-30 21:37:36.
Saved to ./../data/SPD1x_2T2016/tower_item.csv
Requesting query... ok.
Query running...
  Elapsed 10.74 s. Waiting...
Query done.
Processed: 255.7 MB

Retrieving results...
  Got page: 1; 10% done. Elapsed 17.81 s.
  Got page: 2; 20% done. Elapsed 23.17 s.
  Got page: 3; 31% done. Elapsed 29.43 s.
  Got page: 4; 41% done. Elapsed 35.24 s.
  Got page: 5; 51% done. Elapsed 41.1 s.
  Got page: 6; 61% done. Elapsed 46.54 s.
  Got page: 7; 72% done. Elapsed 51.96 s.
  Got page: 8; 82% done. Elapsed 57.6 s.
  Got page: 9; 92% done. Elapsed 65.05 s.
  Got page: 10; 100% done. Elapsed 70.53 s.
Got 570587 rows.

Total time taken 77.84 s.
Finished at 2017-06-30 21:38:55.
Saved to ./../data/SPD1x_2T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 448.4 KB

Retrieving results...
Got 1000 rows.

Total time taken 1.18 s.
Finished at 2017-06-30 21:39:01.
Saved to ./../data/SPD1x_2T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.0 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 14.79 s.
Got 31532 rows.

Total time taken 15.15 s.
Finished at 2017-06-30 21:39:18.
Saved to ./../data/SPD1x_2T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.3 s. Waiting...
  Elapsed 22.69 s. Waiting...
  Elapsed 33.09 s. Waiting...
  Elapsed 43.57 s. Waiting...
  Elapsed 53.67 s. Waiting...
  Elapsed 63.75 s. Waiting...
Query done.
Processed: 783.4 MB

Retrieving results...
  Got page: 1; 1% done. Elapsed 80.95 s.
  Got page: 2; 3% done. Elapsed 87.63 s.
  Got page: 3; 4% done. Elapsed 94.24 s.
  Got page: 4; 6% done. Elapsed 99.78 s.
  Got page: 5; 7% done. Elapsed 106.45 s.
  Got page: 6; 8% done. Elapsed 113.59 s.
  Got page: 7; 10% done. Elapsed 121.49 s.
  Got page: 8; 11% done. Elapsed 128.04 s.
  Got page: 9; 12% done. Elapsed 133.77 s.
  Got page: 10; 14% done. Elapsed 140.06 s.
  Got page: 11; 15% done. Elapsed 147.25 s.
  Got page: 12; 16% done. Elapsed 153.25 s.
  Got page: 13; 18% done. Elapsed 159.35 s.
  Got page: 14; 19% done. Elapsed 166.29 s.
  Got page: 15; 21% done. Elapsed 171.55 s.
  Got page: 16; 22% done. Elapsed 178.38 s.
  Got page: 17; 23% done. Elapsed 185.17 s.
  Got page: 18; 24% done. Elapsed 190.51 s.
  Got page: 19; 25% done. Elapsed 195.5 s.
  Got page: 20; 26% done. Elapsed 200.76 s.
  Got page: 21; 28% done. Elapsed 204.93 s.
  Got page: 22; 29% done. Elapsed 211.33 s.
  Got page: 23; 30% done. Elapsed 216.62 s.
  Got page: 24; 31% done. Elapsed 222.15 s.
  Got page: 25; 32% done. Elapsed 228.03 s.
  Got page: 26; 34% done. Elapsed 235.05 s.
  Got page: 27; 35% done. Elapsed 240.75 s.
  Got page: 28; 36% done. Elapsed 248.63 s.
  Got page: 29; 38% done. Elapsed 254.57 s.
Could not parse problem

If you haven't already done so, go download the pythag-starter.rkt file from the week 1 page. Use only the language you've learned so far to answer the question.
Assume that the two short sides of a right triangle have length 3 and 4. What is the length of the long side? Recall the Pythagorean Theorem tells us that:

Write a BSL expression that produces the value of ? for this triangle where the other two sides have lengths 3 and 4.
Once you have completed the problem, paste your expression here.  Note that this question is deliberately more picky about the correct answer than Dr Racket is.  Dr Racket knows how to evaluate (+(+ 1 2)3).  But in the formatting conventions we are using, we want spaces as in (+ (+ 1 2) 3). This question wants you to pay attention to that detail. 

 (sqrt (+ (sqr 3) (sqr 4)))
 (sqrt (+ (sqr 3) (sqr 4))) 
(sqrt (+ (sqr 3) (sqr 4))) 




Explanation
If your answer was incorrect and you don't understand why, watch the continuation of the video.



Could not parse problem

What is the next step in the following evaluation? 
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
   Step 1: (/ 12 (+ (- 7 4) 3)) 
   Step 2:  __________________





Explanation
The second operand to / is an expression, so it must be evaluated. And the first operand to + is an expression, so it must be evaluated. All of the operands to - are values, so - can be called with 7 and 4 as arguments. This replaces the - call expression with 3.



Could not parse problem


What is the next step in the following evaluation? 
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
Step 1: (/ 12 (+ (- 7 4) 3)) 
Step 2: (/ 12 (+ 3 3)) 
Step 3:  ______________





Explanation:
All of the operands to + have been evaluated, so + can be called with the arguments 3 and 3.




Could not parse problem


What is the next step in the following evaluation?
Step 0: (/ (* 3 4) (+ (- 7 4) 3))
Step 1: (/ 12 (+ (- 7 4) 3)) 
Step 2: (/ 12 (+ 3 3)) 
Step 3: (/ 12 6) 
Step 4: _________





Explanation:
All of the operands to / have been evaluated, so the primitive can be called with the arguments 12 and 6.




Could not parse problem

Consider the following program:

(define FOO (* 2 3))
(define BAR (* FOO 2))

(* FOO BAR)
What result is produced when the program is run? (The best way to figure this out would be to work through the evaluation rules you know one at a time until you have the final result.)




Could not parse problem



    Click the mouse to move the green dot on top of one example of an operator.





Explanation
Operators are primitives built into BSL that consume primitive data and produce  results. Examples include +, *, -, / and many more.  
      		




Could not parse problem



	Identify one example of a function name.





Explanation
	Recall:





Could not parse problem



	Click the mouse to move the green dot on top of one example of a function body.





Explanation
	Recall:





Could not parse problem



	Click the mouse to move the green dot on top of one example of a parameter.





Explanation
	Recall:





Could not parse problem

Problem: Design a function that pluralizes a given word. (Pluralize means to convert the word
          to its plural form.) For simplicity you may assume that just adding s is enough to pluralize a word.
  	

    What is an appropriate signature for this function? Leave out the two semi-colons and the space, but
    otherwise be sure to get the capitalization and all other aspects of the signature correct.
  





Explanation
The most appropriate way to represent a word is with a string, so the primitive type the function should consume and produce is String. This means the signature line, including the semi-colons, is:
;; String -> String
 Note: type names should use upper camel case.



Could not parse problem

A "pointing on a picture" problem (also called an "image mapped input" problem) presents an image, and asks you to click on an area in the image. To help ensure accuracy, make sure you click near the middle of what the question asks for.
In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
The signature shows the function as producing String. But this doesn't match the purpose, the check-expects or the stub, all of which have the function producing Number.



Could not parse problem

In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
In the second check-expect, the operand in the call to empty-string? is 0. But 0 is a number, the signature says the function must consume String, and all the other parts of the design have the function consuming String. 



Could not parse problem

In the following partially complete function design, one part of the design is inconsistent with the rest. Click on the most specific or smallest part that "doesn't belong". 





Explanation
The false answer in the if expression produces true. But true is a boolean, which does not match the signature, purpose or any of the check-expects. 



Could not parse problem

The issue of how many tests a function needs is something we will discuss in more and more detail as the course moves forwards.  
_____________________________________________________________________________
Take a moment to think about how many tests are necessary for the function in the previous video?





Explanation
Continue watching part 2 of the video for an explanation of why each test is necessary. 



Could not parse problem








Build a cond expression equivalent to the above nested if expressions by dragging each of the parts below into the proper place in the cond.
















correct_answer = [{
    'draggables': ['2', '5', '3', '4', '1', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5', 't6'],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        


Could not parse problem

Match each of the following problem statement fragments to the corresponding form of data definition.
 1 - "percentage score"
      2 - "TV volume level 1-30, or mute"
      3 - "primary colors: red, green, blue"
      4 - "height of a rocket"












correct_answer = {'1d':'tb', '2d':'td', '3d':'tc', '4d':'ta'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        


ExplanationGiven the problem statement fragments, the types comments should look something like this:

;; RocketHeight is Natural

;; PercentageScore is Number[0, 100]

;; PrimaryColor is one of:
;; - "red"
;; - "green"
;; - "blue"

;; TelevisionVolume is one of:
;; - Number[1, 30]    
;; - "mute"



Could not parse problem


What is the minimum number of data examples needed to illustrate this data definition? [Enter a number]





Explanation
We need at least 1 example that represents Natural[1, 100], and 1 that represents "standby".




Could not parse problem

How many function examples (tests) would a function need if it consumes Reservation and produces true if the reservation is the last one? [Enter a number]





Explanation
We need at least 3 tests: 2 for the interval case, because the result is true if the reservation is 100, and false otherwise, and we need at least 1 test for the second case, "standby".



Could not parse problem

















correct_answer = correct_answer = [
    {
      'draggables': ['1'],
      'targets': ['t2', 't5'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['2'],
      'targets': ['t1', 't6'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['4', '3'],
      'targets': ['t3', 't4'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem



Drag the Cat data onto it's corresponding image in the world program.











correct_answer = {'1': 't2', '2': 't3', '3': 't1'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Move the green dot to the set of images which most accurately reflects what the domain analysis should look like for the countdown program. Assume the images were drawn from left to right to represent different clock ticks in the program.






Explanation
 The bottom left is the best domain analysis because it shows the numbers in the center of the screen, decreasing until reaching zero.



Could not parse problem



Again consider the countdown program. Categorize each piece of information as either constant or changing.














correct_answer = {
        '1': 'constant', '2': 'constant', '3': 'constant', '4': 'constant', '5': 'change', '6': 'constant', '7': 'constant', '8': 'constant'}
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem



Drag the Countdown data to complete each check-expect for our handle-mouse function. Note, each value can be used more than once, and you don't need to use every one.












correct_answer = [{
      'draggables': ['1'],
      'targets': ['t1', 't3', 't4'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['3'],
      'targets': ['t2'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Here is the signature and purpose for the function that produces true if the list contains a negative number.
;; ListOfNumber -> Boolean
;; produce true if a lon contains a negative number
What is the result of the following tests?
(check-expect (contains-negative? (cons 1 empty)) _____)





Explanation
The list has only 1 element and it is positive.



Could not parse problem

(check-expect (contains-negative? (cons 1 (cons -1.5 empty))) _____)





Explanation
The second element of the list is negative.



Could not parse problem

(check-expect (contains-negative? empty) _____)





Explanation
The list is empty, so it contains no negative numbers.



Could not parse problem

Is this self-referential type comment well-formed?
;; ListOfNumber is one of:
;; - (cons Number ListOfNumber)





Explanation
Although it has a self-referential case, it does not have a base case, so it is not well formed.



Could not parse problem

Is this self-referential type comment well-formed?
;; NonEmptyListOfNumber is one of:
;; - (cons Number empty)
;; - (cons Number NonEmptyListOfNumber)





Explanation
This is a type comment for a non-empty list - a list that at it's shortest just has a single element. It is well-formed because it has both a base case which has no self-reference: (cons Number empty), and a self-referential case: (cons Number NonEmptyListOfNumber).



Could not parse problem

Choose the part of the template that results from each highlighted part of the Type Comment.






Explanation
ListOfNumber has two cases, so we need a cond expression. empty is the first case, and it is atomic distinct, so the answer clause is (...).



Could not parse problem







Explanation
(cons Number ListOfNumber) is compound, so we separate it into two parts, the first being (first lon).



Could not parse problem







Explanation
The second part of the compound is (rest lon) which is ListOfNumber. This is a self-reference in the type comment, so (rest lon) is wrapped in a call to fn-for-lon to form a natural recursion.



Could not parse problem


Drag the template rules to create the correct template rules for foo. Only use as many template rules as are necessary.











correct_answer = [{
    'draggables': ['compound', 'atomic', 'reference' ],
    'targets': ['t1', 't2', 't3' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Use the options below to create the correct template rules for ListOfConcert.
You can use up to six template rules, but you do not need to use all the space.
Note, if you drap the options out of the bar at the bottom, they become bigger and you will be able to read the template rules.
















correct_answer = [{
    'draggables': ['2', '3', '4', '5', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

The factorial of a natural number n is n*n-1*n-2*...1. So factorial of 3 is 3*2*1*1. Let's design a function called fact to compute the factorial.

factorial of 0 is 1
factorial of n is n*factorial(n-1)

Here is the signature and purpose for fact:
;; Natural -> Natural
;; compute n * n-1 * n-2 * ... * 1
What is the result of each check-expect?
(check-expect (fact 0) ____ )



(check-expect (fact 3) ____ )





Explanation
0 factorial is 1, so (fact 0) should produce 1. 
3 factorial is 3*2*1 whihc is 6.



Could not parse problem

In the two boxes below, complete the two cases in the types comment for the data definition for a list of images. 

;; ListOfImage is one of:




















Explanation
The correct type comment for a list of images is 
;; ListOfImage is one of:
;; - empty
;; - (cons Image ListOfImage)



Could not parse problem

After we run the program, we notice that one test in arrange-strings is still failing. Are we done working on layout-strings?






Explanation
We didn't complete the sorting part of this program, so that test for arrange-strings should fail. But since the tests for layout-strings are passing we are ready to move on to completing the rest of the program. 



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
First we look at the root, the node 3:c. It does not have the key 4. We go down the right subtree since the key we are looking for is greater than 3. Then we look at the node 4:d, and it has key 4 and we are done. So we looked at 2 nodes, 3:c and 4:d.



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
To find key 4, we need to look at nodes 1:a, 2:b, 3:c, and then 4:d. So 4 nodes in total.



Could not parse problem



Suppose instead of producing the value of a node with a given key, we would like to 
    produce the path that we took when we searched for that key. So the function that we 
    would like to design should produce a list of "L" or "R", and should end with either
    "Fail" or "Succeed", depending on whether we found the key.
  

    We're almost done designing this function. We have the signature, purpose, tests,
    and we've even started filling in the template.
Drag the expressions below, into the appropriate box on the partially filled in template.












        
correct_answer = {'1': 'second', '2': 'third', '3': 'fourth', '4': 'first'}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


    You're still not comfortable with the idea that trees are layed out from above to below in computer 
    science, instead you would prefer to have your trees layed out left to right. So the root is at the 
    left, it's children are to it's right etc. For example, with your new version the result of 
    evaluating:
(render-bst (make-node 100 "C"
                       (make-node  50  "L" false false)
                       (make-node 150 "CL" false false)))
would look something like:




Again, that would look a lot better with a little extra whitespace in it, but please ignore that for now.
By remembering the role that combination positions play in templates, you realize that the new function definition should be very close to the old function definition. Edit the current render function definition so that it has the new left-to-right behavior by dragging one or more function names from the scrollbar below, onto the  function definition where you want to replace one function name with another.









        
correct_answer = {'2': [[130, 75], 45], '4': [[200, 95], 50]}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference.










correct_answer = [
      {
      'draggables': ['R'], 
      'targets': ['Rt'], 
      'rule':'exact'
      },
      {
      'draggables': ['SR'], 
      'targets': ['SRt'], 
      'rule':'exact'
      },
      {
      'draggables': ['MR', 'MR'],
      'targets': ['MRt1', 'MRt2'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference. (The arrows are coloured to help distinguish between them).














correct_answer = [
      {
      'draggables': ['SR', 'SR'],
      'targets': ['SRt1', 'SRt2'],
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['MR', 'MR', 'MR', 'MR', 'MR', 'MR'],
      'targets': ['MRt1', 'MRt2', 'MRt3', 'MRt4', 'MRt5', 'MRt6'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Below are the templates for the above type comments. Select the correct number for each arrow to show the correspondence between the templates and the type comments










correct_answer = [
      {
      'draggables': ['1'], 
      'targets': ['t1'], 
      'rule':'exact'
      },
      {
      'draggables': ['2', '2'], 
      'targets': ['t2', 't4'], 
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['3'],
      'targets': ['t3'],
      'rule':'exact'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

 How many self-references are there?




ExplanationListOfPerson has a self-reference in it.
 


 
 How many references are there?





Explanation
 All remaining references are part of a mutual reference cycle, so there are 0. 


 How many mutual-references are there?




ExplanationListOfPerson has a reference to Person and vice versa.
 



Could not parse problem


Complete the function design for names-under-20--person and names-under-20--lop.







correct_answer = [{
      'draggables': ['cons', 'append'],
      'targets': ['t1', 't2'],
      'rule':'exact'
      }]
        
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Correctly label each arrow on the template with one of R, SR, MR, NH, NR, or NMR.













correct_answer = [{
    'draggables': ['NH', 'NR'],
    'targets': ['t1', 't4'],
    'rule':'exact'
},
{   'draggables': ['NMR', 'NMR'],
    'targets': ['t2', 't3'],
    'rule':'unordered_equal+number'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Design the function has-path? that consumes a BinaryTree and a Path. The function should produce true if following the path through the tree leads to a node. If the path leads to false or runs into false before reaching the end of the path, the function should produce false.

;; BinaryTree Path -> Boolean
;; prodcue true if following p through bt leads to a node; false otherwise

Lets design a cross product of type comments table to help us write tests for this function. Note Nat, Str and BT stand for Natural, String and BinaryTree.

   p        bt  | false | (make-node Nat Str BT BT)
----------------|-------|----------------------------
empty           |       |            
----------------|-------|----------------------------
(cons "L" Path) |       |            
----------------|-------|----------------------------
(cons "R" Path) |       |            

Recall:

(define BT1 (make-node 1 "a" false false))
(define BT4 (make-node 4 "d"
                       (make-node 2 "b")
                                  (make-node 1 "a" false false)
                                  (make-node 3 "c" false false))
                       (make-node 5 "e" false false))) 
We need at least one check-expect for every cell in the table.
What is the value of each check-expcet?
(check-expect (has-path? false empty) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path ends at false. 




Could not parse problem

(check-expect (has-path? false (list "L")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? false (list "R")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? BT1 empty) _____ )




Explanationhas-path should produce true if the path leads to a node. 




Could not parse problem

(check-expect (has-path? BT4 (list "R")) _____ )





Explanation
Following the given path leads to a node. 



Could not parse problem

(check-expect (has-path? BT4 (list "L" "L" "R")) _____ )





Explanation
Following the given path leads to false. 



Could not parse problem

Look at the table again:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|-------|--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|-------|--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))

How many cases can we reduce it to?





Explanation
The table can be reduced to these four cases:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|       |--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|       |--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))




Could not parse problem

In the practice problem find-person-starter.rkt we asked you to use local to improve your functions performance as the tree gets larger. Would the following be a correct use of local for that purpose?

(define (find--lop n lop)
  (local [(define try (find--person n (first lop)))]
    (cond [(empty? lop) false]
          [else
           (if (not (false? (find--person n (first lop))))
               (find--person n (first lop))
               (find--lop n (rest lop)))])))





Explanation
In this case the local has not been moved to surround the nearest expression that encloses all occurrences of the repeated computation. That would be around the if. Instead it moved outside of the cond answer the if appeared in. Try running it with this definition and see what happens. Step it carefully to be sure you understand why. 



Could not parse problem

Would this version that doesn't use local work?

(define try (find--person n (first lop)))

(define (find--lop n lop)
  (cond [(empty? lop) false]
        [else
         (if (not (false? try))
             try
             (find--lop n (rest lop)))]))





Explanation
The paramaters n and lop are not defined outside of find--lop, so this will not work either.



Could not parse problem


Use the pieces below.













correct_answer = [
    {
      'draggables': ['3'],
      'targets': ['t2', 't3'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['7'],
      'targets': ['t1'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


    An image mapped input problem presents an image for the student.
    Input is given by the location of mouse clicks on the image.
    Correctness of input can be evaluated based on expected dimensions of a rectangle.
  
Which animal shown below is a kitten?





Explanation
The animal on the right is a kitten. The animal on the left is a puppy, not a kitten.



Could not parse problem

In adding the accumulator paramater, we have missed a spot where it should be added. Click to move the green dot to the location of the missing accumulator paramater.





Explanation
We need to add acc at all of the ...s, as well as adding an extra paramater to every call of number-list.



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment
Double hyphen within comment: <!----
Double hyphen within comment: <!------
Double hyphen within comment: <!--------
Double hyphen within comment: <!----------
Double hyphen within comment: <!------------
Double hyphen within comment: <!--------------
Double hyphen within comment: <!----------------
Double hyphen within comment: <!------------------
Double hyphen within comment: <!--------------------
Double hyphen within comment: <!----------------------
Double hyphen within comment: <!------------------------
Double hyphen within comment: <!--------------------------
Double hyphen within comment: <!----------------------------
Double hyphen within comment: <!------------------------------
Double hyphen within comment: <!--------------------------------
Double hyphen within comment: <!----------------------------------
Double hyphen within comment: <!------------------------------------
Double hyphen within comment: <!--------------------------------------
Double hyphen within comment: <!----------------------------------------
Double hyphen within comment: <!------------------------------------------
Double hyphen within comment: <!--------------------------------------------
Double hyphen within comment: <!----------------------------------------------
Double hyphen within comment: <!------------------------------------------------
Double hyphen within comment: <!--------------------------------------------------
Double hyphen within comment: <!----------------------------------------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
[1] "XML is malformed — using htmlInternalTreeParse."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 3.1 MB

Retrieving results...
  Got page: 1; 75% done. Elapsed 9.76 s.
  Got page: 2; 100% done. Elapsed 11.66 s.
Got 51579 rows.

Total time taken 13.12 s.
Finished at 2017-06-30 21:45:35.
Saved to ./../data/SPD2x_2T2015/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 14.38 s. Waiting...
  Elapsed 24.77 s. Waiting...
Query done.
Processed: 535.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 26.49 s.
Got 326 rows.

Total time taken 26.5 s.
Finished at 2017-06-30 21:46:04.
Saved to ./../data/SPD2x_2T2015/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 14.84 s. Waiting...
  Elapsed 25.28 s. Waiting...
  Elapsed 35.65 s. Waiting...
  Elapsed 46.03 s. Waiting...
Query done.
Processed: 485.0 MB

Retrieving results...
  Got page: 1; 3% done. Elapsed 52.79 s.
  Got page: 2; 5% done. Elapsed 56.67 s.
  Got page: 3; 8% done. Elapsed 61.12 s.
  Got page: 4; 10% done. Elapsed 69.24 s.
  Got page: 5; 13% done. Elapsed 74.67 s.
  Got page: 6; 15% done. Elapsed 79.52 s.
  Got page: 7; 18% done. Elapsed 83.84 s.
  Got page: 8; 21% done. Elapsed 88.58 s.
  Got page: 9; 23% done. Elapsed 95.08 s.
  Got page: 10; 26% done. Elapsed 100.13 s.
  Got page: 11; 28% done. Elapsed 105.28 s.
  Got page: 12; 31% done. Elapsed 110.95 s.
  Got page: 13; 33% done. Elapsed 116.33 s.
  Got page: 14; 36% done. Elapsed 121.44 s.
  Got page: 15; 39% done. Elapsed 126.4 s.
  Got page: 16; 41% done. Elapsed 131.86 s.
  Got page: 17; 44% done. Elapsed 139.85 s.
  Got page: 18; 46% done. Elapsed 144.83 s.
  Got page: 19; 49% done. Elapsed 150.22 s.
  Got page: 20; 51% done. Elapsed 156.17 s.
  Got page: 21; 54% done. Elapsed 163.2 s.
  Got page: 22; 57% done. Elapsed 168.63 s.
  Got page: 23; 59% done. Elapsed 174.42 s.
  Got page: 24; 62% done. Elapsed 178.86 s.
  Got page: 25; 64% done. Elapsed 183.76 s.
  Got page: 26; 67% done. Elapsed 188.7 s.
  Got page: 27; 70% done. Elapsed 195.02 s.
  Got page: 28; 72% done. Elapsed 200.21 s.
  Got page: 29; 75% done. Elapsed 205.95 s.
  Got page: 30; 77% done. Elapsed 210.76 s.
  Got page: 31; 80% done. Elapsed 216.82 s.
  Got page: 32; 82% done. Elapsed 222.19 s.
Requesting query... ok.
Query running...
Query done.
Processed: 2.9 KB

Retrieving results...
Got 44 rows.

Total time taken 1.43 s.
Finished at 2017-06-30 21:50:17.
Saved to ./../data/SPD2x_2T2015/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 694.8 KB

Retrieving results...
Got 3841 rows.

Total time taken 2.54 s.
Finished at 2017-06-30 21:50:21.
Saved to ./../data/SPD2x_2T2015/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 514.9 KB

Retrieving results...
Got 739 rows.

Total time taken 1.4 s.
Finished at 2017-06-30 21:50:24.
Saved to ./../data/SPD2x_2T2015/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 642.6 KB

Retrieving results...
Got 611 rows.

Total time taken 1.4 s.
Finished at 2017-06-30 21:50:27.
Saved to ./../data/SPD2x_2T2015/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.6 MB

Retrieving results...
Got 13356 rows.

Total time taken 3.6 s.
Finished at 2017-06-30 21:50:32.
Saved to ./../data/SPD2x_2T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 47.7 KB

Retrieving results...
Got 523 rows.

Total time taken 0.73 s.
Finished at 2017-06-30 21:50:34.
Saved to ./../data/SPD2x_2T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 35.0 MB

Retrieving results...
  Got page: 1; 91% done. Elapsed 9.92 s.
  Got page: 2; 100% done. Elapsed 10.88 s.
Got 64125 rows.

Total time taken 11.58 s.
Finished at 2017-06-30 21:50:46.
Saved to ./../data/SPD2x_2T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 170.7 KB

Retrieving results...
Got 523 rows.

Total time taken 0.94 s.
Finished at 2017-06-30 21:50:49.
Saved to ./../data/SPD2x_2T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 33.6 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 10.2 s.
Got 499 rows.

Total time taken 10.2 s.
Finished at 2017-06-30 21:51:00.
Saved to ./../data/SPD2x_2T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.53 s. Waiting...
Query done.
Processed: 23.0 MB

Retrieving results...
  Got page: 1; 41% done. Elapsed 23.15 s.
  Got page: 2; 82% done. Elapsed 28.87 s.
  Got page: 3; 100% done. Elapsed 31.75 s.
Got 132650 rows.

Total time taken 34.3 s.
Finished at 2017-06-30 21:51:35.
Saved to ./../data/SPD2x_2T2015/page_dirt.csv
Could not parse problem

Here is the signature and purpose for the function that produces true if the list contains a negative number.
;; ListOfNumber -> Boolean
;; produce true if a lon contains a negative number
What is the result of the following tests?
(check-expect (contains-negative? (cons 1 empty)) _____)





Explanation
The list has only 1 element and it is positive.



Could not parse problem

(check-expect (contains-negative? (cons 1 (cons -1.5 empty))) _____)





Explanation
The second element of the list is negative.



Could not parse problem

(check-expect (contains-negative? empty) _____)





Explanation
The list is empty, so it contains no negative numbers.



Could not parse problem

Is this self-referential type comment well-formed?
;; ListOfNumber is one of:
;; - (cons Number ListOfNumber)





Explanation
Although it has a self-referential case, it does not have a base case, so it is not well formed.



Could not parse problem

Is this self-referential type comment well-formed?
;; NonEmptyListOfNumber is one of:
;; - (cons Number empty)
;; - (cons Number NonEmptyListOfNumber)





Explanation
This is a type comment for a non-empty list - a list that at it's shortest just has a single element. It is well-formed because it has both a base case which has no self-reference: (cons Number empty), and a self-referential case: (cons Number NonEmptyListOfNumber).



Could not parse problem

Choose the part of the template that results from each highlighted part of the Type Comment.






Explanation
ListOfNumber has two cases, so we need a cond expression. empty is the first case, and it is atomic distinct, so the answer clause is (...).



Could not parse problem







Explanation
(cons Number ListOfNumber) is compound, so we separate it into two parts, the first being (first lon).



Could not parse problem







Explanation
The second part of the compound is (rest lon) which is ListOfNumber. This is a self-reference in the type comment, so (rest lon) is wrapped in a call to fn-for-lon to form a natural recursion.



Could not parse problem


Drag the template rules to create the correct template rules for foo. Only use as many template rules as are necessary.











correct_answer = [{
    'draggables': ['compound', 'atomic', 'reference' ],
    'targets': ['t1', 't2', 't3' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    



Explanation
Foo is compound. The first field is a simple atomic type, Integer, and the second field is a reference to a non-primitive type.



Could not parse problem


Use the options below to create the correct template rules for ListOfConcert.
You can use up to six template rules, but you do not need to use all the space.
Note, if you drap the options out of the bar at the bottom, they become bigger and you will be able to read the template rules.
















correct_answer = [{
    'draggables': ['2', '3', '4', '5', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

The factorial of a natural number n is n*n-1*n-2*...1. So factorial of 3 is 3*2*1*1. Let's design a function called fact to compute the factorial.

factorial of 0 is 1
factorial of n is n*factorial(n-1)

Here is the signature and purpose for fact:
;; Natural -> Natural
;; compute n * n-1 * n-2 * ... * 1
What is the result of each check-expect?
(check-expect (fact 0) ____ )



(check-expect (fact 3) ____ )





Explanation
0 factorial is 1, so (fact 0) should produce 1. 
3 factorial is 3*2*1 whihc is 6.



Could not parse problem

In the two boxes below, complete the two cases in the types comment for the data definition for a list of images. 

;; ListOfImage is one of:




















Explanation
The correct type comment for a list of images is 
;; ListOfImage is one of:
;; - empty
;; - (cons Image ListOfImage)



Could not parse problem

After we run the program, we notice that one test in arrange-strings is still failing. Are we done working on layout-strings?






Explanation
We didn't complete the sorting part of this program, so that test for arrange-strings should fail. But since the tests for layout-strings are passing we are ready to move on to completing the rest of the program. 



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
First we look at the root, the node 3:c. It does not have the key 4. We go down the right subtree since the key we are looking for is greater than 3. Then we look at the node 4:d, and it has key 4 and we are done. So we looked at 2 nodes, 3:c and 4:d.



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
To find key 4, we need to look at nodes 1:a, 2:b, 3:c, and then 4:d. So 4 nodes in total.



Could not parse problem



Suppose instead of producing the value of a node with a given key, we would like to 
    produce the path that we took when we searched for that key. So the function that we 
    would like to design should produce a list of "L" or "R", and should end with either
    "Fail" or "Succeed", depending on whether we found the key.
  

    We're almost done designing this function. We have the signature, purpose, tests,
    and we've even started filling in the template.
Drag the expressions below, into the appropriate box on the partially filled in template.












        
correct_answer = {'1': 'second', '2': 'third', '3': 'fourth', '4': 'first'}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


    You're still not comfortable with the idea that trees are layed out from above to below in computer 
    science, instead you would prefer to have your trees layed out left to right. So the root is at the 
    left, it's children are to it's right etc. For example, with your new version the result of 
    evaluating:
(render-bst (make-node 100 "C"
                       (make-node  50  "L" false false)
                       (make-node 150 "CL" false false)))
would look something like:




Again, that would look a lot better with a little extra whitespace in it, but please ignore that for now.
By remembering the role that combination positions play in templates, you realize that the new function definition should be very close to the old function definition. Edit the current render function definition so that it has the new left-to-right behavior by dragging one or more function names from the scrollbar below, onto the  function definition where you want to replace one function name with another.









        
correct_answer = {'2': [[130, 75], 45], '4': [[200, 95], 50]}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference.










correct_answer = [
      {
      'draggables': ['R'], 
      'targets': ['Rt'], 
      'rule':'exact'
      },
      {
      'draggables': ['SR'], 
      'targets': ['SRt'], 
      'rule':'exact'
      },
      {
      'draggables': ['MR', 'MR'],
      'targets': ['MRt1', 'MRt2'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference. (The arrows are coloured to help distinguish between them).














correct_answer = [
      {
      'draggables': ['SR', 'SR'],
      'targets': ['SRt1', 'SRt2'],
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['MR', 'MR', 'MR', 'MR', 'MR', 'MR'],
      'targets': ['MRt1', 'MRt2', 'MRt3', 'MRt4', 'MRt5', 'MRt6'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Below are the templates for the above type comments. Select the correct number for each arrow to show the correspondence between the templates and the type comments










correct_answer = [
      {
      'draggables': ['1'], 
      'targets': ['t1'], 
      'rule':'exact'
      },
      {
      'draggables': ['2', '2'], 
      'targets': ['t2', 't4'], 
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['3'],
      'targets': ['t3'],
      'rule':'exact'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

 How many self-references are there?




ExplanationListOfPerson has a self-reference in it.
 


 
 How many references are there?





Explanation
 All remaining references are part of a mutual reference cycle, so there are 0. 


 How many mutual-references are there?




ExplanationListOfPerson has a reference to Person and vice versa.
 



Could not parse problem


Complete the function design for names-under-20--person and names-under-20--lop.







correct_answer = [{
      'draggables': ['cons', 'append'],
      'targets': ['t1', 't2'],
      'rule':'exact'
      }]
        
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Correctly label each arrow on the template with one of R, SR, MR, NH, NR, or NMR.













correct_answer = [{
    'draggables': ['NH', 'NR'],
    'targets': ['t1', 't4'],
    'rule':'exact'
},
{   'draggables': ['NMR', 'NMR'],
    'targets': ['t2', 't3'],
    'rule':'unordered_equal+number'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Design the function has-path? that consumes a BinaryTree and a Path. The function should produce true if following the path through the tree leads to a node. If the path leads to false or runs into false before reaching the end of the path, the function should produce false.

;; BinaryTree Path -> Boolean
;; prodcue true if following p through bt leads to a node; false otherwise

Lets design a cross product of type comments table to help us write tests for this function. Note Nat, Str and BT stand for Natural, String and BinaryTree.

   p        bt  | false | (make-node Nat Str BT BT)
----------------|-------|----------------------------
empty           |       |            
----------------|-------|----------------------------
(cons "L" Path) |       |            
----------------|-------|----------------------------
(cons "R" Path) |       |            

Recall:

(define BT1 (make-node 1 "a" false false))
(define BT4 (make-node 4 "d"
                       (make-node 2 "b")
                                  (make-node 1 "a" false false)
                                  (make-node 3 "c" false false))
                       (make-node 5 "e" false false))) 
We need at least one check-expect for every cell in the table.
What is the value of each check-expcet?
(check-expect (has-path? false empty) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path ends at false. 




Could not parse problem

(check-expect (has-path? false (list "L")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? false (list "R")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? BT1 empty) _____ )




Explanationhas-path should produce true if the path leads to a node. 




Could not parse problem

(check-expect (has-path? BT4 (list "R")) _____ )





Explanation
Following the given path leads to a node. 



Could not parse problem

(check-expect (has-path? BT4 (list "L" "L" "R")) _____ )





Explanation
Following the given path leads to false. 



Could not parse problem

Look at the table again:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|-------|--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|-------|--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))

How many cases can we reduce it to?





Explanation
The table can be reduced to these four cases:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|       |--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|       |--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))




Could not parse problem

In the practice problem find-person-starter.rkt we asked you to use local to improve your functions performance as the tree gets larger. Would the following be a correct use of local for that purpose?

(define (find--lop n lop)
  (local [(define try (find--person n (first lop)))]
    (cond [(empty? lop) false]
          [else
           (if (not (false? (find--person n (first lop))))
               (find--person n (first lop))
               (find--lop n (rest lop)))])))





Explanation
In this case the local has not been moved to surround the nearest expression that encloses all occurrences of the repeated computation. That would be around the if. Instead it moved outside of the cond answer the if appeared in. Try running it with this definition and see what happens. Step it carefully to be sure you understand why. 



Could not parse problem

Would this version that doesn't use local work?

(define try (find--person n (first lop)))

(define (find--lop n lop)
  (cond [(empty? lop) false]
        [else
         (if (not (false? try))
             try
             (find--lop n (rest lop)))]))





Explanation
The paramaters n and lop are not defined outside of find--lop, so this will not work either.



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Opening and ending tag mismatch: vertical line 243 and problem
Opening and ending tag mismatch: sequential line 231 and vertical
Opening and ending tag mismatch: chapter line 190 and sequential
Opening and ending tag mismatch: course line 1 and chapter
Extra content at the end of the document
[1] "XML is malformed — using htmlInternalTreeParse."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 4.4 MB

Retrieving results...
  Got page: 1; 54% done. Elapsed 9.57 s.
  Got page: 2; 100% done. Elapsed 14.12 s.
Got 72107 rows.

Total time taken 17.15 s.
Finished at 2017-06-30 21:53:37.
Saved to ./../data/SPD2x_2T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 12.8 s. Waiting...
Query done.
Processed: 572.4 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 14.19 s.
Got 376 rows.

Total time taken 14.2 s.
Finished at 2017-06-30 21:53:54.
Saved to ./../data/SPD2x_2T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 13.9 s. Waiting...
  Elapsed 24.37 s. Waiting...
Query done.
Processed: 536.3 MB

Retrieving results...
  Got page: 1; 4% done. Elapsed 35.01 s.
  Got page: 2; 8% done. Elapsed 39.14 s.
  Got page: 3; 12% done. Elapsed 44.31 s.
  Got page: 4; 16% done. Elapsed 49.11 s.
  Got page: 5; 19% done. Elapsed 53.51 s.
  Got page: 6; 23% done. Elapsed 58.61 s.
  Got page: 7; 27% done. Elapsed 63.18 s.
  Got page: 8; 31% done. Elapsed 68.69 s.
  Got page: 9; 35% done. Elapsed 73.21 s.
  Got page: 10; 39% done. Elapsed 79.61 s.
  Got page: 11; 43% done. Elapsed 84.79 s.
  Got page: 12; 47% done. Elapsed 89.0 s.
  Got page: 13; 51% done. Elapsed 94.57 s.
  Got page: 14; 54% done. Elapsed 102.74 s.
  Got page: 15; 58% done. Elapsed 107.18 s.
  Got page: 16; 62% done. Elapsed 112.51 s.
  Got page: 17; 66% done. Elapsed 120.01 s.
  Got page: 18; 70% done. Elapsed 124.58 s.
  Got page: 19; 74% done. Elapsed 129.43 s.
  Got page: 20; 78% done. Elapsed 138.15 s.
  Got page: 21; 82% done. Elapsed 143.58 s.
  Got page: 22; 86% done. Elapsed 149.06 s.
  Got page: 23; 89% done. Elapsed 155.04 s.
  Got page: 24; 93% done. Elapsed 160.84 s.
  Got page: 25; 97% done. Elapsed 167.06 s.
  Got page: 26; 100% done. Elapsed 170.81 s.
Got 600223 rows.

Total time taken 193.25 s.
Finished at 2017-06-30 21:57:08.
Saved to ./../data/SPD2x_2T2016/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.9 KB

Retrieving results...
Got 44 rows.

Total time taken 0.97 s.
Finished at 2017-06-30 21:57:20.
Saved to ./../data/SPD2x_2T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 702.3 KB

Retrieving results...
Got 2085 rows.

Total time taken 1.95 s.
Finished at 2017-06-30 21:57:23.
Saved to ./../data/SPD2x_2T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 436.2 KB

Retrieving results...
Got 390 rows.

Total time taken 1.45 s.
Finished at 2017-06-30 21:57:26.
Saved to ./../data/SPD2x_2T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 468.9 KB

Retrieving results...
Got 396 rows.

Total time taken 1.13 s.
Finished at 2017-06-30 21:57:28.
Saved to ./../data/SPD2x_2T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1013.6 KB

Retrieving results...
Got 6218 rows.

Total time taken 1.95 s.
Finished at 2017-06-30 21:57:32.
Saved to ./../data/SPD2x_2T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 47.6 KB

Retrieving results...
Got 521 rows.

Total time taken 0.73 s.
Finished at 2017-06-30 21:57:34.
Saved to ./../data/SPD2x_2T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 46.4 MB

Retrieving results...
  Got page: 1; 66% done. Elapsed 8.63 s.
  Got page: 2; 100% done. Elapsed 11.62 s.
Got 88943 rows.

Total time taken 12.85 s.
Finished at 2017-06-30 21:57:48.
Saved to ./../data/SPD2x_2T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 170.3 KB

Retrieving results...
Got 521 rows.

Total time taken 1.02 s.
Finished at 2017-06-30 21:57:50.
Saved to ./../data/SPD2x_2T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 518.6 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 11.03 s.
Got 7754 rows.

Total time taken 11.15 s.
Finished at 2017-06-30 21:58:03.
Saved to ./../data/SPD2x_2T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.42 s. Waiting...
  Elapsed 22.81 s. Waiting...
  Elapsed 33.21 s. Waiting...
Query done.
Processed: 109.3 MB

Retrieving results...
  Got page: 1; 9% done. Elapsed 45.58 s.
  Got page: 2; 16% done. Elapsed 51.3 s.
  Got page: 3; 24% done. Elapsed 57.71 s.
  Got page: 4; 33% done. Elapsed 63.17 s.
  Got page: 5; 42% done. Elapsed 69.24 s.
  Got page: 6; 50% done. Elapsed 74.99 s.
  Got page: 7; 59% done. Elapsed 82.61 s.
  Got page: 8; 67% done. Elapsed 89.33 s.
  Got page: 9; 76% done. Elapsed 95.48 s.
  Got page: 10; 84% done. Elapsed 101.9 s.
  Got page: 11; 93% done. Elapsed 109.53 s.
  Got page: 12; 100% done. Elapsed 115.82 s.
Got 619086 rows.

Total time taken 129.33 s.
Finished at 2017-06-30 22:00:14.
Saved to ./../data/SPD2x_2T2016/page_dirt.csv
Could not parse problem

Here is the signature and purpose for the function that produces true if the list contains a negative number.
;; ListOfNumber -> Boolean
;; produce true if a lon contains a negative number
What is the result of the following tests?
(check-expect (contains-negative? (cons 1 empty)) _____)





Explanation
The list has only 1 element and it is positive.



Could not parse problem

(check-expect (contains-negative? (cons 1 (cons -1.5 empty))) _____)





Explanation
The second element of the list is negative.



Could not parse problem

(check-expect (contains-negative? empty) _____)





Explanation
The list is empty, so it contains no negative numbers.



Could not parse problem

Is this self-referential type comment well-formed?
;; ListOfNumber is one of:
;; - (cons Number ListOfNumber)





Explanation
Although it has a self-referential case, it does not have a base case, so it is not well formed.



Could not parse problem

Is this self-referential type comment well-formed?
;; NonEmptyListOfNumber is one of:
;; - (cons Number empty)
;; - (cons Number NonEmptyListOfNumber)





Explanation
This is a type comment for a non-empty list - a list that at it's shortest just has a single element. It is well-formed because it has both a base case which has no self-reference: (cons Number empty), and a self-referential case: (cons Number NonEmptyListOfNumber).



Could not parse problem

Choose the part of the template that results from each highlighted part of the Type Comment.






Explanation
ListOfNumber has two cases, so we need a cond expression. empty is the first case, and it is atomic distinct, so the answer clause is (...).



Could not parse problem







Explanation
(cons Number ListOfNumber) is compound, so we separate it into two parts, the first being (first lon).



Could not parse problem







Explanation
The second part of the compound is (rest lon) which is ListOfNumber. This is a self-reference in the type comment, so (rest lon) is wrapped in a call to fn-for-lon to form a natural recursion.



Could not parse problem


Drag the template rules to create the correct template rules for foo. Only use as many template rules as are necessary.











correct_answer = [{
    'draggables': ['compound', 'atomic', 'reference' ],
    'targets': ['t1', 't2', 't3' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    



Explanation
Foo is compound. The first field is a simple atomic type, Integer, and the second field is a reference to a non-primitive type.



Could not parse problem


Use the options below to create the correct template rules for ListOfConcert.
You can use up to six template rules, but you do not need to use all the space.
Note, if you drap the options out of the bar at the bottom, they become bigger and you will be able to read the template rules.
















correct_answer = [{
    'draggables': ['2', '3', '4', '5', '6'],
    'targets': ['t1', 't2', 't3', 't4', 't5' ],
    'rule':'exact'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

The factorial of a natural number n is n*n-1*n-2*...1. So factorial of 3 is 3*2*1*1. Let's design a function called fact to compute the factorial.

factorial of 0 is 1
factorial of n is n*factorial(n-1)

Here is the signature and purpose for fact:
;; Natural -> Natural
;; compute n * n-1 * n-2 * ... * 1
What is the result of each check-expect?
(check-expect (fact 0) ____ )



(check-expect (fact 3) ____ )





Explanation
0 factorial is 1, so (fact 0) should produce 1. 
3 factorial is 3*2*1 whihc is 6.



Could not parse problem

In the two boxes below, complete the two cases in the types comment for the data definition for a list of images. 

;; ListOfImage is one of:




















Explanation
The correct type comment for a list of images is 
;; ListOfImage is one of:
;; - empty
;; - (cons Image ListOfImage)



Could not parse problem

After we run the program, we notice that one test in arrange-strings is still failing. Are we done working on layout-strings?






Explanation
We didn't complete the sorting part of this program, so that test for arrange-strings should fail. But since the tests for layout-strings are passing we are ready to move on to completing the rest of the program. 



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
First we look at the root, the node 3:c. It does not have the key 4. We go down the right subtree since the key we are looking for is greater than 3. Then we look at the node 4:d, and it has key 4 and we are done. So we looked at 2 nodes, 3:c and 4:d.



Could not parse problem

How many nodes do we have to look at in this BST to find the node with key 4? Include the node with key 4 in your count.






Explanation
To find key 4, we need to look at nodes 1:a, 2:b, 3:c, and then 4:d. So 4 nodes in total.



Could not parse problem



Suppose instead of producing the value of a node with a given key, we would like to 
    produce the path that we took when we searched for that key. So the function that we 
    would like to design should produce a list of "L" or "R", and should end with either
    "Fail" or "Succeed", depending on whether we found the key.
  

    We're almost done designing this function. We have the signature, purpose, tests,
    and we've even started filling in the template.
Drag the expressions below, into the appropriate box on the partially filled in template.












        
correct_answer = {'1': 'second', '2': 'third', '3': 'fourth', '4': 'first'}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


    You're still not comfortable with the idea that trees are layed out from above to below in computer 
    science, instead you would prefer to have your trees layed out left to right. So the root is at the 
    left, it's children are to it's right etc. For example, with your new version the result of 
    evaluating:
(render-bst (make-node 100 "C"
                       (make-node  50  "L" false false)
                       (make-node 150 "CL" false false)))
would look something like:




Again, that would look a lot better with a little extra whitespace in it, but please ignore that for now.
By remembering the role that combination positions play in templates, you realize that the new function definition should be very close to the old function definition. Edit the current render function definition so that it has the new left-to-right behavior by dragging one or more function names from the scrollbar below, onto the  function definition where you want to replace one function name with another.









        
correct_answer = {'2': [[130, 75], 45], '4': [[200, 95], 50]}

if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
        





Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference.










correct_answer = [
      {
      'draggables': ['R'], 
      'targets': ['Rt'], 
      'rule':'exact'
      },
      {
      'draggables': ['SR'], 
      'targets': ['SRt'], 
      'rule':'exact'
      },
      {
      'draggables': ['MR', 'MR'],
      'targets': ['MRt1', 'MRt2'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Label each arrow with either R for Reference, SR for Self-Reference or MR for Mutual-Reference. (The arrows are coloured to help distinguish between them).














correct_answer = [
      {
      'draggables': ['SR', 'SR'],
      'targets': ['SRt1', 'SRt2'],
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['MR', 'MR', 'MR', 'MR', 'MR', 'MR'],
      'targets': ['MRt1', 'MRt2', 'MRt3', 'MRt4', 'MRt5', 'MRt6'],
      'rule':'unordered_equal+number'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Below are the templates for the above type comments. Select the correct number for each arrow to show the correspondence between the templates and the type comments










correct_answer = [
      {
      'draggables': ['1'], 
      'targets': ['t1'], 
      'rule':'exact'
      },
      {
      'draggables': ['2', '2'], 
      'targets': ['t2', 't4'], 
      'rule':'unordered_equal+number'
      },
      {
      'draggables': ['3'],
      'targets': ['t3'],
      'rule':'exact'
      }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

 How many self-references are there?




ExplanationListOfPerson has a self-reference in it.
 


 
 How many references are there?





Explanation
 All remaining references are part of a mutual reference cycle, so there are 0. 


 How many mutual-references are there?




ExplanationListOfPerson has a reference to Person and vice versa.
 



Could not parse problem


Complete the function design for names-under-20--person and names-under-20--lop.







correct_answer = [{
      'draggables': ['cons', 'append'],
      'targets': ['t1', 't2'],
      'rule':'exact'
      }]
        
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem


Correctly label each arrow on the template with one of R, SR, MR, NH, NR, or NMR.













correct_answer = [{
    'draggables': ['NH', 'NR'],
    'targets': ['t1', 't4'],
    'rule':'exact'
},
{   'draggables': ['NMR', 'NMR'],
    'targets': ['t2', 't3'],
    'rule':'unordered_equal+number'
}]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

Design the function has-path? that consumes a BinaryTree and a Path. The function should produce true if following the path through the tree leads to a node. If the path leads to false or runs into false before reaching the end of the path, the function should produce false.

;; BinaryTree Path -> Boolean
;; prodcue true if following p through bt leads to a node; false otherwise

Lets design a cross product of type comments table to help us write tests for this function. Note Nat, Str and BT stand for Natural, String and BinaryTree.

   p        bt  | false | (make-node Nat Str BT BT)
----------------|-------|----------------------------
empty           |       |            
----------------|-------|----------------------------
(cons "L" Path) |       |            
----------------|-------|----------------------------
(cons "R" Path) |       |            

Recall:

(define BT1 (make-node 1 "a" false false))
(define BT4 (make-node 4 "d"
                       (make-node 2 "b")
                                  (make-node 1 "a" false false)
                                  (make-node 3 "c" false false))
                       (make-node 5 "e" false false))) 
We need at least one check-expect for every cell in the table.
What is the value of each check-expcet?
(check-expect (has-path? false empty) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path ends at false. 




Could not parse problem

(check-expect (has-path? false (list "L")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? false (list "R")) _____ )




Explanationhas-path? should produce false if the path leads to a false binary tree. Here the path hits false before it ends.




Could not parse problem

(check-expect (has-path? BT1 empty) _____ )




Explanationhas-path should produce true if the path leads to a node. 




Could not parse problem

(check-expect (has-path? BT4 (list "R")) _____ )





Explanation
Following the given path leads to a node. 



Could not parse problem

(check-expect (has-path? BT4 (list "L" "L" "R")) _____ )





Explanation
Following the given path leads to false. 



Could not parse problem

Look at the table again:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|-------|--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|-------|--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))

How many cases can we reduce it to?





Explanation
The table can be reduced to these four cases:

                | false |      (make-node Nat Str BT BT)
----------------|-------|--------------------------------------
      empty     | false |                true
----------------|       |--------------------------------------
(cons "L" Path) | false | (has-path? <left-child> (rest path))
----------------|       |--------------------------------------
(cons "R" Path) | false | (has-path? <right-child> (rest path))




Could not parse problem

In the practice problem find-person-starter.rkt we asked you to use local to improve your functions performance as the tree gets larger. Would the following be a correct use of local for that purpose?

(define (find--lop n lop)
  (local [(define try (find--person n (first lop)))]
    (cond [(empty? lop) false]
          [else
           (if (not (false? (find--person n (first lop))))
               (find--person n (first lop))
               (find--lop n (rest lop)))])))





Explanation
In this case the local has not been moved to surround the nearest expression that encloses all occurrences of the repeated computation. That would be around the if. Instead it moved outside of the cond answer the if appeared in. Try running it with this definition and see what happens. Step it carefully to be sure you understand why. 



Could not parse problem

Would this version that doesn't use local work?

(define try (find--person n (first lop)))

(define (find--lop n lop)
  (cond [(empty? lop) false]
        [else
         (if (not (false? try))
             try
             (find--lop n (rest lop)))]))





Explanation
The paramaters n and lop are not defined outside of find--lop, so this will not work either.



Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Opening and ending tag mismatch: vertical line 207 and problem
Opening and ending tag mismatch: sequential line 195 and vertical
Opening and ending tag mismatch: chapter line 154 and sequential
Opening and ending tag mismatch: course line 1 and chapter
Extra content at the end of the document
[1] "XML is malformed — using htmlInternalTreeParse."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 1.5 MB

Retrieving results...
Got 23037 rows.

Total time taken 6.08 s.
Finished at 2017-06-30 22:05:49.
Saved to ./../data/SPD3x_2T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 12.97 s. Waiting...
  Elapsed 23.42 s. Waiting...
  Elapsed 33.92 s. Waiting...
  Elapsed 44.3 s. Waiting...
  Elapsed 54.7 s. Waiting...
  Elapsed 65.08 s. Waiting...
  Elapsed 75.59 s. Waiting...
  Elapsed 86.02 s. Waiting...
  Elapsed 96.39 s. Waiting...
Query done.
Processed: 239.7 MB

Retrieving results...
Got 0 rows.

Total time taken 106.03 s.
Finished at 2017-06-30 22:07:37.
Saved to ./../data/SPD3x_2T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 13.25 s. Waiting...
Query done.
Processed: 224.5 MB

Retrieving results...
  Got page: 1; 9% done. Elapsed 27.67 s.
  Got page: 2; 17% done. Elapsed 32.12 s.
  Got page: 3; 26% done. Elapsed 36.6 s.
  Got page: 4; 34% done. Elapsed 41.39 s.
  Got page: 5; 43% done. Elapsed 46.87 s.
  Got page: 6; 51% done. Elapsed 51.66 s.
  Got page: 7; 60% done. Elapsed 56.72 s.
  Got page: 8; 68% done. Elapsed 62.44 s.
  Got page: 9; 77% done. Elapsed 67.61 s.
  Got page: 10; 86% done. Elapsed 72.67 s.
  Got page: 11; 94% done. Elapsed 78.75 s.
  Got page: 12; 100% done. Elapsed 82.57 s.
Got 272794 rows.

Total time taken 97.1 s.
Finished at 2017-06-30 22:09:16.
Saved to ./../data/SPD3x_2T2016/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.0 KB

Retrieving results...
Got 47 rows.

Total time taken 0.94 s.
Finished at 2017-06-30 22:09:23.
Saved to ./../data/SPD3x_2T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 633.0 KB

Retrieving results...
Got 1809 rows.

Total time taken 1.57 s.
Finished at 2017-06-30 22:09:26.
Saved to ./../data/SPD3x_2T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 349.5 KB

Retrieving results...
Got 221 rows.

Total time taken 1.72 s.
Finished at 2017-06-30 22:09:29.
Saved to ./../data/SPD3x_2T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 345.4 KB

Retrieving results...
Got 223 rows.

Total time taken 1.31 s.
Finished at 2017-06-30 22:09:31.
Saved to ./../data/SPD3x_2T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 629.4 KB

Retrieving results...
Got 3382 rows.

Total time taken 1.64 s.
Finished at 2017-06-30 22:09:35.
Saved to ./../data/SPD3x_2T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 35.3 KB

Retrieving results...
Got 382 rows.

Total time taken 0.75 s.
Finished at 2017-06-30 22:09:37.
Saved to ./../data/SPD3x_2T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 17.4 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 8.15 s.
Got 35745 rows.

Total time taken 8.65 s.
Finished at 2017-06-30 22:09:47.
Saved to ./../data/SPD3x_2T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 124.2 KB

Retrieving results...
Got 382 rows.

Total time taken 0.9 s.
Finished at 2017-06-30 22:09:50.
Saved to ./../data/SPD3x_2T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 229.7 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 9.25 s.
Got 3846 rows.

Total time taken 9.29 s.
Finished at 2017-06-30 22:10:01.
Saved to ./../data/SPD3x_2T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.37 s. Waiting...
Query done.
Processed: 50.1 MB

Retrieving results...
  Got page: 1; 18% done. Elapsed 20.1 s.
  Got page: 2; 37% done. Elapsed 25.34 s.
  Got page: 3; 55% done. Elapsed 30.49 s.
  Got page: 4; 74% done. Elapsed 36.34 s.
  Got page: 5; 92% done. Elapsed 41.5 s.
  Got page: 6; 100% done. Elapsed 44.75 s.
Got 287689 rows.

Total time taken 50.85 s.
Finished at 2017-06-30 22:10:53.
Saved to ./../data/SPD3x_2T2016/page_dirt.csv
Could not parse problem


Use the pieces below to construct the signature for filter2.













correct_answer = [
    {
      'draggables': ['3'],
      'targets': ['t2', 't3'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['7'],
      'targets': ['t1'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

The remaining questions deal with Problem 3 in the starter file
How many arguments does your fold function consume?





Explanation
There should be 9 arguments. If you answered this question incorrectly, please take another look at your solution before attempting the remaining questions.



Could not parse problem

Questions 7-8 deal with Problem 2 in the starter file. 
While it may be possible to get to these answers using combinatorics, we encourage you to use the solve function you were asked to design. 
How many boards are reachable from B0?





Explanation
There are 512 possible ways to fill the empty board



Could not parse problem

How many boards are reachable from B1?





Explanation
There are 8 possible ways to fill B1



Could not parse problem

Questions 9-10 deal with Problem 3 in the starter file. 
How many valid boards (using the description of valid from Problem 3) are reachable from B0?





Explanation
There are 126 possible ways to fill the empty board with 5 Xs and 4 Os



Could not parse problem

Questions 9-10 deal with Problem 3 in the starter. 
How many valid boards (using the description of valid from Problem 3) are reachable from B1?





Explanation
There are 3 possible ways to complete this board so it has 5 Xs and 4 Os



Could not parse problem

In adding the accumulator paramater, we have missed a spot where it should be added. Click to move the green dot to the location of the missing accumulator paramater.





Explanation
We need to add acc at all of the ...s, as well as adding an extra paramater to every call of number-list.



Could not parse problem


Drag the pieces of code from the scroll bar to complete the refactored design of fact. You do not need to use every piece of code, and you can use each piece more than once.












correct_answer = [{
    'draggables': ['(* n rsf)', '1'],
    'targets': ['t(* n rsf)', 't1'],
    'rule':'exact'
    },  
     {
    'draggables': ['rsf'],
    'targets': ['trsf1', 'trsf2'],
    'rule':'unordered_equal'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Opening and ending tag mismatch: vertical line 600 and problem
Opening and ending tag mismatch: sequential line 543 and vertical
Opening and ending tag mismatch: chapter line 134 and sequential
Opening and ending tag mismatch: course line 1 and chapter
Extra content at the end of the document
[1] "XML is malformed — using htmlInternalTreeParse."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
Query done.
Processed: 995.0 KB

Retrieving results...
Got 14358 rows.

Total time taken 5.5 s.
Finished at 2017-06-30 22:13:56.
Saved to ./../data/SPD3x_3T2015/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 14.34 s. Waiting...
Query done.
Processed: 210.7 MB

Retrieving results...
Got 0 rows.

Total time taken 24.4 s.
Finished at 2017-06-30 22:14:22.
Saved to ./../data/SPD3x_3T2015/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 14.29 s. Waiting...
  Elapsed 24.7 s. Waiting...
Query done.
Processed: 193.0 MB

Retrieving results...
  Got page: 1; 8% done. Elapsed 39.01 s.
  Got page: 2; 16% done. Elapsed 43.28 s.
  Got page: 3; 24% done. Elapsed 47.24 s.
  Got page: 4; 33% done. Elapsed 52.53 s.
  Got page: 5; 41% done. Elapsed 57.15 s.
  Got page: 6; 49% done. Elapsed 62.0 s.
  Got page: 7; 57% done. Elapsed 66.77 s.
  Got page: 8; 65% done. Elapsed 71.84 s.
  Got page: 9; 73% done. Elapsed 77.28 s.
  Got page: 10; 81% done. Elapsed 83.84 s.
  Got page: 11; 90% done. Elapsed 88.78 s.
  Got page: 12; 98% done. Elapsed 92.69 s.
  Got page: 13; 100% done. Elapsed 94.3 s.
Got 286465 rows.

Total time taken 106.04 s.
Finished at 2017-06-30 22:16:09.
Saved to ./../data/SPD3x_3T2015/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 3.0 KB

Retrieving results...
Got 47 rows.

Total time taken 0.97 s.
Finished at 2017-06-30 22:16:17.
Saved to ./../data/SPD3x_3T2015/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 601.0 KB

Retrieving results...
Got 3209 rows.

Total time taken 1.97 s.
Finished at 2017-06-30 22:16:20.
Saved to ./../data/SPD3x_3T2015/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 365.6 KB

Retrieving results...
Got 360 rows.

Total time taken 2.75 s.
Finished at 2017-06-30 22:16:24.
Saved to ./../data/SPD3x_3T2015/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 389.8 KB

Retrieving results...
Got 330 rows.

Total time taken 1.12 s.
Finished at 2017-06-30 22:16:27.
Saved to ./../data/SPD3x_3T2015/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 860.4 KB

Retrieving results...
Got 6158 rows.

Total time taken 1.67 s.
Finished at 2017-06-30 22:16:30.
Saved to ./../data/SPD3x_3T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 35.2 KB

Retrieving results...
Got 382 rows.

Total time taken 0.78 s.
Finished at 2017-06-30 22:16:32.
Saved to ./../data/SPD3x_3T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 11.2 MB

Retrieving results...
Got 21693 rows.

Total time taken 3.79 s.
Finished at 2017-06-30 22:16:37.
Saved to ./../data/SPD3x_3T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 124.1 KB

Retrieving results...
Got 382 rows.

Total time taken 0.92 s.
Finished at 2017-06-30 22:16:39.
Saved to ./../data/SPD3x_3T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 23.6 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 10.23 s.
Got 101 rows.

Total time taken 10.24 s.
Finished at 2017-06-30 22:16:51.
Saved to ./../data/SPD3x_3T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 13.66 s. Waiting...
Query done.
Processed: 20.2 MB

Retrieving results...
  Got page: 1; 46% done. Elapsed 23.85 s.
  Got page: 2; 92% done. Elapsed 29.98 s.
  Got page: 3; 100% done. Elapsed 31.59 s.
Got 118182 rows.

Total time taken 33.52 s.
Finished at 2017-06-30 22:17:26.
Saved to ./../data/SPD3x_3T2015/page_dirt.csv
Could not parse problem


Use the pieces below to construct the signature for filter2.













correct_answer = [
    {
      'draggables': ['3'],
      'targets': ['t2', 't3'],
      'rule': 'unordered_equal'
    },
    {
      'draggables': ['7'],
      'targets': ['t1'],
      'rule': 'exact'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Could not parse problem

The remaining questions deal with Problem 3 in the starter file
How many arguments does your fold function consume?





Explanation
There should be 9 arguments. If you answered this question incorrectly, please take another look at your solution before attempting the remaining questions.



Could not parse problem

Questions 7-8 deal with Problem 2 in the starter file. 
While it may be possible to get to these answers using combinatorics, we encourage you to use the solve function you were asked to design. 
How many boards are reachable from B0?





Explanation
There are 512 possible ways to fill the empty board



Could not parse problem

How many boards are reachable from B1?





Explanation
There are 8 possible ways to fill B1



Could not parse problem

Questions 9-10 deal with Problem 3 in the starter file. 
How many valid boards (using the description of valid from Problem 3) are reachable from B0?





Explanation
There are 126 possible ways to fill the empty board with 5 Xs and 4 Os



Could not parse problem

Questions 9-10 deal with Problem 3 in the starter. 
How many valid boards (using the description of valid from Problem 3) are reachable from B1?





Explanation
There are 3 possible ways to complete this board so it has 5 Xs and 4 Os



Could not parse problem

In adding the accumulator paramater, we have missed a spot where it should be added. Click to move the green dot to the location of the missing accumulator paramater.





Explanation
We need to add acc at all of the ...s, as well as adding an extra paramater to every call of number-list.



Could not parse problem


Drag the pieces of code from the scroll bar to complete the refactored design of fact. You do not need to use every piece of code, and you can use each piece more than once.












correct_answer = [{
    'draggables': ['(* n rsf)', '1'],
    'targets': ['t(* n rsf)', 't1'],
    'rule':'exact'
    },  
     {
    'draggables': ['rsf'],
    'targets': ['trsf1', 'trsf2'],
    'rule':'unordered_equal'
    }]
if draganddrop.grade(submission[0], correct_answer):
    correct = ['correct']
else:
    correct = ['incorrect']
    


Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
Double hyphen within comment: <!-- 
Double hyphen within comment: <!-- --
Double hyphen within comment: <!-- ----
Double hyphen within comment: <!-- ------
Double hyphen within comment: <!-- --------
Double hyphen within comment: <!-- ----------
Double hyphen within comment: <!-- ------------
Double hyphen within comment: <!-- --------------
Double hyphen within comment: <!-- ----------------
Double hyphen within comment: <!-- ------------------
Double hyphen within comment: <!-- --------------------
[1] "XML is malformed — using htmlInternalTreeParse."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
Query done.
Processed: 10.7 MB

Retrieving results...
  Got page: 1; 22% done. Elapsed 12.39 s.
  Got page: 2; 44% done. Elapsed 17.47 s.
  Got page: 3; 66% done. Elapsed 23.21 s.
  Got page: 4; 88% done. Elapsed 27.97 s.
  Got page: 5; 100% done. Elapsed 30.92 s.
Got 175813 rows.

Total time taken 35.5 s.
Finished at 2017-06-30 22:20:00.
Saved to ./../data/UseGen_1x_1T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 12.94 s. Waiting...
Query done.
Processed: 2.7 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 16.53 s.
Got 731 rows.

Total time taken 16.55 s.
Finished at 2017-06-30 22:20:21.
Saved to ./../data/UseGen_1x_1T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 13.77 s. Waiting...
Requesting query... ok.
Query running...
Query done.
Processed: 8.1 KB

Retrieving results...
Got 137 rows.

Total time taken 0.9 s.
Finished at 2017-06-30 22:20:49.
Saved to ./../data/UseGen_1x_1T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.0 MB

Retrieving results...
Got 4531 rows.

Total time taken 2.61 s.
Finished at 2017-06-30 22:20:53.
Saved to ./../data/UseGen_1x_1T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.5 MB

Retrieving results...
Got 2948 rows.

Total time taken 3.54 s.
Finished at 2017-06-30 22:20:58.
Saved to ./../data/UseGen_1x_1T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.5 MB

Retrieving results...
Got 343 rows.

Total time taken 1.17 s.
Finished at 2017-06-30 22:21:01.
Saved to ./../data/UseGen_1x_1T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 4.4 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 7.39 s.
Got 33850 rows.

Total time taken 7.84 s.
Finished at 2017-06-30 22:21:10.
Saved to ./../data/UseGen_1x_1T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 92.9 KB

Retrieving results...
Got 900 rows.

Total time taken 1.09 s.
Finished at 2017-06-30 22:21:13.
Saved to ./../data/UseGen_1x_1T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 142.0 MB

Retrieving results...
  Got page: 1; 26% done. Elapsed 12.81 s.
  Got page: 2; 51% done. Elapsed 18.75 s.
  Got page: 3; 77% done. Elapsed 25.05 s.
  Got page: 4; 100% done. Elapsed 30.17 s.
Got 227362 rows.

Total time taken 33.54 s.
Finished at 2017-06-30 22:21:47.
Saved to ./../data/UseGen_1x_1T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 303.3 KB

Retrieving results...
Got 900 rows.

Total time taken 1.04 s.
Finished at 2017-06-30 22:21:52.
Saved to ./../data/UseGen_1x_1T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.4 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 11.23 s.
Got 3756 rows.

Total time taken 11.27 s.
Finished at 2017-06-30 22:22:05.
Saved to ./../data/UseGen_1x_1T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.37 s. Waiting...
Could not parse Checkbox Group

Below are representations of transcription. Choose all that are correct. 

ABCD

Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 5.4 MB

Retrieving results...
  Got page: 1; 35% done. Elapsed 10.85 s.
  Got page: 2; 71% done. Elapsed 16.76 s.
  Got page: 3; 100% done. Elapsed 21.92 s.
Got 110042 rows.

Total time taken 26.45 s.
Finished at 2017-06-30 22:23:28.
Saved to ./../data/UseGen_1x_3T2015/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 8.81 s. Waiting...
  Elapsed 19.27 s. Waiting...
  Elapsed 29.36 s. Waiting...
Query done.
Processed: 1.8 GB

Retrieving results...
  Got page: 1; 100% done. Elapsed 30.53 s.
Got 562 rows.

Total time taken 30.55 s.
Finished at 2017-06-30 22:24:02.
Saved to ./../data/UseGen_1x_3T2015/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 15.2 s. Waiting...
  Elapsed 25.63 s. Waiting...
  Elapsed 36.07 s. Waiting...
  Elapsed 46.45 s. Waiting...
  Elapsed 56.9 s. Waiting...
  Elapsed 67.32 s. Waiting...
  Elapsed 77.76 s. Waiting...
  Elapsed 88.13 s. Waiting...
  Elapsed 98.63 s. Waiting...
  Elapsed 109.15 s. Waiting...
Query done.
Processed: 1.7 GB

Retrieving results...
  Got page: 1; 1% done. Elapsed 118.36 s.
  Got page: 2; 1% done. Elapsed 124.04 s.
  Got page: 3; 2% done. Elapsed 129.43 s.
  Got page: 4; 2% done. Elapsed 134.01 s.
  Got page: 5; 3% done. Elapsed 139.11 s.
  Got page: 6; 4% done. Elapsed 143.73 s.
  Got page: 7; 4% done. Elapsed 147.85 s.
  Got page: 8; 5% done. Elapsed 153.81 s.
  Got page: 9; 5% done. Elapsed 159.44 s.
  Got page: 10; 6% done. Elapsed 165.43 s.
  Got page: 11; 6% done. Elapsed 170.43 s.
  Got page: 12; 7% done. Elapsed 175.36 s.
  Got page: 13; 8% done. Elapsed 180.49 s.
  Got page: 14; 8% done. Elapsed 185.05 s.
  Got page: 15; 9% done. Elapsed 190.72 s.
  Got page: 16; 9% done. Elapsed 196.57 s.
  Got page: 17; 10% done. Elapsed 202.99 s.
  Got page: 18; 11% done. Elapsed 209.65 s.
  Got page: 19; 11% done. Elapsed 214.0 s.
  Got page: 20; 12% done. Elapsed 218.95 s.
  Got page: 21; 12% done. Elapsed 225.68 s.
  Got page: 22; 13% done. Elapsed 230.73 s.
  Got page: 23; 14% done. Elapsed 235.99 s.
  Got page: 24; 14% done. Elapsed 241.88 s.
  Got page: 25; 15% done. Elapsed 246.86 s.
  Got page: 26; 15% done. Elapsed 252.13 s.
  Got page: 27; 16% done. Elapsed 258.73 s.
  Got page: 28; 16% done. Elapsed 263.28 s.
  Got page: 29; 17% done. Elapsed 268.19 s.
  Got page: 30; 18% done. Elapsed 274.64 s.
  Got page: 31; 18% done. Elapsed 280.02 s.
  Got page: 32; 19% done. Elapsed 286.44 s.
Requesting query... ok.
Query running...
Query done.
Processed: 8.1 KB

Retrieving results...
Got 137 rows.

Total time taken 1.42 s.
Finished at 2017-06-30 22:29:22.
Saved to ./../data/UseGen_1x_3T2015/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 588.1 KB

Retrieving results...
Got 3056 rows.

Total time taken 2.45 s.
Finished at 2017-06-30 22:29:26.
Saved to ./../data/UseGen_1x_3T2015/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.6 MB

Retrieving results...
Got 3479 rows.

Total time taken 3.62 s.
Finished at 2017-06-30 22:29:31.
Saved to ./../data/UseGen_1x_3T2015/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.6 MB

Retrieving results...
Got 754 rows.

Total time taken 1.35 s.
Finished at 2017-06-30 22:29:34.
Saved to ./../data/UseGen_1x_3T2015/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 5.0 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 7.87 s.
Got 42176 rows.

Total time taken 8.4 s.
Finished at 2017-06-30 22:29:44.
Saved to ./../data/UseGen_1x_3T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 75.0 KB

Retrieving results...
Got 737 rows.

Total time taken 1.35 s.
Finished at 2017-06-30 22:29:47.
Saved to ./../data/UseGen_1x_3T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 74.1 MB

Retrieving results...
  Got page: 1; 52% done. Elapsed 9.16 s.
  Got page: 2; 100% done. Elapsed 13.74 s.
Got 112776 rows.

Total time taken 15.56 s.
Finished at 2017-06-30 22:30:04.
Saved to ./../data/UseGen_1x_3T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 246.6 KB

Retrieving results...
Got 737 rows.

Total time taken 1.29 s.
Finished at 2017-06-30 22:30:08.
Saved to ./../data/UseGen_1x_3T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 16.1 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 11.12 s.
Got 34 rows.

Total time taken 11.13 s.
Finished at 2017-06-30 22:30:20.
Saved to ./../data/UseGen_1x_3T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.87 s. Waiting...
  Elapsed 23.38 s. Waiting...
  Elapsed 33.9 s. Waiting...
Query done.
Processed: 240.4 MB

Retrieving results...
  Got page: 1; 3% done. Elapsed 41.59 s.
  Got page: 2; 7% done. Elapsed 47.56 s.
  Got page: 3; 10% done. Elapsed 52.95 s.
  Got page: 4; 14% done. Elapsed 59.47 s.
  Got page: 5; 17% done. Elapsed 64.35 s.
  Got page: 6; 21% done. Elapsed 70.65 s.
  Got page: 7; 24% done. Elapsed 76.64 s.
  Got page: 8; 28% done. Elapsed 81.53 s.
  Got page: 9; 31% done. Elapsed 87.51 s.
  Got page: 10; 35% done. Elapsed 93.83 s.
  Got page: 11; 38% done. Elapsed 99.89 s.
  Got page: 12; 41% done. Elapsed 105.01 s.
  Got page: 13; 45% done. Elapsed 111.3 s.
  Got page: 14; 48% done. Elapsed 118.09 s.
  Got page: 15; 52% done. Elapsed 123.79 s.
  Got page: 16; 55% done. Elapsed 129.82 s.
  Got page: 17; 59% done. Elapsed 136.22 s.
  Got page: 18; 62% done. Elapsed 142.18 s.
  Got page: 19; 66% done. Elapsed 149.17 s.
  Got page: 20; 69% done. Elapsed 154.67 s.
  Got page: 21; 73% done. Elapsed 159.51 s.
  Got page: 22; 76% done. Elapsed 167.19 s.
  Got page: 23; 80% done. Elapsed 171.86 s.
  Got page: 24; 83% done. Elapsed 177.28 s.
  Got page: 25; 87% done. Elapsed 182.73 s.
  Got page: 26; 90% done. Elapsed 189.41 s.
  Got page: 27; 94% done. Elapsed 196.41 s.
  Got page: 28; 97% done. Elapsed 202.58 s.
[1] "Reading in the necessary files..."
Requesting query... ok.
Query running...
Query done.
Processed: 2.6 MB

Retrieving results...
  Got page: 1; 88% done. Elapsed 9.51 s.
  Got page: 2; 100% done. Elapsed 10.63 s.
Got 44238 rows.

Total time taken 12.25 s.
Finished at 2017-06-30 22:35:15.
Saved to ./../data/UseGen_2x_1T2016/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 13.83 s. Waiting...
Query done.
Processed: 638.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 17.5 s.
Got 170 rows.

Total time taken 17.51 s.
Finished at 2017-06-30 22:35:34.
Saved to ./../data/UseGen_2x_1T2016/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 14.8 s. Waiting...
  Elapsed 25.2 s. Waiting...
Query done.
Processed: 601.1 MB

Retrieving results...
  Got page: 1; 4% done. Elapsed 39.45 s.
  Got page: 2; 9% done. Elapsed 44.12 s.
  Got page: 3; 13% done. Elapsed 49.36 s.
  Got page: 4; 18% done. Elapsed 54.12 s.
  Got page: 5; 22% done. Elapsed 62.95 s.
  Got page: 6; 27% done. Elapsed 67.25 s.
  Got page: 7; 31% done. Elapsed 71.37 s.
  Got page: 8; 36% done. Elapsed 76.67 s.
  Got page: 9; 40% done. Elapsed 80.9 s.
  Got page: 10; 45% done. Elapsed 86.91 s.
  Got page: 11; 49% done. Elapsed 93.17 s.
  Got page: 12; 54% done. Elapsed 97.41 s.
  Got page: 13; 58% done. Elapsed 102.75 s.
  Got page: 14; 63% done. Elapsed 107.47 s.
  Got page: 15; 67% done. Elapsed 111.71 s.
  Got page: 16; 72% done. Elapsed 116.12 s.
  Got page: 17; 76% done. Elapsed 123.17 s.
  Got page: 18; 81% done. Elapsed 128.25 s.
  Got page: 19; 85% done. Elapsed 133.08 s.
  Got page: 20; 90% done. Elapsed 138.54 s.
  Got page: 21; 94% done. Elapsed 147.07 s.
  Got page: 22; 99% done. Elapsed 151.25 s.
  Got page: 23; 100% done. Elapsed 153.01 s.
Got 520405 rows.

Total time taken 174.92 s.
Finished at 2017-06-30 22:38:30.
Saved to ./../data/UseGen_2x_1T2016/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 8.7 KB

Retrieving results...
Got 147 rows.

Total time taken 0.98 s.
Finished at 2017-06-30 22:38:40.
Saved to ./../data/UseGen_2x_1T2016/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 349.6 KB

Retrieving results...
Got 1256 rows.

Total time taken 1.34 s.
Finished at 2017-06-30 22:38:43.
Saved to ./../data/UseGen_2x_1T2016/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 703.5 KB

Retrieving results...
Got 1212 rows.

Total time taken 1.8 s.
Finished at 2017-06-30 22:38:46.
Saved to ./../data/UseGen_2x_1T2016/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 498.9 KB

Retrieving results...
Got 71 rows.

Total time taken 1.01 s.
Finished at 2017-06-30 22:38:49.
Saved to ./../data/UseGen_2x_1T2016/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.2 MB

Retrieving results...
Got 7632 rows.

Total time taken 2.11 s.
Finished at 2017-06-30 22:38:52.
Saved to ./../data/UseGen_2x_1T2016/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 82.2 KB

Retrieving results...
Got 801 rows.

Total time taken 0.89 s.
Finished at 2017-06-30 22:38:54.
Saved to ./../data/UseGen_2x_1T2016/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 38.5 MB

Retrieving results...
  Got page: 1; 99% done. Elapsed 9.09 s.
  Got page: 2; 100% done. Elapsed 9.38 s.
Got 58779 rows.

Total time taken 10.06 s.
Finished at 2017-06-30 22:39:05.
Saved to ./../data/UseGen_2x_1T2016/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 270.2 KB

Retrieving results...
Got 801 rows.

Total time taken 1.13 s.
Finished at 2017-06-30 22:39:08.
Saved to ./../data/UseGen_2x_1T2016/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 541.2 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 11.32 s.
Got 1137 rows.

Total time taken 11.34 s.
Finished at 2017-06-30 22:39:21.
Saved to ./../data/UseGen_2x_1T2016/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.41 s. Waiting...
Query done.
Processed: 95.9 MB

Retrieving results...
  Got page: 1; 10% done. Elapsed 26.45 s.
  Got page: 2; 20% done. Elapsed 32.74 s.
  Got page: 3; 31% done. Elapsed 37.66 s.
  Got page: 4; 41% done. Elapsed 43.27 s.
  Got page: 5; 50% done. Elapsed 47.97 s.
  Got page: 6; 60% done. Elapsed 53.61 s.
  Got page: 7; 70% done. Elapsed 58.21 s.
  Got page: 8; 80% done. Elapsed 64.7 s.
  Got page: 9; 89% done. Elapsed 72.26 s.
  Got page: 10; 100% done. Elapsed 78.04 s.
  Got page: 11; 100% done. Elapsed 78.55 s.
Got 484225 rows.

Total time taken 89.88 s.
Finished at 2017-06-30 22:40:52.
Saved to ./../data/UseGen_2x_1T2016/page_dirt.csv
Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
[1] "Combining the JSON and XML elements..."
[1] "Adding the course order to forum_elements..."
[1] "Joining everything with forum elements..."
[1] "Saving everything to CSV..."
[1] "Complete. `wrangled_forum_posts`, `wrangled_forum_words`, `wrangled_forum_views`, `wrangled_forum_searches`, and `wrangled_forum_elements` have been saved to csv."
Requesting query... ok.
Query running...
Query done.
Processed: 2.4 MB

Retrieving results...
  Got page: 1; 73% done. Elapsed 10.37 s.
  Got page: 2; 100% done. Elapsed 12.74 s.
Got 53554 rows.

Total time taken 13.9 s.
Finished at 2017-06-30 22:45:42.
Saved to ./../data/UseGen_2x_3T2015/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 13.26 s. Waiting...
Query done.
Processed: 588.0 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 19.05 s.
Got 432 rows.

Total time taken 19.06 s.
Finished at 2017-06-30 22:46:03.
Saved to ./../data/UseGen_2x_3T2015/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 15.07 s. Waiting...
  Elapsed 25.46 s. Waiting...
  Elapsed 35.57 s. Waiting...
Query done.
Processed: 535.1 MB

Retrieving results...
  Got page: 1; 3% done. Elapsed 50.23 s.
  Got page: 2; 6% done. Elapsed 57.91 s.
  Got page: 3; 9% done. Elapsed 63.71 s.
  Got page: 4; 12% done. Elapsed 70.4 s.
  Got page: 5; 15% done. Elapsed 74.73 s.
  Got page: 6; 18% done. Elapsed 79.27 s.
  Got page: 7; 21% done. Elapsed 85.82 s.
  Got page: 8; 24% done. Elapsed 91.5 s.
  Got page: 9; 27% done. Elapsed 96.71 s.
  Got page: 10; 30% done. Elapsed 101.77 s.
  Got page: 11; 33% done. Elapsed 106.47 s.
  Got page: 12; 36% done. Elapsed 110.61 s.
  Got page: 13; 39% done. Elapsed 116.04 s.
  Got page: 14; 42% done. Elapsed 120.62 s.
  Got page: 15; 45% done. Elapsed 125.48 s.
  Got page: 16; 48% done. Elapsed 131.35 s.
  Got page: 17; 51% done. Elapsed 137.33 s.
  Got page: 18; 54% done. Elapsed 146.76 s.
  Got page: 19; 57% done. Elapsed 151.11 s.
  Got page: 20; 60% done. Elapsed 155.14 s.
  Got page: 21; 63% done. Elapsed 160.79 s.
  Got page: 22; 66% done. Elapsed 165.89 s.
  Got page: 23; 69% done. Elapsed 171.16 s.
  Got page: 24; 72% done. Elapsed 176.39 s.
  Got page: 25; 75% done. Elapsed 181.75 s.
  Got page: 26; 78% done. Elapsed 186.92 s.
  Got page: 27; 81% done. Elapsed 192.98 s.
  Got page: 28; 84% done. Elapsed 198.96 s.
  Got page: 29; 87% done. Elapsed 204.15 s.
  Got page: 30; 91% done. Elapsed 208.9 s.
  Got page: 31; 94% done. Elapsed 215.29 s.
  Got page: 32; 97% done. Elapsed 220.57 s.
Requesting query... ok.
Query running...
Query done.
Processed: 8.8 KB

Retrieving results...
Got 148 rows.

Total time taken 1.85 s.
Finished at 2017-06-30 22:50:18.
Saved to ./../data/UseGen_2x_3T2015/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 280.5 KB

Retrieving results...
Got 1582 rows.

Total time taken 2.64 s.
Finished at 2017-06-30 22:50:22.
Saved to ./../data/UseGen_2x_3T2015/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 840.9 KB

Retrieving results...
Got 1773 rows.

Total time taken 2.5 s.
Finished at 2017-06-30 22:50:26.
Saved to ./../data/UseGen_2x_3T2015/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 725.1 KB

Retrieving results...
Got 365 rows.

Total time taken 1.66 s.
Finished at 2017-06-30 22:50:29.
Saved to ./../data/UseGen_2x_3T2015/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.1 MB

Retrieving results...
Got 18223 rows.

Total time taken 3.29 s.
Finished at 2017-06-30 22:50:33.
Saved to ./../data/UseGen_2x_3T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 68.0 KB

Retrieving results...
Got 676 rows.

Total time taken 1.1 s.
Finished at 2017-06-30 22:50:36.
Saved to ./../data/UseGen_2x_3T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 32.6 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 8.33 s.
Got 52329 rows.

Total time taken 9.01 s.
Finished at 2017-06-30 22:50:46.
Saved to ./../data/UseGen_2x_3T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 225.9 KB

Retrieving results...
Got 676 rows.

Total time taken 0.99 s.
Finished at 2017-06-30 22:50:49.
Saved to ./../data/UseGen_2x_3T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 4.5 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 9.87 s.
Got 57 rows.

Total time taken 9.88 s.
Finished at 2017-06-30 22:51:00.
Saved to ./../data/UseGen_2x_3T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.86 s. Waiting...
Query done.
Processed: 4.4 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 16.36 s.
Got 21292 rows.

Total time taken 16.77 s.
Finished at 2017-06-30 22:51:18.
Saved to ./../data/UseGen_2x_3T2015/page_dirt.csv
[1] "Reading in the necessary files..."
Requesting query... ok.
Query running...
Query done.
Processed: 3.9 MB

Retrieving results...
  Got page: 1; 45% done. Elapsed 10.58 s.
  Got page: 2; 90% done. Elapsed 15.61 s.
  Got page: 3; 100% done. Elapsed 17.03 s.
Got 86615 rows.

Total time taken 19.38 s.
Finished at 2017-06-30 22:52:31.
Saved to ./../data/Water201x_2_2T2015/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 15.4 s. Waiting...
  Elapsed 25.88 s. Waiting...
Query done.
Processed: 719.4 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 28.86 s.
Got 707 rows.

Total time taken 28.88 s.
Finished at 2017-06-30 22:53:02.
Saved to ./../data/Water201x_2_2T2015/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 15.26 s. Waiting...
  Elapsed 25.64 s. Waiting...
  Elapsed 36.02 s. Waiting...
Query done.
Processed: 674.3 MB

Retrieving results...
  Got page: 1; 4% done. Elapsed 44.12 s.
  Got page: 2; 8% done. Elapsed 48.84 s.
  Got page: 3; 11% done. Elapsed 54.39 s.
  Got page: 4; 15% done. Elapsed 58.72 s.
  Got page: 5; 19% done. Elapsed 62.92 s.
  Got page: 6; 23% done. Elapsed 68.39 s.
  Got page: 7; 27% done. Elapsed 72.45 s.
  Got page: 8; 31% done. Elapsed 76.87 s.
  Got page: 9; 34% done. Elapsed 81.48 s.
  Got page: 10; 38% done. Elapsed 87.29 s.
  Got page: 11; 42% done. Elapsed 92.6 s.
  Got page: 12; 46% done. Elapsed 99.03 s.
  Got page: 13; 50% done. Elapsed 105.31 s.
  Got page: 14; 54% done. Elapsed 110.63 s.
  Got page: 15; 57% done. Elapsed 115.1 s.
  Got page: 16; 61% done. Elapsed 120.37 s.
  Got page: 17; 65% done. Elapsed 126.2 s.
  Got page: 18; 69% done. Elapsed 131.1 s.
  Got page: 19; 73% done. Elapsed 135.51 s.
  Got page: 20; 77% done. Elapsed 140.54 s.
  Got page: 21; 80% done. Elapsed 145.73 s.
  Got page: 22; 84% done. Elapsed 149.95 s.
  Got page: 23; 88% done. Elapsed 154.19 s.
  Got page: 24; 92% done. Elapsed 158.78 s.
  Got page: 25; 96% done. Elapsed 163.24 s.
  Got page: 26; 100% done. Elapsed 167.89 s.
  Got page: 27; 100% done. Elapsed 169.41 s.
Got 609678 rows.

Total time taken 195.24 s.
Finished at 2017-06-30 22:56:19.
Saved to ./../data/Water201x_2_2T2015/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.9 KB

Retrieving results...
Got 18 rows.

Total time taken 0.81 s.
Finished at 2017-06-30 22:56:29.
Saved to ./../data/Water201x_2_2T2015/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.2 MB

Retrieving results...
Got 5876 rows.

Total time taken 3.18 s.
Finished at 2017-06-30 22:56:34.
Saved to ./../data/Water201x_2_2T2015/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1006.5 KB

Retrieving results...
Got 1744 rows.

Total time taken 2.33 s.
Finished at 2017-06-30 22:56:38.
Saved to ./../data/Water201x_2_2T2015/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.1 MB

Retrieving results...
Got 321 rows.

Total time taken 1.09 s.
Finished at 2017-06-30 22:56:40.
Saved to ./../data/Water201x_2_2T2015/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.6 MB

Retrieving results...
Got 21537 rows.

Total time taken 3.63 s.
Finished at 2017-06-30 22:56:45.
Saved to ./../data/Water201x_2_2T2015/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 31.8 KB

Retrieving results...
Got 318 rows.

Total time taken 0.76 s.
Finished at 2017-06-30 22:56:47.
Saved to ./../data/Water201x_2_2T2015/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 58.1 MB

Retrieving results...
  Got page: 1; 70% done. Elapsed 10.0 s.
  Got page: 2; 100% done. Elapsed 12.38 s.
Got 82832 rows.

Total time taken 13.29 s.
Finished at 2017-06-30 22:57:02.
Saved to ./../data/Water201x_2_2T2015/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 108.4 KB

Retrieving results...
Got 318 rows.

Total time taken 1.04 s.
Finished at 2017-06-30 22:57:04.
Saved to ./../data/Water201x_2_2T2015/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 25.2 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 9.77 s.
Got 839 rows.

Total time taken 9.78 s.
Finished at 2017-06-30 22:57:15.
Saved to ./../data/Water201x_2_2T2015/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.53 s. Waiting...
Query done.
Processed: 12.3 MB

Retrieving results...
  Got page: 1; 79% done. Elapsed 25.11 s.
  Got page: 2; 100% done. Elapsed 26.94 s.
Got 65589 rows.

Total time taken 27.92 s.
Finished at 2017-06-30 22:57:44.
Saved to ./../data/Water201x_2_2T2015/page_dirt.csv
Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
Requesting query... ok.
Query running...
  Elapsed 11.07 s. Waiting...
Query done.
Processed: 1.9 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 23.85 s.
Got 30119 rows.

Total time taken 24.49 s.
Finished at 2017-06-30 22:59:45.
Saved to ./../data/Water201x_3T2014/demographic_multiple_choice.csv
Requesting query... ok.
Query running...
  Elapsed 14.3 s. Waiting...
  Elapsed 24.79 s. Waiting...
Query done.
Processed: 12.3 MB

Retrieving results...
Got 0 rows.

Total time taken 25.94 s.
Finished at 2017-06-30 23:00:12.
Saved to ./../data/Water201x_3T2014/open_assessment.csv
Requesting query... ok.
Query running...
  Elapsed 14.91 s. Waiting...
  Elapsed 25.41 s. Waiting...
  Elapsed 35.8 s. Waiting...
Query done.
Processed: 427.6 MB

Retrieving results...
  Got page: 1; 5% done. Elapsed 49.95 s.
  Got page: 2; 11% done. Elapsed 56.77 s.
  Got page: 3; 16% done. Elapsed 61.15 s.
  Got page: 4; 22% done. Elapsed 66.1 s.
  Got page: 5; 27% done. Elapsed 73.5 s.
  Got page: 6; 32% done. Elapsed 78.59 s.
  Got page: 7; 38% done. Elapsed 82.88 s.
  Got page: 8; 43% done. Elapsed 86.99 s.
  Got page: 9; 49% done. Elapsed 92.08 s.
  Got page: 10; 54% done. Elapsed 97.13 s.
  Got page: 11; 59% done. Elapsed 101.42 s.
  Got page: 12; 65% done. Elapsed 105.66 s.
  Got page: 13; 70% done. Elapsed 111.13 s.
  Got page: 14; 76% done. Elapsed 115.34 s.
  Got page: 15; 81% done. Elapsed 119.87 s.
  Got page: 16; 86% done. Elapsed 123.68 s.
  Got page: 17; 92% done. Elapsed 129.55 s.
  Got page: 18; 97% done. Elapsed 139.08 s.
  Got page: 19; 100% done. Elapsed 141.73 s.
Got 431919 rows.

Total time taken 155.6 s.
Finished at 2017-06-30 23:02:49.
Saved to ./../data/Water201x_3T2014/generalized_video_heat.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.9 KB

Retrieving results...
Got 18 rows.

Total time taken 0.87 s.
Finished at 2017-06-30 23:02:57.
Saved to ./../data/Water201x_3T2014/generalized_video_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 598.2 KB

Retrieving results...
Got 3544 rows.

Total time taken 2.5 s.
Finished at 2017-06-30 23:03:01.
Saved to ./../data/Water201x_3T2014/generalized_demographics.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.7 MB

Retrieving results...
Got 2403 rows.

Total time taken 2.99 s.
Finished at 2017-06-30 23:03:05.
Saved to ./../data/Water201x_3T2014/forum_posts.csv
Requesting query... ok.
Query running...
Query done.
Processed: 969.8 KB

Retrieving results...
Got 393 rows.

Total time taken 1.02 s.
Finished at 2017-06-30 23:03:07.
Saved to ./../data/Water201x_3T2014/forum_searches.csv
Requesting query... ok.
Query running...
Query done.
Processed: 2.7 MB

Retrieving results...
Got 25396 rows.

Total time taken 3.38 s.
Finished at 2017-06-30 23:03:11.
Saved to ./../data/Water201x_3T2014/forum_views.csv
Requesting query... ok.
Query running...
Query done.
Processed: 28.3 KB

Retrieving results...
Got 295 rows.

Total time taken 0.75 s.
Finished at 2017-06-30 23:03:14.
Saved to ./../data/Water201x_3T2014/tower_item.csv
Requesting query... ok.
Query running...
Query done.
Processed: 28.3 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 7.51 s.
Got 56372 rows.

Total time taken 8.2 s.
Finished at 2017-06-30 23:03:23.
Saved to ./../data/Water201x_3T2014/tower_engage_dirt.csv
Requesting query... ok.
Query running...
Query done.
Processed: 97.6 KB

Retrieving results...
Got 295 rows.

Total time taken 0.91 s.
Finished at 2017-06-30 23:03:26.
Saved to ./../data/Water201x_3T2014/course_axis.csv
Requesting query... ok.
Query running...
Query done.
Processed: 1.1 MB

Retrieving results...
  Got page: 1; 100% done. Elapsed 9.33 s.
Got 50 rows.

Total time taken 9.34 s.
Finished at 2017-06-30 23:03:36.
Saved to ./../data/Water201x_3T2014/external_link_dirt.csv
Requesting query... ok.
Query running...
  Elapsed 12.73 s. Waiting...
Query done.
Processed: 766.9 KB

Retrieving results...
  Got page: 1; 100% done. Elapsed 13.62 s.
Got 3574 rows.

Total time taken 13.67 s.
Finished at 2017-06-30 23:03:51.
Saved to ./../data/Water201x_3T2014/page_dirt.csv
Multiple Choice JSON Ready
Assessment JSON Ready
[1] "Reading in the necessary files..."
[1] "Preparing the forum views data..."
[1] "Preparing the forum posts data..."
[1] "     Getting activity levels..."
[1] "     Getting post types..."
[1] "     Inferring post subcategories..."
[1] "          Counting comments..."
[1] "          Counting responses..."
[1] "Preparing the forum words data..."
[1] "Preparing the forum searches data..."
[1] "Preparing the JSON elements..."
[1] "Getting `discussion_topics`"
[1] "Preparing the XML elements..."
